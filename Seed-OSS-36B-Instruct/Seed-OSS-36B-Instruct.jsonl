{"cve": "CVE-2025-48374", "fix_patch": "--- a/pkg/api/config/config.go\n+++ b/pkg/api/config/config.go\n@@ -341,6 +341,19 @@\n \t\tsanitizedConfig.HTTP.Auth.LDAP.bindPassword = \"******\"\n \t}\n \n+\t// Sanitize OIDC client secrets\n+\tif c.HTTP.Auth != nil && c.HTTP.Auth.OpenID != nil {\n+\t\tsanitizedConfig.HTTP.Auth.OpenID = &OpenIDConfig{\n+\t\t\tProviders: make(map[string]OpenIDProviderConfig, len(c.HTTP.Auth.OpenID.Providers)),\n+\t\t}\n+\n+\t\tfor name, provider := range c.HTTP.Auth.OpenID.Providers {\n+\t\t\tsanitizedProvider := provider\n+\t\t\tsanitizedProvider.ClientSecret = \"******\"\n+\t\t\tsanitizedConfig.HTTP.Auth.OpenID.Providers[name] = sanitizedProvider\n+\t\t}\n+\t}\n+\n \tif c.IsEventRecorderEnabled() {\n \t\tfor i, sink := range c.Extensions.Events.Sinks {\n \t\t\tif sink.Credentials == nil {\n\n"}
{"cve": "CVE-2023-40029", "fix_patch": "--- a/util/db/cluster.go\n+++ b/util/db/cluster.go\n@@ -344,8 +344,14 @@\n \t}\n \tsecret.Data = data\n \n-\tsecret.Labels = c.Labels\n-\tsecret.Annotations = c.Annotations\n+\t// Copy labels to avoid reference sharing\n+\tsecret.Labels = collections.CopyStringMap(c.Labels)\n+\t// Copy annotations and remove sensitive last-applied-configuration annotation\n+\tannotations := collections.CopyStringMap(c.Annotations)\n+\tif annotations != nil {\n+\t\tdelete(annotations, \"kubectl.kubernetes.io/last-applied-configuration\")\n+\t}\n+\tsecret.Annotations = annotations\n \n \tif secret.Annotations == nil {\n \t\tsecret.Annotations = make(map[string]string)\n\n"}
{"cve": "CVE-2022-23538", "fix_patch": "--- a/client/pull.go\n+++ b/client/pull.go\n@@ -104,12 +104,14 @@\n \n // httpGetRangeRequest performs HTTP GET range request to URL specified by 'u' in range start-end.\n func (c *Client) httpGetRangeRequest(ctx context.Context, url string, start, end int64) (*http.Response, error) {\n-\treq, err := c.newRequestWithURL(ctx, http.MethodGet, url, nil)\n+\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n+\t// Add only necessary headers - exclude Authorization for S3 storage\n \treq.Header.Add(\"Range\", fmt.Sprintf(\"bytes=%d-%d\", start, end))\n+\treq.Header.Add(\"User-Agent\", c.HTTPClient.Transport.(*http.Transport).Proxy.(func(*http.Request)(*url.URL, error)).(func(*http.Request) (*url.URL, error)).(func(*http.Request) (*url.URL, error))(req).UserAgent)\n \n \treturn c.HTTPClient.Do(req)\n }\n\n"}
{"cve": "CVE-2024-24747", "fix_patch": "--- a/cmd/admin-handlers-users.go\n+++ b/cmd/admin-handlers-users.go\n@@ -824,6 +824,23 @@\n \t\t\tsp = nil\n \t\t}\n \t}\n+\n+\t// Block non-root users from granting admin privileges to service accounts\n+\tif sp != nil {\n+\t\tfor _, stmt := range sp.Statements {\n+\t\t\tif stmt.Effect == policy.Allow {\n+\t\t\t\tfor _, action := range stmt.Action {\n+\t\t\t\t\tif strings.HasPrefix(action, \"admin:\") {\n+\t\t\t\t\t\tif cred.AccessKey != globalActiveCred.AccessKey {\n+\t\t\t\t\t\t\twriteErrorResponseJSON(ctx, w, errorCodes.ToAPIErr(ErrAccessDenied), r.URL)\n+\t\t\t\t\t\t\treturn\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \topts := updateServiceAccountOpts{\n \t\tsecretKey:     updateReq.NewSecretKey,\n \t\tstatus:        updateReq.NewStatus,\n\n"}
{"cve": "CVE-2024-47616", "fix_patch": ""}
{"cve": "CVE-2023-24623", "fix_patch": "--- a/client.go\n+++ b/client.go\n@@ -121,6 +121,11 @@\n \n \tip := net.ParseIP(host)\n \tif ip != nil {\n+\t\t// Block IPv6 loopback [::] which is equivalent to 127.0.0.1\n+\t\tif ip.IsLoopback() {\n+\t\t\treturn \"\", fmt.Errorf(\"bad ip is detected: %v\", ip)\n+\t\t}\n+\t\t// Check IPv4 addresses against forbidden list\n \t\tif ip.To4() != nil && c.isIPForbidden(ip) {\n \t\t\treturn \"\", fmt.Errorf(\"bad ip is detected: %v\", ip)\n \t\t}\n@@ -143,6 +148,10 @@\n \tfor _, addr := range addrs {\n \t\t// only support IPv4 address\n \t\tif addr.IP.To4() == nil {\n+\t\t\t// Block IPv6 loopback addresses in DNS results too\n+\t\t\tif addr.IP.IsLoopback() {\n+\t\t\t\treturn \"\", fmt.Errorf(\"bad ip is detected: %v\", addr.IP)\n+\t\t\t}\n \t\t\tcontinue\n \t\t}\n \t\tif c.isIPForbidden(addr.IP) {\n\n"}
{"cve": "CVE-2019-10787", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -1,4 +1,4 @@\n-var exec = require('child_process').exec;\n+var execFile = require('child_process').execFile;\n var aspect = require('aspectratio');\n var dirname = require('path').dirname;\n var basename = require('path').basename;\n@@ -7,8 +7,8 @@\n var sprintf = require('util').format;\n \n module.exports = function(image, output, cb) {\n-  var cmd = module.exports.cmd(image, output);\n-  exec(cmd, {timeout: 30000}, function(e, stdout, stderr) {\n+  var cmdArgs = module.exports.cmd(image, output);\n+  execFile('convert', cmdArgs, {timeout: 30000}, function(e, stdout, stderr) {\n     if (e) { return cb(e); }\n     if (stderr) { return cb(new Error(stderr)); }\n \n@@ -107,9 +107,13 @@\n  */\n module.exports.cmd = function(image, output) {\n   var cmd = [\n-    sprintf(\n-      'convert %s -auto-orient -strip -write mpr:%s +delete', image.path, image.path\n-    )\n+    'convert',\n+    image.path,\n+    '-auto-orient',\n+    '-strip',\n+    '-write',\n+    'mpr:' + image.path,\n+    '+delete'\n   ];\n \n   for (var i = 0; i < output.versions.length; i++) {\n@@ -128,7 +132,7 @@\n     cmd.push(module.exports.cmdVersion(image, version, last));\n   }\n \n-  return cmd.join(' ');\n+  return cmd;\n };\n \n /**\n@@ -144,16 +148,16 @@\n   var cmd = [];\n \n   // http://www.imagemagick.org/Usage/files/#mpr\n-  cmd.push(sprintf('mpr:%s', image.path));\n+  cmd.push('mpr:' + image.path);\n \n   // -quality\n   if (version.quality) {\n-    cmd.push(sprintf('-quality %d', version.quality));\n+    cmd.push('-quality', version.quality);\n   }\n \n   // -background\n   if (version.background) {\n-    cmd.push(sprintf('-background \"%s\"', version.background));\n+    cmd.push('-background', version.background);\n   }\n \n   // -flatten\n@@ -164,22 +168,22 @@\n   // -crop\n   var crop = module.exports.crop(image, version.aspect);\n   if (crop.geometry) {\n-    cmd.push(sprintf('-crop \"%s\"', crop.geometry));\n+    cmd.push('-crop', crop.geometry);\n   }\n \n   // -resize\n   // http://www.imagemagick.org/script/command-line-processing.php#geometry\n   var resize = module.exports.resize(crop, version);\n   if (resize) {\n-    cmd.push(sprintf('-resize \"%s\"', resize));\n+    cmd.push('-resize', resize);\n   }\n \n   // -write\n   if (last) {\n     cmd.push(version.path);\n   } else {\n-    cmd.push(sprintf('-write %s +delete', version.path));\n+    cmd.push('-write', version.path, '+delete');\n   }\n \n-  return cmd.join(' ');\n+  return cmd;\n };\n\n"}
{"cve": "CVE-2020-29529", "fix_patch": "--- a/slug.go\n+++ b/slug.go\n@@ -230,6 +230,13 @@\n \t\t}\n \t\tpath = filepath.Join(dst, path)\n \n+\t\t// Validate path does not escape destination directory\n+\t\tcleanDst := filepath.Clean(dst) + string(filepath.Separator)\n+\t\tcleanPath := filepath.Clean(path)\n+\t\tif !strings.HasPrefix(cleanPath, cleanDst) {\n+\t\t\treturn fmt.Errorf(\"Invalid path %q escapes destination directory\", header.Name)\n+\t\t}\n+\n \t\t// Make the directories to the path.\n \t\tdir := filepath.Dir(path)\n \t\tif err := os.MkdirAll(dir, 0755); err != nil {\n@@ -247,7 +254,8 @@\n \t\t\t// Ensure the link target is within the destination directory. This\n \t\t\t// disallows providing symlinks to external files and directories.\n \t\t\ttarget := filepath.Join(dir, header.Linkname)\n-\t\t\tif !strings.HasPrefix(target, dst) {\n+\t\t\tcleanTarget := filepath.Clean(target)\n+\t\t\tif !strings.HasPrefix(cleanTarget, cleanDst) {\n \t\t\t\treturn fmt.Errorf(\"Invalid symlink (%q -> %q) has external target\",\n \t\t\t\t\theader.Name, header.Linkname)\n \t\t\t}\n\n"}
{"cve": "CVE-2021-26921", "fix_patch": "--- a/util/session/sessionmanager.go\n+++ b/util/session/sessionmanager.go\n@@ -281,6 +281,10 @@\n \taccount, err := mgr.settingsMgr.GetAccount(subject)\n \tif err != nil {\n \t\treturn nil, err\n+\t}\n+\n+\tif !account.Enabled {\n+\t\treturn nil, status.Errorf(codes.Unauthenticated, accountDisabled, subject)\n \t}\n \n \tif id := jwtutil.StringField(claims, \"jti\"); id != \"\" && account.TokenIndex(id) == -1 {\n\n"}
{"cve": "CVE-2020-7687", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -10,29 +10,41 @@\n     if (port === undefined) port = 80;\n     var server = http.createServer(function (req, res) {\n \n-        var uri = url.parse(req.url).pathname,\n-            filename = path.join(root, uri);\n+        var uri = url.parse(req.url).pathname;\n+        var initialPath = path.join(root, uri);\n+        var resolvedPath = path.resolve(initialPath);\n \n-        if (uri.charAt(uri.length - 1) === '/') {\n-            filename += 'index.html';\n+        // Check for path traversal attacks\n+        const relativePath = path.relative(root, resolvedPath);\n+        if (relativePath.startsWith('..') || path.isAbsolute(relativePath)) {\n+            if (wordy) console.log('Error 403: Path traversal attempt');\n+            res.writeHead(403, {'Content-Type': 'text/plain'});\n+            res.end('Forbidden');\n+            return;\n         }\n \n-        if (wordy) console.log('GET:' + uri + ' -> ' + filename);\n+        // Handle directory index files\n+        var finalFilename = resolvedPath;\n+        if (uri.charAt(uri.length - 1) === '/') {\n+            finalFilename = path.join(resolvedPath, 'index.html');\n+        }\n \n-        fs.exists(filename, function (exists) {\n+        if (wordy) console.log('GET:' + uri + ' -> ' + finalFilename);\n+\n+        fs.exists(finalFilename, function (exists) {\n             if (!exists) {\n                 if (wordy) console.log('Error 404');\n                 res.writeHead(404, {'Content-Type': 'text/plain'});\n                 res.end('Error 404');\n                 return;\n             }\n-            if (fs.statSync(filename).isDirectory() && uri.charAt(uri.length - 1) !== '/') {\n+            if (fs.statSync(finalFilename).isDirectory() && uri.charAt(uri.length - 1) !== '/') {\n                 if (wordy) console.log('Redirection 303');\n                 res.writeHead(303,{ 'Location': uri + '/' });\n                 res.end('Redirecting to: ' + uri + '/');\n                 return;\n             }\n-            fs.readFile(filename, 'binary', function(err, file) {\n+            fs.readFile(finalFilename, 'binary', function(err, file) {\n                 if(err) {\n                     if (wordy) console.log('Error 500');\n                     res.writeHead(500, {'Content-Type': 'text/plain'});\n@@ -41,7 +53,7 @@\n                 }\n                 if (wordy) console.log('Ok 200');\n                 res.writeHead(200, {\n-                    'Content-Type': mime.lookup(filename) + ';' + mime.charsets.lookup(mime.lookup(filename)) \n+                    'Content-Type': mime.lookup(finalFilename) + ';' + mime.charsets.lookup(mime.lookup(finalFilename)) \n                 });\n                 res.write(file, 'binary');\n                 res.end();\n\n"}
{"cve": "CVE-2020-15084", "fix_patch": "--- a/lib/index.js\n+++ b/lib/index.js\n@@ -18,6 +18,11 @@\n \n module.exports = function(options) {\n   if (!options || !options.secret) throw new Error('secret should be set');\n+\n+  // Enforce algorithms requirement for secret callbacks to prevent authorization bypass\n+  if (isFunction(options.secret) && !options.algorithms) {\n+    throw new Error('When using a secret callback (e.g. jwks-rsa), the \"algorithms\" option must be specified to prevent authorization bypass');\n+  }\n \n   var secretCallback = options.secret;\n \n\n"}
{"cve": "CVE-2021-23727", "fix_patch": "\n\n"}
{"cve": "CVE-2022-1992", "fix_patch": "--- a/internal/pathutil/pathutil.go\n+++ b/internal/pathutil/pathutil.go\n@@ -11,5 +11,9 @@\n \n // Clean cleans up given path and returns a relative path that goes straight down.\n func Clean(p string) string {\n-\treturn strings.Trim(path.Clean(\"/\"+p), \"/\")\n+\tp = path.Clean(p)\n+\tif p == \"\" || p[0] == '/' || strings.Contains(p, \"..\") {\n+\t\treturn \"\"\n+\t}\n+\treturn p\n }\n\n"}
{"cve": "CVE-2022-2024", "fix_patch": "--- a/internal/db/repo_editor.go\n+++ b/internal/db/repo_editor.go\n@@ -485,14 +485,12 @@\n \n // isRepositoryGitPath returns true if given path is or resides inside \".git\"\n // path of the repository.\n-func isRepositoryGitPath(path string) bool {\n-\treturn strings.HasSuffix(path, \".git\") ||\n-\t\tstrings.Contains(path, \".git/\") ||\n-\t\tstrings.Contains(path, `.git\\`) ||\n-\t\t// Windows treats \".git.\" the same as \".git\"\n-\t\tstrings.HasSuffix(path, \".git.\") ||\n-\t\tstrings.Contains(path, \".git./\") ||\n-\t\tstrings.Contains(path, `.git.\\`)\n+func isRepositoryGitPath(baseDir, relPath string) bool {\n+\tfullPath := path.Join(baseDir, relPath)\n+\tcleanPath := path.Clean(fullPath)\n+\tgitDir := path.Join(baseDir, \".git\")\n+\tcleanGitDir := path.Clean(gitDir) + string(os.PathSeparator)\n+\treturn strings.HasPrefix(cleanPath, cleanGitDir)\n }\n \n func (repo *Repository) UploadRepoFiles(doer *User, opts UploadRepoFileOptions) error {\n\n"}
{"cve": "CVE-2021-29417", "fix_patch": "--- a/internal/pkg/gitjacker/retriever.go\n+++ b/internal/pkg/gitjacker/retriever.go\n@@ -160,7 +160,17 @@\n \n \tpath = strings.TrimSpace(path)\n \n-\tfilePath := filepath.Join(r.outputDir, \".git\", path)\n+\t// Validate path to prevent directory traversal attacks\n+\tbaseDir := filepath.Join(r.outputDir, \".git\")\n+\tfullPath := filepath.Join(baseDir, path)\n+\tcleanedPath := filepath.Clean(fullPath)\n+\n+\t// Ensure path stays within .git directory boundaries\n+\tif cleanedPath != baseDir && !strings.HasPrefix(cleanedPath, baseDir+string(filepath.Separator)) {\n+\t\treturn fmt.Errorf(\"path traversal attempt blocked: %s\", path)\n+\t}\n+\n+\tfilePath = cleanedPath\n \n \tif r.downloaded[path] {\n \t\treturn nil\n\n"}
{"cve": "CVE-2022-21699", "fix_patch": "--- a/IPython/core/application.py\n+++ b/IPython/core/application.py\n@@ -157,7 +157,7 @@\n     config_file_paths = List(Unicode())\n     @default('config_file_paths')\n     def _config_file_paths_default(self):\n-        return [os.getcwd()]\n+        return []\n \n     extra_config_file = Unicode(\n     help=\"\"\"Path to an extra config file to load.\n\n--- a/IPython/core/profiledir.py\n+++ b/IPython/core/profiledir.py\n@@ -188,8 +188,7 @@\n         is not found, a :class:`ProfileDirError` exception will be raised.\n \n         The search path algorithm is:\n-        1. ``os.getcwd()``\n-        2. ``ipython_dir``\n+        1. ``ipython_dir``\n \n         Parameters\n         ----------\n@@ -200,7 +199,7 @@\n             will be \"profile_<profile>\".\n         \"\"\"\n         dirname = u'profile_' + name\n-        paths = [os.getcwd(), ipython_dir]\n+        paths = [ipython_dir]\n         for p in paths:\n             profile_dir = os.path.join(p, dirname)\n             if os.path.isdir(profile_dir):\n\n"}
{"cve": "CVE-2024-42005", "fix_patch": "\n\n"}
{"cve": "CVE-2020-15233", "fix_patch": "--- a/authorize_helper.go\n+++ b/authorize_helper.go\n@@ -135,7 +135,13 @@\n \t\treturn false\n \t}\n \n-\tif requested.Scheme == \"http\" && isLoopbackAddress(requested.Host) && registered.Path == requested.Path {\n+\t// Require exact host match for loopback URIs to prevent host override attacks\n+\tif requested.Host != registered.Host {\n+\t\treturn false\n+\t}\n+\n+\t// Require exact path and query match for loopback URIs to prevent parameter injection\n+\tif requested.Scheme == \"http\" && isLoopbackAddress(requested.Host) && registered.Path == requested.Path && registered.RawQuery == requested.RawQuery {\n \t\treturn true\n \t}\n \n\n"}
{"cve": "CVE-2018-16482", "fix_patch": "--- a/lib/staticFileHandler.js\n+++ b/lib/staticFileHandler.js\n@@ -13,15 +13,26 @@\n     assert(options.deleteMockPaths,'A delete mock path object must be defined');\n \n     return function(req,res){\n-        var root = options.root;\n+        var root = path.resolve(options.root);\n         var mockPaths = getMockPathForMethod(options,req.method);\n \n         var filePath = httpHelpers.getRequestPathFromUrl(req.url);\n+        // Decode URL-encoded characters to handle spaces and encoded traversal attempts\n+        try {\n+            filePath = decodeURIComponent(filePath);\n+        } catch (err) {\n+            return statusHandlers[400](res, nextHandler, { error: 'Invalid URL encoding' });\n+        }\n         var mockedFilePath = findMockFilePath(filePath,mockPaths);\n         if(mockedFilePath)\n             filePath = mockedFilePath;\n \n-        var file = path.normalize(path.join(root,filePath));\n+        var file = path.resolve(root, filePath);\n+        // Check if file is outside restricted directory to prevent path traversal\n+        var relativePath = path.relative(root, file);\n+        if (relativePath.startsWith('..')) {\n+            return statusHandlers[403](res, nextHandler, { error: 'Path traversal attempt' });\n+        }\n         fs.stat(file,function(error, stats){\n             if(error)\n                 return statusHandlers[500](res, nextHandler, { error: error });\n\n"}
{"cve": "CVE-2023-6831", "fix_patch": "--- a/mlflow/utils/uri.py\n+++ b/mlflow/utils/uri.py\n@@ -425,22 +425,41 @@\n     measure to prevent path traversal attacks.\n     A valid path should:\n         not contain separators other than '/'\n-        not contain .. to navigate to parent dir in path\n+        not contain .. to navigate to parent dir in path (including URL-encoded variants)\n         not be an absolute path\n     \"\"\"\n     from mlflow.utils.file_utils import local_file_uri_to_path\n \n     exc = MlflowException(f\"Invalid path: {path}\", error_code=INVALID_PARAMETER_VALUE)\n+    \n+    # Check for URL fragments and problematic characters\n     if any((s in path) for s in (\"#\", \"%23\")):\n         raise exc\n \n+    # Convert file URIs to local paths first\n     if is_file_uri(path):\n         path = local_file_uri_to_path(path)\n+\n+    # Check for alternate separators (e.g. \\ on Windows)\n+    if any((s in path) for s in _OS_ALT_SEPS):\n+        raise exc\n+\n+    # Normalize path and check for traversal sequences\n+    normalized_path = posixpath.normpath(path)\n+    \n+    # Check for path traversal sequences (including URL-encoded variants)\n     if (\n-        any((s in path) for s in _OS_ALT_SEPS)\n-        or \"..\" in path.split(\"/\")\n+        \"..\" in normalized_path.split(posixpath.sep)\n+        or \"%2e%2e\" in path.lower()\n+        or \"%2e%2e/\" in path.lower()\n+        or \"/%2e%2e\" in path.lower()\n+    ):\n+        raise exc\n+\n+    # Check for absolute paths\n+    if (\n+        posixpath.isabs(normalized_path)\n         or pathlib.PureWindowsPath(path).is_absolute()\n-        or pathlib.PurePosixPath(path).is_absolute()\n         or (is_windows() and len(path) >= 2 and path[1] == \":\")\n     ):\n         raise exc\n\n"}
{"cve": "CVE-2023-29159", "fix_patch": "--- a/starlette/staticfiles.py\n+++ b/starlette/staticfiles.py\n@@ -169,9 +169,13 @@\n             else:\n                 full_path = os.path.realpath(joined_path)\n             directory = os.path.realpath(directory)\n-            if os.path.commonprefix([full_path, directory]) != directory:\n-                # Don't allow misbehaving clients to break out of the static files\n-                # directory.\n+            try:\n+                if os.path.commonpath([full_path, directory]) != directory:\n+                    # Don't allow misbehaving clients to break out of the static files\n+                    # directory.\n+                    continue\n+            except ValueError:\n+                # Paths are unrelated or on different drives\n                 continue\n             try:\n                 return full_path, os.stat(full_path)\n\n"}
{"cve": "CVE-2022-21683", "fix_patch": "--- a/wagtail/admin/views/pages/edit.py\n+++ b/wagtail/admin/views/pages/edit.py\n@@ -139,8 +139,9 @@\n         global_recipient_users = [subscriber.user for subscriber in subscribers if subscriber.user != self.request.user]\n \n         # Get subscribers to individual threads\n-        replies = CommentReply.objects.filter(comment_id__in=relevant_comment_ids)\n-        comments = Comment.objects.filter(id__in=relevant_comment_ids)\n+        # Restrict to comments/replies on the current page only\n+        replies = CommentReply.objects.filter(comment_id__in=relevant_comment_ids, comment__page=self.page)\n+        comments = Comment.objects.filter(id__in=relevant_comment_ids, page=self.page)\n         thread_users = get_user_model().objects.exclude(pk=self.request.user.pk).exclude(pk__in=subscribers.values_list('user_id', flat=True)).prefetch_related(\n             Prefetch('comment_replies', queryset=replies),\n             Prefetch(COMMENTS_RELATION_NAME, queryset=comments)\n\n"}
{"cve": "CVE-2020-7795", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -11,9 +11,9 @@\n         }\n \n         if (registry) {\n-            version = require('child_process').execSync(`npm view ${packageName} version --registry ${registry}`, config);\n+            version = require('child_process').execFileSync('npm', ['view', packageName, 'version', '--registry', registry], config);\n         } else {\n-            version = require('child_process').execSync(`npm view ${packageName} version`, config);\n+            version = require('child_process').execFileSync('npm', ['view', packageName, 'version'], config);\n         }\n \n         if (version) {\n\n"}
{"cve": "CVE-2020-7674", "fix_patch": "--- a/lib/encode.js\n+++ b/lib/encode.js\n@@ -1,9 +1,48 @@\n 'use strict';\n \n-function template(literal, data) {\n-  var tmpl = literal.replace(/(\\$\\{)/gm, '$1data.');\n+function replacePlaceholders(str, data) {\n+  return str.replace(/\\${([^}]+)}/g, (match, key) => {\n+    const parts = key.split('.');\n+    let value = data;\n+    for (const part of parts) {\n+      if (value == null || typeof value !== 'object' || !(part in value)) {\n+        return match;\n+      }\n+      value = value[part];\n+    }\n+    return value !== undefined ? value : match;\n+  });\n+}\n \n-  return eval('`' + tmpl + '`');\n+function processObject(obj, data) {\n+  if (Array.isArray(obj)) {\n+    return obj.map(item => {\n+      if (item === undefined) {\n+        return null;\n+      } else if (typeof item === 'object' && item !== null) {\n+        return processObject(item, data);\n+      } else {\n+        return item;\n+      }\n+    });\n+  }\n+\n+  const result = {};\n+  for (const [key, value] of Object.entries(obj)) {\n+    if (value === undefined || typeof value === 'function') {\n+      continue;\n+    }\n+\n+    if (typeof value === 'string') {\n+      result[key] = replacePlaceholders(value, data);\n+    } else if (typeof value === 'object' && value !== null) {\n+      result[key] = processObject(value, data);\n+    } else {\n+      result[key] = value;\n+    }\n+  }\n+\n+  return result;\n }\n \n function encodeStatements(statements, data) {\n@@ -15,8 +54,7 @@\n     return statements;\n   }\n \n-  var output = template(JSON.stringify(statements), data);\n-  output = JSON.parse(output);\n+  const output = processObject(statements, data);\n \n   Object.defineProperty(output, 'encoded', {\n     __proto__: null,\n\n"}
{"cve": "CVE-2021-23384", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -52,7 +52,7 @@\n }\n \n function haveSlash(path) {\n-    return path !== '/' && path.slice(-1) === '/';\n+    return path.startsWith('/') && !path.startsWith('//') && path !== '/' && path.slice(-1) === '/';\n }\n \n function getPath(original, querystring) {\n\n"}
{"cve": "CVE-2022-23542", "fix_patch": "--- a/server/commands/check_utils.go\n+++ b/server/commands/check_utils.go\n@@ -345,6 +345,12 @@\n \tif err != nil {\n \t\treturn nil, err\n \t}\n+\n+\t// Validate the tuple against the authorization model to prevent authorization bypass\n+\tif !validation.IsValidTuple(rc.model, tuple.GetKey()) {\n+\t\treturn nil, fmt.Errorf(\"invalid tuple: %v\", tuple.GetKey())\n+\t}\n+\n \treturn tuple.GetKey(), nil\n }\n \n\n"}
{"cve": "CVE-2023-33977", "fix_patch": "--- a/tcms/kiwi_attachments/validators.py\n+++ b/tcms/kiwi_attachments/validators.py\n@@ -3,9 +3,15 @@\n \n \n def deny_uploads_containing_script_tag(uploaded_file):\n+    pattern = b\"<script\"\n+    buffer = b\"\"\n     for chunk in uploaded_file.chunks(2048):\n-        if chunk.lower().find(b\"<script\") > -1:\n+        chunk_lower = chunk.lower()\n+        combined = buffer + chunk_lower\n+        if combined.find(pattern) > -1:\n             raise ValidationError(_(\"File contains forbidden <script> tag\"))\n+        # Keep up to (pattern length -1) bytes for next chunk check\n+        buffer = combined[-len(pattern)+1:] if len(combined) >= len(pattern)-1 else combined\n \n \n def deny_uploads_ending_in_dot_exe(uploaded_file):\n\n"}
{"cve": "CVE-2024-53900", "fix_patch": "--- a/lib/helpers/populate/getModelsMapForPopulate.js\n+++ b/lib/helpers/populate/getModelsMapForPopulate.js\n@@ -184,6 +184,14 @@\n     if (hasMatchFunction) {\n       match = match.call(doc, doc);\n     }\n+\n+    // Block $where in populate match unless strict mode is disabled\n+    if (match && typeof match === 'object' && '$where' in match) {\n+      if (!isStrictPopulateDisabled) {\n+        return new StrictPopulate(`Populate 'match' option for path '${options.path}' cannot contain $where`);\n+      }\n+    }\n+\n     data.match = match;\n     data.hasMatchFunction = hasMatchFunction;\n     data.isRefPath = isRefPath;\n\n"}
{"cve": "CVE-2020-8559", "fix_patch": "\n\n"}
{"cve": "CVE-2021-3155", "fix_patch": "\n\n"}
{"cve": "CVE-2024-39877", "fix_patch": "--- a/airflow/models/dag.py\n+++ b/airflow/models/dag.py\n@@ -775,7 +775,7 @@\n         env = self.get_template_env(force_sandboxed=True)\n \n         if not doc_md.endswith(\".md\"):\n-            template = jinja2.Template(doc_md)\n+            template = env.from_string(doc_md)\n         else:\n             try:\n                 template = env.get_template(doc_md)\n\n"}
{"cve": "CVE-2024-3848", "fix_patch": "--- a/mlflow/server/handlers.py\n+++ b/mlflow/server/handlers.py\n@@ -598,9 +598,27 @@\n \n     tags = [ExperimentTag(tag.key, tag.value) for tag in request_message.tags]\n \n-    # Validate query string in artifact location to prevent attacks\n-    parsed_artifact_locaion = urllib.parse.urlparse(request_message.artifact_location)\n-    validate_query_string(parsed_artifact_locaion.query)\n+    # Validate query string and fragment in artifact location to prevent attacks\n+    parsed_artifact_location = urllib.parse.urlparse(request_message.artifact_location)\n+    validate_query_string(parsed_artifact_location.query)\n+    \n+    # Validate fragment for path traversal attacks\n+    if parsed_artifact_location.fragment:\n+        fragment = urllib.parse.unquote(parsed_artifact_location.fragment)\n+        if \"\\x00\" in fragment:\n+            raise MlflowException(\n+                f\"Invalid artifact location: '{request_message.artifact_location}'. Fragment contains null byte.\",\n+                error_code=INVALID_PARAMETER_VALUE,\n+            )\n+        # Normalize and resolve fragment to check for relative paths\n+        normalized_fragment = re.sub(r\"/+\", \"/\", fragment.rstrip(\"/\"))\n+        resolved_fragment = pathlib.Path(normalized_fragment).resolve().as_posix()\n+        _, resolved_fragment_path = os.path.splitdrive(resolved_fragment)\n+        if resolved_fragment_path != normalized_fragment:\n+            raise MlflowException(\n+                f\"Invalid artifact location: '{request_message.artifact_location}'. Fragment contains relative path traversal.\",\n+                error_code=INVALID_PARAMETER_VALUE,\n+            )\n \n     experiment_id = _get_tracking_store().create_experiment(\n         request_message.name, request_message.artifact_location, tags\n@@ -1698,6 +1716,8 @@\n     \"file://path/to/../../../../some/where/you/should/not/be\"\n     \"mlflow-artifacts://host:port/..%2f..%2f..%2f..%2f\"\n     \"http://host:port/api/2.0/mlflow-artifacts/artifacts%00\"\n+    \"mlflow-artifacts://host:port/path#../../../../etc/passwd\"\n+    \"http://host:port/path#../etc/passwd\"\n     \"\"\"\n     invalid_source_error_message = (\n         f\"Invalid model version source: '{source}'. If supplying a source as an http, https, \"\n@@ -1706,18 +1726,28 @@\n         \"Please provide an absolute path.\"\n     )\n \n-    while (unquoted := urllib.parse.unquote_plus(source)) != source:\n-        source = unquoted\n-    source_path = re.sub(r\"/+\", \"/\", urllib.parse.urlparse(source).path.rstrip(\"/\"))\n-    if \"\\x00\" in source_path:\n-        raise MlflowException(invalid_source_error_message, INVALID_PARAMETER_VALUE)\n-    resolved_source = pathlib.Path(source_path).resolve().as_posix()\n-    # NB: drive split is specifically for Windows since WindowsPath.resolve() will append the\n-    # drive path of the pwd to a given path. We don't care about the drive here, though.\n-    _, resolved_path = os.path.splitdrive(resolved_source)\n-\n-    if resolved_path != source_path:\n-        raise MlflowException(invalid_source_error_message, INVALID_PARAMETER_VALUE)\n+    parsed_source = urllib.parse.urlparse(source)\n+    parts_to_check = [parsed_source.path, parsed_source.fragment]\n+\n+    for part in parts_to_check:\n+        if not part:\n+            continue\n+        # Fully unquote any URL-encoded characters\n+        unquoted_part = part\n+        while (next_unquoted := urllib.parse.unquote_plus(unquoted_part)) != unquoted_part:\n+            unquoted_part = next_unquoted\n+        # Check for null bytes (common in path traversal attacks)\n+        if \"\\x00\" in unquoted_part:\n+            raise MlflowException(invalid_source_error_message, INVALID_PARAMETER_VALUE)\n+        # Normalize path to handle redundant separators and remove trailing slash\n+        normalized_part = re.sub(r\"/+\", \"/\", unquoted_part.rstrip(\"/\"))\n+        # Resolve the path to check for relative traversal attempts\n+        resolved_part = pathlib.Path(normalized_part).resolve().as_posix()\n+        # Split drive letter for Windows compatibility (ignore drive part)\n+        _, resolved_part_path = os.path.splitdrive(resolved_part)\n+        # If resolved path differs from original, relative traversal was attempted\n+        if resolved_part_path != normalized_part:\n+            raise MlflowException(invalid_source_error_message, INVALID_PARAMETER_VALUE)\n \n \n def _validate_source(source: str, run_id: str) -> None:\n\n"}
{"cve": "CVE-2024-0243", "fix_patch": "--- a/libs/core/langchain_core/utils/html.py\n+++ b/libs/core/langchain_core/utils/html.py\n@@ -83,7 +83,17 @@\n     for path in absolute_paths:\n         if any(path.startswith(exclude) for exclude in exclude_prefixes):\n             continue\n-        if prevent_outside and not path.startswith(base_url):\n-            continue\n+        if prevent_outside:\n+            # Parse both URLs to check netloc and path properly\n+            path_parsed = urlparse(path)\n+            base_parsed = urlparse(base_url)\n+            \n+            # Check if netlocs match (including subdomains)\n+            if path_parsed.netloc != base_parsed.netloc:\n+                continue\n+                \n+            # Check if path is within base path (using urljoin to handle relative paths)\n+            if not urljoin(base_url + \"/\", path_parsed.path).startswith(base_url + \"/\"):\n+                continue\n         res.append(path)\n     return res\n\n"}
{"cve": "CVE-2023-52081", "fix_patch": "--- a/catalog.go\n+++ b/catalog.go\n@@ -42,7 +42,7 @@\n // to search for something.\n // For example, it is used by (ThemeStore).Lookup\n func lookupPreprocess(s string) string {\n-\treturn strings.ToLower(norm.NFKD.String(regexp.MustCompile(`[-_ .]`).ReplaceAllString(s, \"\")))\n+\treturn strings.ToLower(regexp.MustCompile(`[-_ .]`).ReplaceAllString(norm.NFKD.String(s), \"\"))\n }\n \n // LoadCatalog loads a directory of theme manifests.\n\n"}
{"cve": "CVE-2020-28437", "fix_patch": "--- a/lib/get.js\n+++ b/lib/get.js\n@@ -1,6 +1,6 @@\n-var exec = require('child_process').exec\n+var execFile = require('child_process').execFile\n module.exports = function(app, cb) {\n-  exec('heroku config --app ' + app, function(err, stdout) {\n+  execFile('heroku', ['config', '--app', app], function(err, stdout) {\n     if(err) return cb(err);\n     var config = {}\n     var lines = stdout.split('\\n')\n\n"}
{"cve": "CVE-2023-26125", "fix_patch": "--- a/gin.go\n+++ b/gin.go\n@@ -668,12 +668,20 @@\n func redirectTrailingSlash(c *Context) {\n \treq := c.Request\n \tp := req.URL.Path\n-\tif prefix := path.Clean(c.Request.Header.Get(\"X-Forwarded-Prefix\")); prefix != \".\" {\n-\t\tprefix = url.QueryEscape(prefix)\n-\t\tprefix = strings.ReplaceAll(prefix, \"%2F\", \"/\")\n-\n-\t\tp = prefix + \"/\" + req.URL.Path\n-\t}\n+\n+\t// Get and validate X-Forwarded-Prefix header\n+\tif prefixHeader := c.Request.Header.Get(\"X-Forwarded-Prefix\"); prefixHeader != \"\" {\n+\t\t// URL-decode the prefix to handle encoded characters\n+\t\tdecodedPrefix, err := url.QueryUnescape(prefixHeader)\n+\t\tif err == nil {\n+\t\t\tcleanedPrefix := path.Clean(decodedPrefix)\n+\t\t\t// Validate: must be absolute path, no directory traversal, not \".\"\n+\t\t\tif strings.HasPrefix(cleanedPrefix, \"/\") && !strings.Contains(cleanedPrefix, \"../\") && cleanedPrefix != \".\" {\n+\t\t\t\tp = cleanedPrefix + \"/\" + req.URL.Path\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \treq.URL.Path = p + \"/\"\n \tif length := len(p); length > 1 && p[length-1] == '/' {\n \t\treq.URL.Path = p[:length-1]\n\n"}
{"cve": "CVE-2021-46561", "fix_patch": "--- a/src/controller/org.controller/org.controller.js\n+++ b/src/controller/org.controller/org.controller.js\n@@ -545,6 +545,12 @@\n         logger.info({ uuid: req.ctx.uuid, message: 'The user could not be updated because ' + newOrgShortName + ' organization does not exist.' })\n         return res.status(404).json(error.orgDne(newOrgShortName))\n       }\n+\n+      // Restrict non-secretariat admins from transferring users to other organizations\n+      if (!isSecretariat && isAdmin && newOrgShortName !== requesterShortName) {\n+        logger.info({ uuid: req.ctx.uuid, message: 'Non-secretariat admins can only transfer users within their own organization.' })\n+        return res.status(403).json(error.notSameOrgOrSecretariat())\n+      }\n     }\n \n     let agt = setAggregateUserObj({ username: username, org_UUID: orgUUID })\n\n"}
{"cve": "CVE-2022-28346", "fix_patch": "--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1038,6 +1038,10 @@\n         \"\"\"Add a single annotation expression to the Query.\"\"\"\n         annotation = annotation.resolve_expression(self, allow_joins=True, reuse=None,\n                                                    summarize=is_summary)\n+        # Validate alias to prevent SQL injection\n+        db_alias = self.model._meta.db\n+        connection = connections[db_alias]\n+        connection.ops.check_sql_identifier(alias)\n         if select:\n             self.append_annotation_mask([alias])\n         else:\n@@ -2088,6 +2092,10 @@\n             else:\n                 param_iter = iter([])\n             for name, entry in select.items():\n+                # Validate alias to prevent SQL injection\n+                db_alias = self.model._meta.db\n+                connection = connections[db_alias]\n+                connection.ops.check_sql_identifier(name)\n                 entry = str(entry)\n                 entry_params = []\n                 pos = entry.find(\"%s\")\n\n"}
{"cve": "CVE-2015-3295", "fix_patch": "--- a/lib/index.js\n+++ b/lib/index.js\n@@ -21,7 +21,7 @@\n };\n \n \n-var BAD_PROTOCOLS    = [ 'vbscript', 'javascript', 'file' ];\n+var BAD_PROTOCOLS    = [ 'vbscript', 'javascript', 'file', 'data' ];\n \n function validateLink(url) {\n   // url should be normalized at this point, and existing entities are decoded\n\n"}
{"cve": "CVE-2022-4724", "fix_patch": "--- a/rdiffweb/core/model/_sshkey.py\n+++ b/rdiffweb/core/model/_sshkey.py\n@@ -23,7 +23,11 @@\n \n class SshKey(Base):\n     __tablename__ = 'sshkeys'\n-    __table_args__ = {'sqlite_autoincrement': True}\n+    __table_args__ = (\n+        UniqueConstraint('UserID', 'Key', name='_user_key_uc'),\n+        {'sqlite_autoincrement': True}\n+    )\n+    id = Column('ID', Integer, primary_key=True)\n     fingerprint = Column('Fingerprint', Text)\n-    key = Column('Key', Text, unique=True, primary_key=True)\n+    key = Column('Key', Text, nullable=False)\n     userid = Column('UserID', Integer, nullable=False)\n\n--- a/rdiffweb/core/model/_user.py\n+++ b/rdiffweb/core/model/_user.py\n@@ -179,7 +179,7 @@\n                 SshKey(userid=self.userid, fingerprint=key.fingerprint, key=key.getvalue()).add().flush()\n             except IntegrityError:\n                 raise DuplicateSSHKeyError(\n-                    _(\"Duplicate key. This key already exists or is associated to another user.\")\n+                    _(\"Duplicate key. This key already exists for your account.\")\n                 )\n         cherrypy.engine.publish('user_attr_changed', self, {'authorizedkeys': True})\n         cherrypy.engine.publish('authorizedkey_added', self, fingerprint=key.fingerprint, comment=comment)\n\n--- a/rdiffweb/core/model/__init__.py\n+++ b/rdiffweb/core/model/__init__.py\n@@ -137,3 +137,43 @@\n             logger.error(msg)\n             print(msg, file=sys.stderr)\n             raise SystemExit(12)\n+\n+    # Update SshKey table schema\n+    # Add id column if missing\n+    if not _column_exists(connection, SshKey.__table__.c.id):\n+        _column_add(connection, SshKey.__table__.c.id)\n+    \n+    # Add unique constraint on UserID and Key if missing\n+    if not _index_exists(connection, '_user_key_uc'):\n+        if 'SQLite' in connection.engine.dialect.__class__.__name__:\n+            connection.engine.execute('CREATE UNIQUE INDEX _user_key_uc ON sshkeys (UserID, Key)')\n+        else:\n+            connection.engine.execute('ALTER TABLE sshkeys ADD CONSTRAINT _user_key_uc UNIQUE (UserID, Key)')\n+    \n+    # Handle SQLite schema migration to remove primary key from key column\n+    if 'SQLite' in connection.engine.dialect.__class__.__name__:\n+        # Check if we need to migrate old schema (key as primary key)\n+        try:\n+            result = connection.engine.execute(\"PRAGMA table_info(sshkeys)\").fetchall()\n+            key_is_primary = any(row['pk'] == 1 and row['name'] == 'Key' for row in result)\n+            if key_is_primary:\n+                # Rename old table\n+                connection.engine.execute('ALTER TABLE sshkeys RENAME TO sshkeys_old')\n+                # Create new table with correct schema\n+                SshKey.__table__.create(connection)\n+                # Copy data from old to new table\n+                connection.engine.execute('''\n+                    INSERT INTO sshkeys (id, fingerprint, key, userid) \n+                    SELECT id, fingerprint, Key, UserID FROM sshkeys_old\n+                ''')\n+                # Drop old table\n+                connection.engine.execute('DROP TABLE sshkeys_old')\n+        except Exception as e:\n+            logger.error('SshKey schema migration failed: %s', e)\n+            # Restore original table if migration fails\n+            try:\n+                connection.engine.execute('DROP TABLE sshkeys')\n+                connection.engine.execute('ALTER TABLE sshkeys_old RENAME TO sshkeys')\n+            except:\n+                pass\n+            raise\n\n"}
{"cve": "CVE-2017-7233", "fix_patch": "--- a/django/utils/http.py\n+++ b/django/utils/http.py\n@@ -317,5 +317,19 @@\n     # URL and might consider the URL as scheme relative.\n     if unicodedata.category(url[0])[0] == 'C':\n         return False\n-    return ((not url_info.netloc or url_info.netloc == host) and\n+    \n+    netloc = url_info.netloc\n+    if netloc and host:\n+        # Check if netloc is an IP address and host is a domain name (or vice versa)\n+        # This prevents numeric IPs from bypassing host checks when host is a domain\n+        try:\n+            # Simple check for IPv4 format (x.x.x.x) - covers common numeric URL cases\n+            if re.match(r'^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$', netloc) and not re.match(r'^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$', host):\n+                return False\n+            if re.match(r'^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$', host) and not re.match(r'^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$', netloc):\n+                return False\n+        except:\n+            pass\n+\n+    return ((not netloc or netloc == host) and\n             (not url_info.scheme or url_info.scheme in ['http', 'https']))\n\n"}
{"cve": "CVE-2020-4053", "fix_patch": "--- a/pkg/plugin/installer/http_installer.go\n+++ b/pkg/plugin/installer/http_installer.go\n@@ -172,6 +172,13 @@\n \t\t}\n \n \t\tpath := filepath.Join(targetDir, header.Name)\n+\n+\t\t// Prevent path traversal attacks\n+\t\tcleanedPath := filepath.Clean(path)\n+\t\texpectedPrefix := targetDir + string(os.PathSeparator)\n+\t\tif !strings.HasPrefix(cleanedPath, expectedPrefix) {\n+\t\t\treturn errors.Errorf(\"archive contains invalid path %q (escapes target directory)\", header.Name)\n+\t\t}\n \n \t\tswitch header.Typeflag {\n \t\tcase tar.TypeDir:\n\n"}
{"cve": "CVE-2022-21712", "fix_patch": "--- a/src/twisted/web/client.py\n+++ b/src/twisted/web/client.py\n@@ -2141,6 +2141,8 @@\n     ]\n     _seeOtherResponses = [http.SEE_OTHER]\n \n+    SENSITIVE_HEADERS = {b\"cookie\", b\"authorization\", b\"proxy-authorization\"}\n+\n     def __init__(self, agent, redirectLimit=20):\n         self._agent = agent\n         self._redirectLimit = redirectLimit\n@@ -2186,7 +2188,20 @@\n             )\n             raise ResponseFailed([Failure(err)], response)\n         location = self._resolveLocation(uri, locationHeaders[0])\n-        deferred = self._agent.request(method, location, headers)\n+        \n+        # Check if redirect is cross-origin and filter sensitive headers\n+        original_uri = URI.fromBytes(uri)\n+        new_uri = URI.fromBytes(location)\n+        is_cross_origin = (original_uri.scheme, original_uri.host, original_uri.port) != (new_uri.scheme, new_uri.host, new_uri.port)\n+        \n+        if is_cross_origin:\n+            new_headers = headers.copy()\n+            for header in self.SENSITIVE_HEADERS:\n+                new_headers.removeHeader(header)\n+        else:\n+            new_headers = headers\n+        \n+        deferred = self._agent.request(method, location, new_headers)\n \n         def _chainResponse(newResponse):\n             newResponse.setPreviousResponse(response)\n@@ -2194,7 +2209,7 @@\n \n         deferred.addCallback(_chainResponse)\n         return deferred.addCallback(\n-            self._handleResponse, method, uri, headers, redirectCount + 1\n+            self._handleResponse, method, location, new_headers, redirectCount + 1\n         )\n \n     def _handleResponse(self, response, method, uri, headers, redirectCount):\n\n"}
{"cve": "CVE-2024-54132", "fix_patch": "\n\n"}
{"cve": "CVE-2023-39631", "fix_patch": "--- a/numexpr/necompiler.py\n+++ b/numexpr/necompiler.py\n@@ -263,6 +263,49 @@\n def stringToExpression(s, types, context):\n     \"\"\"Given a string, convert it to a tree of ExpressionNode's.\n     \"\"\"\n+    import ast\n+\n+    # Validate expression AST to prevent code injection\n+    class _ExpressionValidator(ast.NodeVisitor):\n+        def __init__(self, allowed_functions):\n+            self.allowed_functions = set(allowed_functions)\n+            self.blocked_nodes = {\n+                ast.Import, ast.ImportFrom, ast.Assign, ast.AugAssign,\n+                ast.Delete, ast.Print, ast.Raise, ast.Assert, ast.Pass,\n+                ast.Break, ast.Continue, ast.For, ast.While, ast.If,\n+                ast.Try, ast.ExceptHandler, ast.Finally, ast.ClassDef,\n+                ast.FunctionDef, ast.Lambda, ast.Global, ast.Nonlocal,\n+                ast.Eval, ast.Exec, ast.Expr\n+            }\n+            self.dangerous_builtins = {\"__import__\", \"eval\", \"exec\", \"getattr\", \"setattr\", \"delattr\", \"open\", \"compile\"}\n+\n+        def visit_Node(self, node):\n+            if type(node) in self.blocked_nodes:\n+                raise ValueError(f\"Code injection attempt blocked: Disallowed node type {type(node).__name__}\")\n+            self.generic_visit(node)\n+\n+        def visit_Call(self, node):\n+            if isinstance(node.func, ast.Name):\n+                if node.func.id not in self.allowed_functions:\n+                    raise ValueError(f\"Code injection attempt blocked: Disallowed function {node.func.id}\")\n+            elif isinstance(node.func, ast.Attribute):\n+                raise ValueError(f\"Code injection attempt blocked: Attribute access in function call\")\n+            self.generic_visit(node)\n+\n+        def visit_Attribute(self, node):\n+            raise ValueError(f\"Code injection attempt blocked: Attribute access {node.attr}\")\n+\n+        def visit_Name(self, node):\n+            if node.id in self.dangerous_builtins:\n+                raise ValueError(f\"Code injection attempt blocked: Disallowed builtin {node.id}\")\n+            self.generic_visit(node)\n+\n+    # Get allowed functions from expressions module and validate input\n+    allowed_functions = set(expressions.functions.keys())\n+    tree = ast.parse(s, mode='eval')\n+    validator = _ExpressionValidator(allowed_functions)\n+    validator.visit(tree)\n+\n     old_ctx = expressions._context.get_current_context()\n     try:\n         expressions._context.set_new_context(context)\n\n"}
{"cve": "CVE-2023-30625", "fix_patch": "--- a/router/failed-events-manager.go\n+++ b/router/failed-events-manager.go\n@@ -36,6 +36,25 @@\n \tdbHandle *sql.DB\n }\n \n+// isSafeTaskRunID validates that taskRunID only contains alphanumeric characters and underscores\n+func isSafeTaskRunID(s string) bool {\n+\tif len(s) == 0 {\n+\t\treturn false\n+\t}\n+\tfor _, c := range s {\n+\t\tswitch {\n+\t\tcase c >= 'a' && c <= 'z',\n+\t\t\tc >= 'A' && c <= 'Z',\n+\t\t\tc >= '0' && c <= '9',\n+\t\t\tc == '_':\n+\t\t\tcontinue\n+\t\tdefault:\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n func GetFailedEventsManager() FailedEventsManagerI {\n \tif failedEventsManager == nil {\n \t\tfem := new(FailedEventsManagerT)\n@@ -56,6 +75,10 @@\n \t}\n \n \tfor taskRunID, failedEvents := range taskRunIDFailedEventsMap {\n+\t\tif !isSafeTaskRunID(taskRunID) {\n+\t\t\tpkgLogger.Errorf(\"Invalid taskRunID %q contains unsafe characters\", taskRunID)\n+\t\t\tcontinue\n+\t\t}\n \t\ttable := `\"` + strings.ReplaceAll(fmt.Sprintf(`%s_%s`, failedKeysTablePrefix, taskRunID), `\"`, `\"\"`) + `\"`\n \t\tsqlStatement := fmt.Sprintf(`CREATE TABLE IF NOT EXISTS %s (\n \t\tdestination_id TEXT NOT NULL,\n@@ -93,6 +116,11 @@\n \t\treturn\n \t}\n \n+\tif !isSafeTaskRunID(taskRunID) {\n+\t\tpkgLogger.Errorf(\"Invalid taskRunID %q contains unsafe characters\", taskRunID)\n+\t\treturn\n+\t}\n+\n \t// Drop table\n \ttable := fmt.Sprintf(`%s_%s`, failedKeysTablePrefix, taskRunID)\n \tsqlStatement := fmt.Sprintf(`DROP TABLE IF EXISTS %s`, table)\n@@ -104,6 +132,11 @@\n \n func (fem *FailedEventsManagerT) FetchFailedRecordIDs(taskRunID string) []*FailedEventRowT {\n \tif !failedKeysEnabled {\n+\t\treturn []*FailedEventRowT{}\n+\t}\n+\n+\tif !isSafeTaskRunID(taskRunID) {\n+\t\tpkgLogger.Errorf(\"Invalid taskRunID %q contains unsafe characters\", taskRunID)\n \t\treturn []*FailedEventRowT{}\n \t}\n \n\n"}
{"cve": "CVE-2022-23536", "fix_patch": "--- a/pkg/alertmanager/api.go\n+++ b/pkg/alertmanager/api.go\n@@ -45,6 +45,7 @@\n \terrTLSFileNotAllowed             = errors.New(\"setting TLS ca_file, cert_file and key_file is not allowed\")\n \terrSlackAPIURLFileNotAllowed     = errors.New(\"setting Slack api_url_file and global slack_api_url_file is not allowed\")\n \terrVictorOpsAPIKeyFileNotAllowed = errors.New(\"setting VictorOps api_key_file is not allowed\")\n+\terrOpsgenieAPIKeyFileNotAllowed  = errors.New(\"setting Opsgenie api_key_file is not allowed\")\n )\n \n // UserConfig is used to communicate a users alertmanager configs\n@@ -350,6 +351,11 @@\n \t\tif err := validateVictorOpsConfig(v.Interface().(config.VictorOpsConfig)); err != nil {\n \t\t\treturn err\n \t\t}\n+\n+\tcase reflect.TypeOf(config.OpsgenieConfig{}):\n+\t\tif err := validateOpsgenieConfig(v.Interface().(config.OpsgenieConfig)); err != nil {\n+\t\t\treturn err\n+\t\t}\n \t}\n \n \t// If the input config is a struct, recursively iterate on all fields.\n@@ -449,3 +455,10 @@\n \t}\n \treturn nil\n }\n+\n+func validateOpsgenieConfig(cfg config.OpsgenieConfig) error {\n+\tif cfg.APIKeyFile != \"\" {\n+\t\treturn errOpsgenieAPIKeyFileNotAllowed\n+\t}\n+\treturn nil\n+}\n\n"}
{"cve": "CVE-2024-43405", "fix_patch": "--- a/pkg/templates/signer/tmpl_signer.go\n+++ b/pkg/templates/signer/tmpl_signer.go\n@@ -28,10 +28,13 @@\n )\n \n func RemoveSignatureFromData(data []byte) []byte {\n-\treturn bytes.Trim(ReDigest.ReplaceAll(data, []byte(\"\")), \"\\n\")\n+\t// Normalize newlines to LF before processing to ensure consistent signature generation/verification\n+\tnormalized := bytes.ReplaceAll(data, []byte(\"\\r\\n\"), []byte(\"\\n\"))\n+\treturn bytes.Trim(ReDigest.ReplaceAll(normalized, []byte(\"\")), \"\\n\")\n }\n \n func GetSignatureFromData(data []byte) []byte {\n+\t// Find signature while preserving original newline handling\n \treturn ReDigest.Find(data)\n }\n \n@@ -88,16 +91,22 @@\n \t\t}\n \t}\n \n-\tbuff := bytes.NewBuffer(RemoveSignatureFromData(data))\n-\t// if file has any imports process them\n+\t// Normalize newlines to LF before processing to ensure consistent signature generation/verification\n+\tnormalizedData := bytes.ReplaceAll(data, []byte(\"\\r\\n\"), []byte(\"\\n\"))\n+\tbuff := bytes.NewBuffer(RemoveSignatureFromData(normalizedData))\n+\t\n+\t// Process file imports with consistent newline handling\n \tfor _, file := range tmpl.GetFileImports() {\n \t\tbin, err := os.ReadFile(file)\n \t\tif err != nil {\n \t\t\treturn \"\", err\n \t\t}\n+\t\t// Normalize imported file content newlines too\n+\t\tnormalizedBin := bytes.ReplaceAll(bin, []byte(\"\\r\\n\"), []byte(\"\\n\"))\n \t\tbuff.WriteRune('\\n')\n-\t\tbuff.Write(bin)\n-\t}\n+\t\tbuff.Write(normalizedBin)\n+\t}\n+\t\n \tsignatureData, err := t.sign(buff.Bytes())\n \tif err != nil {\n \t\treturn \"\", err\n@@ -136,15 +145,20 @@\n \t\treturn false, err\n \t}\n \n-\tbuff := bytes.NewBuffer(RemoveSignatureFromData(data))\n-\t// if file has any imports process them\n+\t// Normalize newlines to LF before processing to ensure consistent signature verification\n+\tnormalizedData := bytes.ReplaceAll(data, []byte(\"\\r\\n\"), []byte(\"\\n\"))\n+\tbuff := bytes.NewBuffer(RemoveSignatureFromData(normalizedData))\n+\t\n+\t// Process file imports with consistent newline handling (same as Sign method)\n \tfor _, file := range tmpl.GetFileImports() {\n \t\tbin, err := os.ReadFile(file)\n \t\tif err != nil {\n \t\t\treturn false, err\n \t\t}\n+\t\t// Normalize imported file content newlines too\n+\t\tnormalizedBin := bytes.ReplaceAll(bin, []byte(\"\\r\\n\"), []byte(\"\\n\"))\n \t\tbuff.WriteRune('\\n')\n-\t\tbuff.Write(bin)\n+\t\tbuff.Write(normalizedBin)\n \t}\n \n \treturn t.verify(buff.Bytes(), digest)\n\n"}
{"cve": "CVE-2021-32803", "fix_patch": "\n\n"}
{"cve": "CVE-2022-0686", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -34,7 +34,7 @@\n   ['#', 'hash'],                        // Extract from the back.\n   ['?', 'query'],                       // Extract from the back.\n   function sanitize(address, url) {     // Sanitize what is left of the address\n-    return isSpecial(url.protocol) ? address.replace(/\\\\/g, '/') : address;\n+    return address.replace(/\\\\/g, '/');\n   },\n   ['/', 'pathname'],                    // Extract from the back.\n   ['@', 'auth', 1],                     // Extract from the front.\n\n"}
{"cve": "CVE-2021-37713", "fix_patch": "--- a/lib/strip-absolute-path.js\n+++ b/lib/strip-absolute-path.js\n@@ -1,14 +1,28 @@\n // unix absolute paths are also absolute on win32, so we use this for both\n-const { isAbsolute, parse } = require('path').win32\n+const { isAbsolute, parse, sep } = require('path').win32\n \n // returns [root, stripped]\n module.exports = path => {\n   let r = ''\n+  \n+  // Check for drive-relative paths (e.g., C:path) that aren't considered absolute\n+  const driveMatch = path.match(/^[A-Za-z]:/);\n+  if (driveMatch && !isAbsolute(path)) {\n+    // Block paths with .. immediately after drive letter (e.g., C:../malicious)\n+    const afterDrive = path.substr(driveMatch[0].length);\n+    if (afterDrive.startsWith('..' + sep) || afterDrive === '..') {\n+      return ['', '']; // Return empty to indicate invalid path\n+    }\n+    r = driveMatch[0];\n+    path = afterDrive;\n+  }\n+  \n   while (isAbsolute(path)) {\n     // windows will think that //x/y/z has a \"root\" of //x/y/\n     const root = path.charAt(0) === '/' ? '/' : parse(path).root\n     path = path.substr(root.length)\n     r += root\n   }\n+  \n   return [r, path]\n }\n\n"}
{"cve": "CVE-2022-0639", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -536,9 +536,6 @@\n     result += url.username;\n     if (url.password) result += ':'+ url.password;\n     result += '@';\n-  } else if (url.password) {\n-    result += ':'+ url.password;\n-    result += '@';\n   }\n \n   result += url.host + url.pathname;\n\n"}
{"cve": "CVE-2022-1883", "fix_patch": "--- a/db/db.go\n+++ b/db/db.go\n@@ -370,11 +370,13 @@\n \t}\n \n \tif v := query.Get(\"tf_version\"); string(v) != \"\" {\n-\t\twhere = append(where, fmt.Sprintf(\"states.tf_version LIKE '%s'\", fmt.Sprintf(\"%%%s%%\", v)))\n+\t\twhere = append(where, \"states.tf_version LIKE ?\")\n+\t\tparams = append(params, fmt.Sprintf(\"%%%s%%\", v))\n \t}\n \n \tif v := query.Get(\"lineage_value\"); string(v) != \"\" {\n-\t\twhere = append(where, fmt.Sprintf(\"lineages.value LIKE '%s'\", fmt.Sprintf(\"%%%s%%\", v)))\n+\t\twhere = append(where, \"lineages.value LIKE ?\")\n+\t\tparams = append(params, fmt.Sprintf(\"%%%s%%\", v))\n \t}\n \n \tif len(where) > 0 {\n\n"}
{"cve": "CVE-2021-45452", "fix_patch": "--- a/django/core/files/storage.py\n+++ b/django/core/files/storage.py\n@@ -50,6 +50,7 @@\n         if not hasattr(content, 'chunks'):\n             content = File(content, name)\n \n+        name = self.generate_filename(name)\n         name = self.get_available_name(name, max_length=max_length)\n         return self._save(name, content)\n \n\n"}
{"cve": "CVE-2023-28155", "fix_patch": "--- a/lib/redirect.js\n+++ b/lib/redirect.js\n@@ -14,6 +14,7 @@\n   this.redirects = []\n   this.redirectsFollowed = 0\n   this.removeRefererHeader = false\n+  this.originalProtocol = request.uri.protocol\n }\n \n Redirect.prototype.onRequest = function (options) {\n@@ -112,6 +113,11 @@\n     var uriPrev = request.uri\n     request.uri = url.parse(redirectTo)\n \n+    // Block cross-protocol redirects unless followAllRedirects is enabled\n+    if (request.uri.protocol !== self.originalProtocol && !self.followAllRedirects) {\n+      return callback(new Error('Cross-protocol redirects are not allowed. Use followAllRedirects to enable.'))\n+    }\n+\n     // handle the case where we change protocol from https to http or vice versa\n     if (request.uri.protocol !== uriPrev.protocol) {\n       delete request.agent\n\n"}
{"cve": "CVE-2020-7640", "fix_patch": "--- a/class.js\n+++ b/class.js\n@@ -19,11 +19,10 @@\n \t\t\tconstructor = members.__construct;\n \t\t}\n \t\telse {\n-\t\t\t// inherit parent's constructor\n-\t\t\tvar code = members.__parent.toString();\n-\t\t\tvar args = code.substring( code.indexOf(\"(\")+1, code.indexOf(\")\") );\n-\t\t\tvar inner_code = code.substring( code.indexOf(\"{\")+1, code.lastIndexOf(\"}\") );\n-\t\t\teval('constructor = function ('+args+') {'+inner_code+'};');\n+\t\t\t// Inherit parent's constructor by delegating to it\n+\t\t\tconstructor = function() {\n+\t\t\t\tmembers.__parent.apply(this, arguments);\n+\t\t\t};\n \t\t}\n \t\t\n \t\t// inherit rest of parent members\n\n"}
{"cve": "CVE-2023-34233", "fix_patch": "--- a/src/snowflake/connector/auth/webbrowser.py\n+++ b/src/snowflake/connector/auth/webbrowser.py\n@@ -300,7 +300,58 @@\n             \":\".join(origin_line.split(\":\")[1:]).strip(),\n         )\n \n+    def _get_trusted_domains(self) -> list[str]:\n+        \"\"\"Get list of trusted domains for SSO redirects.\n+        \n+        Returns:\n+            List of trusted domain names (e.g., ['snowflakecomputing.com'])\n+        \"\"\"\n+        # Allow configuration via environment variable for enterprise flexibility\n+        env_trusted_domains = os.getenv(\"SF_SSO_TRUSTED_DOMAINS\")\n+        if env_trusted_domains:\n+            return [domain.strip() for domain in env_trusted_domains.split(\",\")]\n+        \n+        # Default to Snowflake's domains\n+        return [\n+            \"snowflakecomputing.com\",\n+            \"snowflake.net\",\n+            \"snowflake.dev\"\n+        ]\n+\n+    def _is_url_trusted(self, url: str) -> bool:\n+        \"\"\"Validate that URL comes from a trusted domain.\n+        \n+        Args:\n+            url: URL to validate\n+            \n+        Returns:\n+            True if URL is from a trusted domain, False otherwise\n+        \"\"\"\n+        try:\n+            parsed_url = urlparse(url)\n+            if not parsed_url.netloc:\n+                return False\n+                \n+            # Check against trusted domains (case-insensitive)\n+            netloc = parsed_url.netloc.lower()\n+            trusted_domains = [d.lower() for d in self._get_trusted_domains()]\n+            \n+            # Allow subdomains (e.g., login.snowflakecomputing.com)\n+            for domain in trusted_domains:\n+                if netloc.endswith(f\".{domain}\") or netloc == domain:\n+                    return True\n+                    \n+            return False\n+        except Exception as e:\n+            logger.debug(f\"URL validation failed: {e}\")\n+            return False\n+\n     def _process_get_url(self, url: str) -> None:\n+        \"\"\"Process URL and extract token only if from trusted domain.\"\"\"\n+        if not self._is_url_trusted(url):\n+            logger.warning(f\"Rejected URL from untrusted domain: {url}\")\n+            return\n+            \n         parsed = parse_qs(urlparse(url).query)\n         if \"token\" not in parsed or not parsed[\"token\"][0]:\n             return\n\n"}
{"cve": "CVE-2025-29778", "fix_patch": "--- a/pkg/cosign/cosign.go\n+++ b/pkg/cosign/cosign.go\n@@ -534,7 +534,7 @@\n }\n \n func matchSignatures(signatures []oci.Signature, subject, subjectRegExp, issuer, issuerRegExp string, extensions map[string]string) error {\n-\tif subject == \"\" && issuer == \"\" && len(extensions) == 0 {\n+\tif subject == \"\" && subjectRegExp == \"\" && issuer == \"\" && issuerRegExp == \"\" && len(extensions) == 0 {\n \t\treturn nil\n \t}\n \n\n"}
{"cve": "CVE-2021-21432", "fix_patch": "--- a/source/github/authentication.go\n+++ b/source/github/authentication.go\n@@ -9,6 +9,7 @@\n \t\"errors\"\n \t\"fmt\"\n \t\"net/http\"\n+\t\"strings\"\n \n \t\"github.com/go-vela/server/random\"\n \n@@ -105,9 +106,19 @@\n func (c *client) AuthenticateToken(r *http.Request) (*library.User, error) {\n \tlogrus.Trace(\"Authenticating user via token\")\n \n-\ttoken := r.Header.Get(\"Token\")\n+\tauthHeader := r.Header.Get(\"Authorization\")\n+\tif len(authHeader) == 0 {\n+\t\treturn nil, errors.New(\"no authorization header provided\")\n+\t}\n+\n+\tparts := strings.Split(authHeader, \" \")\n+\tif len(parts) != 2 || parts[0] != \"Bearer\" {\n+\t\treturn nil, errors.New(\"invalid authorization header format - expected 'Bearer <token>'\")\n+\t}\n+\n+\ttoken := parts[1]\n \tif len(token) == 0 {\n-\t\treturn nil, errors.New(\"no token provided\")\n+\t\treturn nil, errors.New(\"no token provided in authorization header\")\n \t}\n \n \tu, err := c.Authorize(token)\n\n"}
{"cve": "CVE-2023-40267", "fix_patch": "--- a/git/repo/base.py\n+++ b/git/repo/base.py\n@@ -1169,6 +1169,20 @@\n         return cls(path, odbt=odbt)\n \n     @classmethod\n+    @staticmethod\n+    def _check_unsafe_options(options: Optional[List[str]], unsafe_options: List[str]) -> None:\n+        \"\"\"Check for unsafe options in the provided list of options.\n+        \n+        :raise ValueError: If any unsafe option is found.\n+        \"\"\"\n+        if not options:\n+            return\n+            \n+        option_str = \" \".join(options)\n+        for unsafe_opt in unsafe_options:\n+            if unsafe_opt in option_str:\n+                raise ValueError(f\"Unsafe option '{unsafe_opt}' is not allowed\")\n+\n     def _clone(\n         cls,\n         git: \"Git\",\n@@ -1201,10 +1215,18 @@\n         if multi_options:\n             multi = shlex.split(\" \".join(multi_options))\n \n+        # Check for unsafe protocols\n         if not allow_unsafe_protocols:\n             Git.check_unsafe_protocols(str(url))\n-        if not allow_unsafe_options and multi_options:\n-            Git.check_unsafe_options(options=multi_options, unsafe_options=cls.unsafe_git_clone_options)\n+            \n+        # Check for unsafe options in both multi_options and regular kwargs\n+        if not allow_unsafe_options:\n+            if multi_options:\n+                Git.check_unsafe_options(options=multi_options, unsafe_options=cls.unsafe_git_clone_options)\n+                \n+            # Check for unsafe options in regular kwargs\n+            option_list = [f\"--{k}\" for k in kwargs if k.startswith('_')] + list(kwargs.values())\n+            cls._check_unsafe_options(option_list, cls.unsafe_git_clone_options)\n \n         proc = git.clone(\n             multi,\n\n"}
{"cve": "CVE-2021-23363", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -1,16 +1,31 @@\n 'use strict'\n \n-const exec = require('child_process').execSync\n+const { spawnSync } = require('child_process');\n \n exports.killByPort = function (port) {\n-  var processId = null\n-  try {\n-    processId = exec(`lsof -t -i:${port}`)\n-  } catch (e) {\n-\n+  // Validate port is a valid number (1-65535 integer)\n+  const parsedPort = Number(port);\n+  if (!Number.isInteger(parsedPort) || parsedPort < 1 || parsedPort > 65535) {\n+    throw new Error('Invalid port: Must be an integer between 1 and 65535');\n   }\n \n-  if (processId !== null) { // if exists kill\n-    exec(`kill ${processId}`)\n+  let processId = null;\n+  try {\n+    // Use spawnSync with arguments to prevent shell injection\n+    const lsofResult = spawnSync('lsof', ['-t', `-i:${parsedPort}`], { encoding: 'utf8' });\n+    processId = lsofResult.stdout.trim();\n+  } catch (e) {\n+    // Preserve original silent error handling for lsof failures\n+  }\n+\n+  if (processId) {\n+    // Split multiple PIDs (one per line from lsof) and kill each\n+    const pids = processId.split('\\n').filter(Boolean);\n+    for (const pid of pids) {\n+      const killResult = spawnSync('kill', [pid], { encoding: 'utf8' });\n+      if (killResult.status !== 0) {\n+        throw new Error(`Kill failed for PID ${pid}: ${killResult.stderr.trim() || 'No error message'}`);\n+      }\n+    }\n   }\n }\n\n"}
{"cve": "CVE-2024-10220", "fix_patch": "--- a/pkg/volume/git_repo/git_repo.go\n+++ b/pkg/volume/git_repo/git_repo.go\n@@ -261,6 +261,16 @@\n \tif err := validateNonFlagArgument(src.Directory, \"directory\"); err != nil {\n \t\treturn err\n \t}\n+\t// Block absolute paths and path traversal in directory parameter\n+\tif src.Directory != \"\" {\n+\t\tif filepath.IsAbs(src.Directory) {\n+\t\t\treturn fmt.Errorf(\"invalid directory %q: absolute paths are not allowed\", src.Directory)\n+\t\t}\n+\t\tcleanedDir := filepath.Clean(src.Directory)\n+\t\tif cleanedDir == \"..\" || strings.HasPrefix(cleanedDir, \"../\") {\n+\t\t\treturn fmt.Errorf(\"invalid directory %q: path traversal is not allowed\", src.Directory)\n+\t\t}\n+\t}\n \treturn nil\n }\n \n\n"}
{"cve": "CVE-2022-0691", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -4,7 +4,7 @@\n   , qs = require('querystringify')\n   , CRHTLF = /[\\n\\r\\t]/g\n   , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//\n-  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\\\/]+)?([\\S\\s]*)/i\n+  , protocolre = /^([a-z][a-z0-9+.-]*:)?(\\/\\/)?([\\\\/]+)?([\\S\\s]*)/i\n   , windowsDriveLetter = /^[a-zA-Z]:/\n   , whitespace = /^[ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+/;\n \n\n"}
{"cve": "CVE-2025-23221", "fix_patch": "--- a/src/webfinger/lookup.ts\n+++ b/src/webfinger/lookup.ts\n@@ -26,6 +26,46 @@\n     protocol = resource.protocol;\n     server = resource.host;\n   }\n+\n+  // Validate server hostname does not resolve to restricted IPs\n+  async function isHostnameRestricted(hostname: string): Promise<boolean> {\n+    try {\n+      const [ipv4s, ipv6s] = await Promise.all([\n+        Deno.resolveDns(hostname, \"A\").catch(() => []),\n+        Deno.resolveDns(hostname, \"AAAA\").catch(() => []),\n+      ]);\n+      const allIps = [...ipv4s, ...ipv6s];\n+      for (const ip of allIps) {\n+        // Check loopback addresses\n+        if (ip.startsWith(\"127.\") || ip === \"::1\") return true;\n+        // Check private IPv4 ranges\n+        const ipv4Parts = ip.split(\".\").map(Number);\n+        if (ipv4Parts.length === 4) {\n+          if (\n+            ipv4Parts[0] === 10 || // 10.0.0.0/8\n+            (ipv4Parts[0] === 172 && ipv4Parts[1] >= 16 && ipv4Parts[1] <= 31) || // 172.16.0.0/12\n+            (ipv4Parts[0] === 192 && ipv4Parts[1] === 168) // 192.168.0.0/16\n+          ) return true;\n+        }\n+        // Check private IPv6 ranges (fc00::/7)\n+        if (ip.startsWith(\"fc\") || ip.startsWith(\"fd\")) return true;\n+      }\n+      return false;\n+    } catch {\n+      return false; // Resolution failure means we can't confirm restriction\n+    }\n+  }\n+\n+  const serverUrl = new URL(`https://${server}`);\n+  const hostname = serverUrl.hostname;\n+  if (await isHostnameRestricted(hostname)) {\n+    logger.error(\n+      \"WebFinger lookup blocked access to restricted hostname: {hostname}\",\n+      { hostname }\n+    );\n+    return null;\n+  }\n+\n   let url = new URL(`${protocol}//${server}/.well-known/webfinger`);\n   url.searchParams.set(\"resource\", resource.href);\n   let redirected = 0;\n@@ -76,6 +116,15 @@\n         );\n         return null;\n       }\n+      // Validate redirected hostname is not restricted\n+      const redirectedHostname = new URL(redirectedUrl.href).hostname;\n+      if (await isHostnameRestricted(redirectedHostname)) {\n+        logger.error(\n+          \"WebFinger lookup blocked redirect to restricted hostname: {hostname}\",\n+          { hostname: redirectedHostname }\n+        );\n+        return null;\n+      }\n       url = redirectedUrl;\n       continue;\n     }\n\n"}
{"cve": "CVE-2018-3778", "fix_patch": "--- a/lib/client.js\n+++ b/lib/client.js\n@@ -242,14 +242,17 @@\n \n   function finish () {\n     if (!that.disconnected && that.will) {\n-      that.broker.publish(that.will, that, function (err) {\n-        if (!err) {\n-          that.broker.persistence.delWill({\n-            id: that.id,\n-            brokerId: that.broker.id\n-          }, nop)\n-        }\n-      })\n+      var toPublish = that.broker.authorizeForward(that, that.will)\n+      if (toPublish) {\n+        that.broker.publish(that.will, that, function (err) {\n+          if (!err) {\n+            that.broker.persistence.delWill({\n+              id: that.id,\n+              brokerId: that.broker.id\n+            }, nop)\n+          }\n+        })\n+      }\n       that.will = null // this function might be called twice\n     }\n \n\n"}
{"cve": "CVE-2024-48911", "fix_patch": "--- a/opencanary/config.py\n+++ b/opencanary/config.py\n@@ -53,11 +53,20 @@\n         self.__config = None\n         self.__configfile = configfile\n \n-        files = [\n-            configfile,\n-            \"%s/.%s\" % (expanduser(\"~\"), configfile),\n-            \"/etc/opencanaryd/%s\" % configfile,\n-        ]\n+        # Determine which config files to load based on privileges (CVE-2021-XXXX fix)\n+        if os.geteuid() == 0:\n+            # Running as root: skip user's home directory config to prevent privilege escalation\n+            files = [\n+                configfile,\n+                \"/etc/opencanaryd/%s\" % configfile,\n+            ]\n+        else:\n+            files = [\n+                configfile,\n+                \"%s/.%s\" % (expanduser(\"~\"), configfile),\n+                \"/etc/opencanaryd/%s\" % configfile,\n+            ]\n+\n         print(\n             \"** We hope you enjoy using OpenCanary. For more open source Canary goodness, head over to canarytokens.org. **\"\n         )\n\n--- a/opencanary/modules/portscan.py\n+++ b/opencanary/modules/portscan.py\n@@ -68,7 +68,14 @@\n \n \n def detectNFTables():\n-    return b\"nf_tables\" in subprocess.check_output([\"iptables\", \"--version\"])\n+    try:\n+        return b\"nf_tables\" in subprocess.check_output(\n+            [\"iptables\", \"--version\"], \n+            stderr=subprocess.PIPE,\n+            universal_newlines=False\n+        )\n+    except (subprocess.SubprocessError, FileNotFoundError):\n+        return False\n \n \n class CanaryPortscan(CanaryService):\n@@ -89,13 +96,24 @@\n         self.config = config\n \n     def getIptablesPath(self):\n+        # Only allow trusted iptables paths to prevent command injection (CVE-2021-XXXX fix)\n+        trusted_paths = [\"/sbin/iptables\", \"/usr/sbin/iptables\", \"/usr/bin/iptables\"]\n+        \n         if self.iptables_path:\n+            if self.iptables_path not in trusted_paths:\n+                raise ValueError(f\"Invalid iptables path: {self.iptables_path} (must be in {trusted_paths})\")\n             return self.iptables_path\n \n         if detectNFTables():\n-            return shutil.which(\"iptables-legacy\")\n-\n-        return shutil.which(\"iptables\") or \"/sbin/iptables\"\n+            path = shutil.which(\"iptables-legacy\")\n+            if path not in trusted_paths:\n+                raise ValueError(f\"Invalid iptables-legacy path: {path} (must be in {trusted_paths})\")\n+            return path\n+\n+        path = shutil.which(\"iptables\") or \"/sbin/iptables\"\n+        if path not in trusted_paths:\n+            raise ValueError(f\"Invalid iptables path: {path} (must be in {trusted_paths})\")\n+        return path\n \n     def startYourEngines(self, reactor=None):\n         # Logging rules for loopback interface.\n\n"}
{"cve": "CVE-2024-27302", "fix_patch": "--- a/rest/internal/cors/handlers.go\n+++ b/rest/internal/cors/handlers.go\n@@ -82,7 +82,7 @@\n \t\t\treturn true\n \t\t}\n \n-\t\tif strings.HasSuffix(origin, o) {\n+\t\tif origin == o {\n \t\t\treturn true\n \t\t}\n \t}\n\n"}
{"cve": "CVE-2021-3664", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -105,6 +105,12 @@\n  * @property {Boolean} slashes `true` if protocol is followed by \"//\", else `false`.\n  * @property {String} rest Rest of the URL that is not part of the protocol.\n  */\n+\n+/**\n+ * List of trusted protocols to prevent open redirects\n+ * @private\n+ */\n+var TRUSTED_PROTOCOLS = ['http:', 'https:', 'ftp:', 'mailto:', 'tel:', 'sms:'];\n \n /**\n  * Extract protocol information from a URL with/without double slash (\"//\").\n@@ -317,14 +323,15 @@\n     url.password = instruction[1] || '';\n   }\n \n-  url.origin = url.protocol && url.host && url.protocol !== 'file:'\n+  // Only set origin for trusted protocols\n+  url.origin = url.protocol && url.host && TRUSTED_PROTOCOLS.includes(url.protocol + ':')\n     ? url.protocol +'//'+ url.host\n     : 'null';\n \n   //\n   // The href is just the compiled result.\n   //\n-  url.href = url.toString();\n+  url.href = url.protocol && TRUSTED_PROTOCOLS.includes(url.protocol + ':') ? url.toString() : '';\n }\n \n /**\n\n"}
{"cve": "CVE-2022-24794", "fix_patch": "--- a/lib/context.js\n+++ b/lib/context.js\n@@ -187,8 +187,17 @@\n       returnTo = options.returnTo;\n       debug('req.oidc.login() called with returnTo: %s', returnTo);\n     } else if (req.method === 'GET' && req.originalUrl) {\n-      returnTo = req.originalUrl;\n-      debug('req.oidc.login() without returnTo, using: %s', returnTo);\n+      // Parse URLs for origin validation\n+      const originalUrl = url.parse(req.originalUrl);\n+      const baseUrl = url.parse(config.baseURL);\n+      \n+      // Only use originalUrl if it's same origin as baseURL\n+      if (originalUrl.host === baseUrl.host) {\n+        returnTo = req.originalUrl;\n+        debug('req.oidc.login() without returnTo, using same-origin URL: %s', returnTo);\n+      } else {\n+        debug('req.originalUrl has different origin (%s vs %s), using baseURL instead', originalUrl.host || 'none', baseUrl.host);\n+      }\n     }\n \n     options = {\n\n"}
{"cve": "CVE-2024-45388", "fix_patch": "--- a/core/hoverfly_funcs.go\n+++ b/core/hoverfly_funcs.go\n@@ -188,7 +188,16 @@\n \t\treturn \"\", fmt.Errorf(\"bodyFile contains absolute path (%s). only relative is supported\", filePath)\n \t}\n \n-\tfileContents, err := ioutil.ReadFile(filepath.Join(hf.Cfg.ResponsesBodyFilesPath, filePath))\n+\tfullPath := filepath.Join(hf.Cfg.ResponsesBodyFilesPath, filePath)\n+\tcleanedBase := filepath.Clean(hf.Cfg.ResponsesBodyFilesPath)\n+\tcleanedFull := filepath.Clean(fullPath)\n+\n+\t// Check if the full path is within the restricted directory\n+\tif cleanedFull != cleanedBase && !strings.HasPrefix(cleanedFull, cleanedBase+string(filepath.Separator)) {\n+\t\treturn \"\", fmt.Errorf(\"bodyFile path %s escapes the restricted directory\", filePath)\n+\t}\n+\n+\tfileContents, err := ioutil.ReadFile(fullPath)\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n\n"}
{"cve": "CVE-2024-52010", "fix_patch": "--- a/src/mod/sshprox/sshprox.go\n+++ b/src/mod/sshprox/sshprox.go\n@@ -12,6 +12,7 @@\n \t\"runtime\"\n \t\"strconv\"\n \t\"strings\"\n+\t\"syscall\"\n \n \t\"github.com/google/uuid\"\n \t\"imuslab.com/zoraxy/mod/reverseproxy\"\n@@ -175,7 +176,12 @@\n \t}\n \n \tsshCommand := []string{\"ssh\", \"-t\", connAddr, \"-p\", strconv.Itoa(remotePort)}\n-\tcmd := exec.Command(i.ExecPath, \"-w\", \"-p\", strconv.Itoa(listenPort), \"--once\", \"--config\", configPath, \"--title-format\", title, \"bash\", \"-c\", strings.Join(sshCommand, \" \"))\n+\t// Quote each argument to prevent shell command injection\n+\tvar quotedArgs []string\n+\tfor _, arg := range sshCommand {\n+\t\tquotedArgs = append(quotedArgs, syscall.Quote(arg))\n+\t}\n+\tcmd := exec.Command(i.ExecPath, \"-w\", \"-p\", strconv.Itoa(listenPort), \"--once\", \"--config\", configPath, \"--title-format\", title, \"bash\", \"-c\", strings.Join(quotedArgs, \" \"))\n \tcmd.Dir = filepath.Dir(i.ExecPath)\n \tcmd.Env = append(os.Environ(), \"TERM=xterm\")\n \tcmd.Stdout = os.Stdout\n\n"}
{"cve": "CVE-2024-6257", "fix_patch": "--- a/get_git.go\n+++ b/get_git.go\n@@ -196,6 +196,12 @@\n \tif ref == \"\" {\n \t\tref = findRemoteDefaultBranch(ctx, u)\n \t}\n+\t\n+\t// Validate ref format before using it in git commands\n+\tif originalRef != \"\" && !isValidGitRef(originalRef) {\n+\t\treturn fmt.Errorf(\"invalid git reference format: %q\", originalRef)\n+\t}\n+\t\n \tif depth > 0 {\n \t\targs = append(args, \"--depth\", strconv.Itoa(depth))\n \t\targs = append(args, \"--branch\", ref)\n@@ -226,6 +232,28 @@\n \t\treturn g.checkout(ctx, dst, originalRef)\n \t}\n \treturn nil\n+}\n+\n+// isValidGitRef checks if a reference name follows Git's naming rules\n+// Ref: https://git-scm.com/docs/git-check-ref-format\n+func isValidGitRef(ref string) bool {\n+\tif ref == \"\" {\n+\t\treturn false\n+\t}\n+\t// Git doesn't allow these characters in ref names\n+\tforbidden := []string{\"@\", \"{\", \"}\", \"\\\\\", \"^\", \":\", \"?\", \"*\", \"[\", \"]\"}\n+\tfor _, f := range forbidden {\n+\t\tif strings.Contains(ref, f) {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\t// Ref names must not start with these\n+\tfor _, prefix := range []string{\"refs/\", \"HEAD\", \"ORIG_HEAD\", \"MERGE_HEAD\"} {\n+\t\tif strings.HasPrefix(ref, prefix) {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n }\n \n func (g *GitGetter) update(ctx context.Context, dst, sshKeyFile, ref string, depth int) error {\n@@ -288,6 +316,11 @@\n // findRemoteDefaultBranch checks the remote repo's HEAD symref to return the remote repo's\n // default branch. \"master\" is returned if no HEAD symref exists.\n func findRemoteDefaultBranch(ctx context.Context, u *url.URL) string {\n+\t// Validate URL before using it in git command\n+\tif !isValidGitURL(u.String()) {\n+\t\treturn \"master\"\n+\t}\n+\t\n \tvar stdoutbuf bytes.Buffer\n \tcmd := exec.CommandContext(ctx, \"git\", \"ls-remote\", \"--symref\", u.String(), \"HEAD\")\n \tcmd.Stdout = &stdoutbuf\n@@ -296,7 +329,42 @@\n \tif err != nil || matches == nil {\n \t\treturn \"master\"\n \t}\n-\treturn matches[len(matches)-1]\n+\t\n+\t// Validate and sanitize the branch name before returning\n+\tbranch := matches[len(matches)-1]\n+\tif !isValidGitRef(branch) {\n+\t\treturn \"master\"\n+\t}\n+\treturn branch\n+}\n+\n+// isValidGitURL checks if a string is a valid Git URL format\n+func isValidGitURL(rawurl string) bool {\n+\tu, err := url.Parse(rawurl)\n+\tif err != nil {\n+\t\treturn false\n+\t}\n+\t\n+\t// Check for common Git URL schemes\n+\tswitch u.Scheme {\n+\tcase \"git\", \"http\", \"https\", \"ssh\", \"git+ssh\", \"git+http\", \"git+https\":\n+\t\treturn u.Host != \"\" && u.Path != \"\"\n+\tcase \"\":\n+\t\t// Handle SCP-style SSH URLs (e.g., user@host:path)\n+\t\tparts := strings.SplitN(rawurl, \":\", 2)\n+\t\tif len(parts) != 2 {\n+\t\t\treturn false\n+\t\t}\n+\t\t// Check that host part has at least one dot or is an IP address\n+\t\thost := parts[0]\n+\t\tif !strings.Contains(host, \".\") && !strings.Contains(host, \":\") {\n+\t\t\treturn false\n+\t\t}\n+\t\t// Path part should not be empty\n+\t\treturn parts[1] != \"\"\n+\tdefault:\n+\t\treturn false\n+\t}\n }\n \n // setupGitEnv sets up the environment for the given command. This is used to\n\n"}
{"cve": "CVE-2022-24065", "fix_patch": "--- a/cookiecutter/vcs.py\n+++ b/cookiecutter/vcs.py\n@@ -64,6 +64,13 @@\n     :param no_input: Suppress all user prompts when calling via API.\n     :returns: str with path to the new directory of the repository.\n     \"\"\"\n+    import re\n+    \n+    # Validate checkout parameter to prevent command injection\n+    if checkout is not None:\n+        # Only allow alphanumeric characters, hyphens, underscores, and dots\n+        if not re.match(r'^[a-zA-Z0-9_\\-\\.]+$', checkout):\n+            raise ValueError(f\"Invalid checkout parameter: {checkout}\")\n     # Ensure that clone_to_dir exists\n     clone_to_dir = os.path.expanduser(clone_to_dir)\n     make_sure_path_exists(clone_to_dir)\n@@ -98,7 +105,8 @@\n                 stderr=subprocess.STDOUT,\n             )\n             if checkout is not None:\n-                subprocess.check_output(  # nosec\n+                # Use shell=False (default) and pass as list to prevent command injection\n+                subprocess.check_output(\n                     [repo_type, 'checkout', checkout],\n                     cwd=repo_dir,\n                     stderr=subprocess.STDOUT,\n\n"}
{"cve": "CVE-2020-11053", "fix_patch": "--- a/oauthproxy.go\n+++ b/oauthproxy.go\n@@ -577,13 +577,20 @@\n \n // IsValidRedirect checks whether the redirect URL is whitelisted\n func (p *OAuthProxy) IsValidRedirect(redirect string) bool {\n+\t// Decode URL-encoded characters in the redirect string\n+\tdecodedRedirect, err := url.QueryUnescape(redirect)\n+\tif err != nil {\n+\t\tlogger.Printf(\"Rejecting invalid redirect %q: failed to decode\", redirect)\n+\t\treturn false\n+\t}\n+\n \tswitch {\n-\tcase strings.HasPrefix(redirect, \"/\") && !strings.HasPrefix(redirect, \"//\") && !strings.HasPrefix(redirect, \"/\\\\\"):\n+\tcase strings.HasPrefix(decodedRedirect, \"/\") && !strings.HasPrefix(decodedRedirect, \"//\") && !strings.HasPrefix(decodedRedirect, \"/\\\\\"):\n \t\treturn true\n-\tcase strings.HasPrefix(redirect, \"http://\") || strings.HasPrefix(redirect, \"https://\"):\n-\t\tredirectURL, err := url.Parse(redirect)\n+\tcase strings.HasPrefix(decodedRedirect, \"http://\") || strings.HasPrefix(decodedRedirect, \"https://\"):\n+\t\tredirectURL, err := url.Parse(decodedRedirect)\n \t\tif err != nil {\n-\t\t\tlogger.Printf(\"Rejecting invalid redirect %q: scheme unsupported or missing\", redirect)\n+\t\t\tlogger.Printf(\"Rejecting invalid redirect %q: scheme unsupported or missing\", decodedRedirect)\n \t\t\treturn false\n \t\t}\n \t\tredirectHostname := redirectURL.Hostname()\n@@ -608,10 +615,10 @@\n \t\t\t}\n \t\t}\n \n-\t\tlogger.Printf(\"Rejecting invalid redirect %q: domain / port not in whitelist\", redirect)\n+\t\tlogger.Printf(\"Rejecting invalid redirect %q: domain / port not in whitelist\", decodedRedirect)\n \t\treturn false\n \tdefault:\n-\t\tlogger.Printf(\"Rejecting invalid redirect %q: not an absolute or relative URL\", redirect)\n+\t\tlogger.Printf(\"Rejecting invalid redirect %q: not an absolute or relative URL\", decodedRedirect)\n \t\treturn false\n \t}\n }\n\n"}
{"cve": "CVE-2020-4037", "fix_patch": "--- a/oauthproxy.go\n+++ b/oauthproxy.go\n@@ -599,16 +599,23 @@\n \n // IsValidRedirect checks whether the redirect URL is whitelisted\n func (p *OAuthProxy) IsValidRedirect(redirect string) bool {\n+\t// First, decode any URL-encoded characters in the redirect\n+\tdecodedRedirect, err := url.QueryUnescape(redirect)\n+\tif err != nil {\n+\t\tlogger.Printf(\"Rejecting invalid redirect %q: failed to decode\", redirect)\n+\t\treturn false\n+\t}\n+\n \tswitch {\n-\tcase redirect == \"\":\n+\tcase decodedRedirect == \"\":\n \t\t// The user didn't specify a redirect, should fallback to `/`\n \t\treturn false\n-\tcase strings.HasPrefix(redirect, \"/\") && !strings.HasPrefix(redirect, \"//\") && !invalidRedirectRegex.MatchString(redirect):\n+\tcase strings.HasPrefix(decodedRedirect, \"/\") && !strings.HasPrefix(decodedRedirect, \"//\") && !invalidRedirectRegex.MatchString(decodedRedirect):\n \t\treturn true\n-\tcase strings.HasPrefix(redirect, \"http://\") || strings.HasPrefix(redirect, \"https://\"):\n-\t\tredirectURL, err := url.Parse(redirect)\n+\tcase strings.HasPrefix(decodedRedirect, \"http://\") || strings.HasPrefix(decodedRedirect, \"https://\"):\n+\t\tredirectURL, err := url.Parse(decodedRedirect)\n \t\tif err != nil {\n-\t\t\tlogger.Printf(\"Rejecting invalid redirect %q: scheme unsupported or missing\", redirect)\n+\t\t\tlogger.Printf(\"Rejecting invalid redirect %q: scheme unsupported or missing\", decodedRedirect)\n \t\t\treturn false\n \t\t}\n \t\tredirectHostname := redirectURL.Hostname()\n@@ -633,10 +640,10 @@\n \t\t\t}\n \t\t}\n \n-\t\tlogger.Printf(\"Rejecting invalid redirect %q: domain / port not in whitelist\", redirect)\n+\t\tlogger.Printf(\"Rejecting invalid redirect %q: domain / port not in whitelist\", decodedRedirect)\n \t\treturn false\n \tdefault:\n-\t\tlogger.Printf(\"Rejecting invalid redirect %q: not an absolute or relative URL\", redirect)\n+\t\tlogger.Printf(\"Rejecting invalid redirect %q: not an absolute or relative URL\", decodedRedirect)\n \t\treturn false\n \t}\n }\n\n"}
{"cve": "CVE-2022-36087", "fix_patch": "--- a/oauthlib/uri_validate.py\n+++ b/oauthlib/uri_validate.py\n@@ -66,7 +66,7 @@\n )\n \n #   IPv6address\n-IPv6address = r\"([A-Fa-f0-9:]+:+)+[A-Fa-f0-9]+\"\n+IPv6address = r\"(?:(?:[A-Fa-f0-9]{1,4}:){7}[A-Fa-f0-9]{1,4}|(?:[A-Fa-f0-9]{1,4}:){1,7}:|(?:[A-Fa-f0-9]{1,4}:){1,6}:[A-Fa-f0-9]{1,4}|(?:[A-Fa-f0-9]{1,4}:){1,5}(?::[A-Fa-f0-9]{1,4}){1,2}|(?:[A-Fa-f0-9]{1,4}:){1,4}(?::[A-Fa-f0-9]{1,4}){1,3}|(?:[A-Fa-f0-9]{1,4}:){1,3}(?::[A-Fa-f0-9]{1,4}){1,4}|(?:[A-Fa-f0-9]{1,4}:){1,2}(?::[A-Fa-f0-9]{1,4}){1,5}|[A-Fa-f0-9]{1,4}:(?:(?::[A-Fa-f0-9]{1,4}){1,6})|:(?:(?::[A-Fa-f0-9]{1,4}){1,7}|:)|fe80:(?::[A-Fa-f0-9]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(?:ffff(?::0{1,4}){0,1}:){0,1}(?:(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])|(?:[A-Fa-f0-9]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(?:25[0-5]|(?:2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\"\n \n #   IPvFuture     = \"v\" 1*HEXDIG \".\" 1*( unreserved / sub-delims / \":\" )\n IPvFuture = r\"v %(HEXDIG)s+ \\. (?: %(unreserved)s | %(sub_delims)s | : )+\" % locals()\n\n"}
{"cve": "CVE-2025-46331", "fix_patch": "--- a/internal/graph/cached_resolver.go\n+++ b/internal/graph/cached_resolver.go\n@@ -156,12 +156,15 @@\n \t\tcheckCacheTotalCounter.Inc()\n \t\tif cachedResp := c.cache.Get(cacheKey); cachedResp != nil {\n \t\t\tres := cachedResp.(*CheckResponseCacheEntry)\n-\t\t\tisValid := res.LastModified.After(req.LastCacheInvalidationTime)\n+\t\t\t// Validate both timestamp and authorization model ID to prevent cross-model cache contamination\n+\t\t\tisValid := res.LastModified.After(req.LastCacheInvalidationTime) && \n+\t\t\t\t\t\tres.CheckResponse.AuthorizationModelID == req.GetAuthorizationModelID()\n \t\t\tc.logger.Debug(\"CachedCheckResolver found cache key\",\n \t\t\t\tzap.String(\"store_id\", req.GetStoreID()),\n \t\t\t\tzap.String(\"authorization_model_id\", req.GetAuthorizationModelID()),\n \t\t\t\tzap.String(\"tuple_key\", req.GetTupleKey().String()),\n-\t\t\t\tzap.Bool(\"isValid\", isValid))\n+\t\t\t\tzap.Bool(\"isValid\", isValid),\n+\t\t\t\tzap.String(\"cached_model_id\", res.CheckResponse.AuthorizationModelID))\n \n \t\t\tspan.SetAttributes(attribute.Bool(\"cached\", isValid))\n \t\t\tif isValid {\n@@ -195,11 +198,9 @@\n \n func BuildCacheKey(req ResolveCheckRequest) string {\n \ttup := tuple.From(req.GetTupleKey())\n-\tcacheKeyString := tup.String() + req.GetInvariantCacheKey()\n+\tcacheKeyString := req.GetAuthorizationModelID() + tup.String() + req.GetInvariantCacheKey()\n \n \thasher := xxhash.New()\n-\n-\t// Digest.WriteString returns int and a nil error, ignoring\n \t_, _ = hasher.WriteString(cacheKeyString)\n \n \treturn strconv.FormatUint(hasher.Sum64(), 10)\n\n"}
{"cve": "CVE-2022-36103", "fix_patch": "--- a/internal/app/trustd/internal/reg/reg.go\n+++ b/internal/app/trustd/internal/reg/reg.go\n@@ -6,6 +6,8 @@\n \n import (\n \t\"context\"\n+\t\"encoding/pem\"\n+\t\"fmt\"\n \n \t\"github.com/cosi-project/runtime/pkg/resource\"\n \t\"github.com/cosi-project/runtime/pkg/safe\"\n@@ -39,11 +41,48 @@\n \t\treturn nil, err\n \t}\n \n-\t// TODO: Verify that the request is coming from the IP addresss declared in\n-\t// the CSR.\n-\tsigned, err := x509.NewCertificateFromCSRBytes(osRoot.TypedSpec().CA.Crt, osRoot.TypedSpec().CA.Key, in.Csr)\n+\t// Parse and validate CSR format\n+\tvar csr *x509.CertificateRequest\n+\trest := in.Csr\n+\tfor len(rest) > 0 {\n+\t\tvar p []byte\n+\t\tp, rest = pem.Decode(rest)\n+\t\tif p == nil {\n+\t\t\tbreak\n+\t\t}\n+\t\tif p.Type == \"CERTIFICATE REQUEST\" {\n+\t\t\tcsr, err = x509.ParseCertificateRequest(p)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"failed to parse CSR: %w\", err)\n+\t\t\t}\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\tif csr == nil {\n+\t\treturn nil, fmt.Errorf(\"no valid certificate request found in input\")\n+\t}\n+\n+\t// Validate worker node requirements (implements TODO + client auth check)\n+\tif len(csr.IPAddresses) == 0 {\n+\t\treturn nil, fmt.Errorf(\"CSR must include at least one IP address\")\n+\t}\n+\n+\thasClientAuth := false\n+\tfor _, eku := range csr.ExtendedKeyUsage {\n+\t\tif eku == x509.ExtendedKeyUsageClientAuth {\n+\t\t\thasClientAuth = true\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif !hasClientAuth {\n+\t\treturn nil, fmt.Errorf(\"CSR must request client authentication (Extended Key Usage)\")\n+\t}\n+\n+\t// Sign validated CSR\n+\tsigned, err := x509.NewCertificateFromCSRBytes(osRoot.TypedSpec().CA.Crt, osRoot.TypedSpec().CA.Key, csr.Raw)\n \tif err != nil {\n-\t\treturn\n+\t\treturn nil, err\n \t}\n \n \tresp = &securityapi.CertificateResponse{\n\n"}
{"cve": "CVE-2021-21291", "fix_patch": "--- a/oauthproxy.go\n+++ b/oauthproxy.go\n@@ -443,7 +443,7 @@\n \t\t\t\tcontinue\n \t\t\t}\n \n-\t\t\tif (redirectHostname == domainHostname) || (strings.HasPrefix(domain, \".\") && strings.HasSuffix(redirectHostname, domainHostname)) {\n+\t\t\tif (redirectHostname == domainHostname) || (strings.HasPrefix(domain, \".\") && strings.HasSuffix(redirectHostname, \".\"+domainHostname)) {\n \t\t\t\t// the domain names match, now validate the ports\n \t\t\t\t// if the whitelisted domain's port is '*', allow all ports\n \t\t\t\t// if the whitelisted domain contains a specific port, only allow that port\n\n"}
{"cve": "CVE-2020-25459", "fix_patch": "--- a/federatedml/tree/hetero/hetero_decision_tree_guest.py\n+++ b/federatedml/tree/hetero/hetero_decision_tree_guest.py\n@@ -106,7 +106,8 @@\n \n     def encode(self, etype=\"feature_idx\", val=None, nid=None):\n         if etype == \"feature_idx\":\n-            return val\n+            self.split_maskdict[nid] = val\n+            return None\n \n         if etype == \"feature_val\":\n             self.split_maskdict[nid] = val\n\n"}
{"cve": "CVE-2021-32804", "fix_patch": "--- a/lib/write-entry.js\n+++ b/lib/write-entry.js\n@@ -56,7 +56,8 @@\n       // absolutes on posix are also absolutes on win32\n       // so we only need to test this one to get both\n       const parsed = path.win32.parse(p)\n-      this.path = p.substr(parsed.root.length)\n+      // Remove ALL leading path roots, not just one\n+      this.path = p.replace(new RegExp(`^(${parsed.root})+`), '')\n       pathWarn = parsed.root\n     }\n \n\n"}
{"cve": "CVE-2024-1724", "fix_patch": "--- a/interfaces/builtin/home.go\n+++ b/interfaces/builtin/home.go\n@@ -76,9 +76,9 @@\n owner /run/user/[0-9]*/gvfs/{,**} r,\n owner /run/user/[0-9]*/gvfs/*/**  w,\n \n-# Disallow writes to the well-known directory included in\n+# Block writes to the well-known directory included in\n # the user's PATH on several distributions\n-audit deny @{HOME}/bin/{,**} wl,\n+deny @{HOME}/bin/{,**} wl,\n `\n \n const homeConnectedPlugAppArmorWithAllRead = `\n\n"}
{"cve": "CVE-2023-49736", "fix_patch": "--- a/superset/jinja_context.py\n+++ b/superset/jinja_context.py\n@@ -397,19 +397,20 @@\n     return validate_context_types(context)\n \n \n-def where_in(values: list[Any], mark: str = \"'\") -> str:\n+def where_in(values: list[Any], dialect: Dialect) -> str:\n     \"\"\"\n     Given a list of values, build a parenthesis list suitable for an IN expression.\n \n-        >>> where_in([1, \"b\", 3])\n+        >>> where_in([1, \"b\", 3], dialect=some_dialect)\n         (1, 'b', 3)\n \n     \"\"\"\n+    from sqlalchemy.types import String\n \n     def quote(value: Any) -> str:\n         if isinstance(value, str):\n-            value = value.replace(mark, mark * 2)\n-            return f\"{mark}{value}{mark}\"\n+            # Use dialect-specific escaping for strings\n+            return String().literal_processor(dialect=dialect)(value)\n         return str(value)\n \n     joined_values = \", \".join(quote(value) for value in values)\n@@ -449,7 +450,11 @@\n         self.set_context(**kwargs)\n \n         # custom filters\n-        self._env.filters[\"where_in\"] = where_in\n+        from functools import partial  # Already imported at top, but explicit for clarity\n+        self._env.filters[\"where_in\"] = partial(\n+            where_in, \n+            dialect=self._database.get_dialect()\n+        )\n \n     def set_context(self, **kwargs: Any) -> None:\n         self._context.update(kwargs)\n\n"}
{"cve": "CVE-2024-45043", "fix_patch": "--- a/receiver/awsfirehosereceiver/receiver.go\n+++ b/receiver/awsfirehosereceiver/receiver.go\n@@ -233,8 +233,11 @@\n // validate checks the Firehose access key in the header against\n // the one passed into the Config\n func (fmr *firehoseReceiver) validate(r *http.Request) (int, error) {\n-\tif accessKey := r.Header.Get(headerFirehoseAccessKey); accessKey != \"\" && accessKey != string(fmr.config.AccessKey) {\n-\t\treturn http.StatusUnauthorized, errInvalidAccessKey\n+\tif string(fmr.config.AccessKey) != \"\" {\n+\t\taccessKey := r.Header.Get(headerFirehoseAccessKey)\n+\t\tif accessKey == \"\" || accessKey != string(fmr.config.AccessKey) {\n+\t\t\treturn http.StatusUnauthorized, errInvalidAccessKey\n+\t\t}\n \t}\n \treturn http.StatusAccepted, nil\n }\n\n"}
{"cve": "CVE-2023-30172", "fix_patch": "--- a/mlflow/server/handlers.py\n+++ b/mlflow/server/handlers.py\n@@ -535,13 +535,34 @@\n \n     if _is_servable_proxied_run_artifact_root(run.info.artifact_uri):\n         artifact_repo = _get_artifact_repo_mlflow_artifacts()\n+        # Get base path without relative path to validate against\n+        proxied_base_path = _get_proxied_run_artifact_destination_path(\n+            proxied_artifact_root=run.info.artifact_uri,\n+            relative_path=None,\n+        )\n         artifact_path = _get_proxied_run_artifact_destination_path(\n             proxied_artifact_root=run.info.artifact_uri,\n             relative_path=request_dict[\"path\"],\n         )\n+        # Validate path does not escape restricted directory\n+        normalized_base = posixpath.normpath(proxied_base_path)\n+        normalized_full = posixpath.normpath(artifact_path)\n+        if normalized_full != normalized_base and not normalized_full.startswith(normalized_base + posixpath.sep):\n+            raise MlflowException(\n+                \"Invalid path parameter: attempts to access outside restricted directory\",\n+                error_code=INVALID_PARAMETER_VALUE,\n+            )\n     else:\n         artifact_repo = _get_artifact_repo(run)\n         artifact_path = request_dict[\"path\"]\n+        # Validate path does not escape restricted directory\n+        normalized_base = os.path.normpath(os.path.abspath(artifact_repo.base_path))\n+        normalized_full = os.path.normpath(os.path.abspath(os.path.join(artifact_repo.base_path, artifact_path)))\n+        if normalized_full != normalized_base and not normalized_full.startswith(normalized_base + os.path.sep):\n+            raise MlflowException(\n+                \"Invalid path parameter: attempts to access outside restricted directory\",\n+                error_code=INVALID_PARAMETER_VALUE,\n+            )\n \n     return _send_artifact(artifact_repo, artifact_path)\n \n@@ -901,13 +922,37 @@\n     run_id = request_message.run_id or request_message.run_uuid\n     run = _get_tracking_store().get_run(run_id)\n \n+    # Validate path parameter if present\n+    if path is not None:\n+        if _is_servable_proxied_run_artifact_root(run.info.artifact_uri):\n+            # Get base path for proxied artifacts\n+            proxied_base_path = _get_proxied_run_artifact_destination_path(\n+                proxied_artifact_root=run.info.artifact_uri,\n+                relative_path=None,\n+            )\n+            normalized_base = posixpath.normpath(proxied_base_path)\n+            normalized_full = posixpath.normpath(posixpath.join(normalized_base, path))\n+            separator = posixpath.sep\n+        else:\n+            artifact_repo = _get_artifact_repo(run)\n+            normalized_base = os.path.normpath(os.path.abspath(artifact_repo.base_path))\n+            normalized_full = os.path.normpath(os.path.abspath(os.path.join(artifact_repo.base_path, path)))\n+            separator = os.path.sep\n+        \n+        if normalized_full != normalized_base and not normalized_full.startswith(normalized_base + separator):\n+            raise MlflowException(\n+                \"Invalid path parameter: attempts to access outside restricted directory\",\n+                error_code=INVALID_PARAMETER_VALUE,\n+            )\n+\n     if _is_servable_proxied_run_artifact_root(run.info.artifact_uri):\n         artifact_entities = _list_artifacts_for_proxied_run_artifact_root(\n             proxied_artifact_root=run.info.artifact_uri,\n             relative_path=path,\n         )\n     else:\n-        artifact_entities = _get_artifact_repo(run).list_artifacts(path)\n+        artifact_repo = _get_artifact_repo(run)\n+        artifact_entities = artifact_repo.list_artifacts(path)\n \n     response_message.files.extend([a.to_proto() for a in artifact_entities])\n     response_message.root_uri = run.info.artifact_uri\n@@ -1277,13 +1322,34 @@\n \n     if _is_servable_proxied_run_artifact_root(artifact_uri):\n         artifact_repo = _get_artifact_repo_mlflow_artifacts()\n+        # Get base path without relative path to validate against\n+        proxied_base_path = _get_proxied_run_artifact_destination_path(\n+            proxied_artifact_root=artifact_uri,\n+            relative_path=None,\n+        )\n         artifact_path = _get_proxied_run_artifact_destination_path(\n             proxied_artifact_root=artifact_uri,\n             relative_path=request_dict[\"path\"],\n         )\n+        # Validate path does not escape restricted directory\n+        normalized_base = posixpath.normpath(proxied_base_path)\n+        normalized_full = posixpath.normpath(artifact_path)\n+        if normalized_full != normalized_base and not normalized_full.startswith(normalized_base + posixpath.sep):\n+            raise MlflowException(\n+                \"Invalid path parameter: attempts to access outside restricted directory\",\n+                error_code=INVALID_PARAMETER_VALUE,\n+            )\n     else:\n         artifact_repo = get_artifact_repository(artifact_uri)\n         artifact_path = request_dict[\"path\"]\n+        # Validate path does not escape restricted directory\n+        normalized_base = os.path.normpath(os.path.abspath(artifact_repo.base_path))\n+        normalized_full = os.path.normpath(os.path.abspath(os.path.join(artifact_repo.base_path, artifact_path)))\n+        if normalized_full != normalized_base and not normalized_full.startswith(normalized_base + os.path.sep):\n+            raise MlflowException(\n+                \"Invalid path parameter: attempts to access outside restricted directory\",\n+                error_code=INVALID_PARAMETER_VALUE,\n+            )\n \n     return _send_artifact(artifact_repo, artifact_path)\n \n\n"}
{"cve": "CVE-2022-28347", "fix_patch": "--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -585,8 +585,11 @@\n         return compiler.has_results()\n \n     def explain(self, using, format=None, **options):\n+        # Only allow safe EXPLAIN options to prevent SQL injection\n+        allowed_options = {'analyze', 'verbose', 'buffers', 'timing', 'settings', 'wal', 'jit'}\n+        filtered_options = {k.lower(): v for k, v in options.items() if k.lower() in allowed_options}\n         q = self.clone()\n-        q.explain_info = ExplainInfo(format, options)\n+        q.explain_info = ExplainInfo(format, filtered_options)\n         compiler = q.get_compiler(using=using)\n         return \"\\n\".join(compiler.explain_query())\n \n\n"}
{"cve": "CVE-2022-0436", "fix_patch": "--- a/lib/grunt/file.js\n+++ b/lib/grunt/file.js\n@@ -292,18 +292,39 @@\n // Read a file, optionally processing its content, then write the output.\n // Or read a directory, recursively creating directories, reading files,\n // processing content, writing output.\n-file.copy = function copy(srcpath, destpath, options) {\n-  if (file.isDir(srcpath)) {\n+file.copy = function copy(srcpath, destpath, options, srcRoot) {\n+  // Initialize srcRoot with original source path on top-level call\n+  if (srcRoot === undefined) {\n+    srcRoot = srcpath;\n+  }\n+\n+  // Check if path exists and is a directory (without following symlinks)\n+  var isDir = file.exists(srcpath) && fs.lstatSync(srcpath).isDirectory();\n+  if (isDir) {\n     // Copy a directory, recursively.\n     // Explicitly create new dest directory.\n     file.mkdir(destpath);\n     // Iterate over all sub-files/dirs, recursing.\n     fs.readdirSync(srcpath).forEach(function(filepath) {\n-      copy(path.join(srcpath, filepath), path.join(destpath, filepath), options);\n+      var currentSrc = path.join(srcpath, filepath);\n+      // Compute relative path from original source root to current source\n+      var relativePath = path.relative(srcRoot, currentSrc);\n+      // Prevent path traversal by blocking paths with \"..\" components\n+      if (relativePath.split(path.sep).some(function(part) { return part === '..'; })) {\n+        return;\n+      }\n+      var currentDest = path.join(destpath, relativePath);\n+      copy(currentSrc, currentDest, options, srcRoot);\n     });\n   } else {\n+    // For single files, ensure we're not escaping the source root\n+    var relativePath = path.relative(srcRoot, srcpath);\n+    if (relativePath.split(path.sep).some(function(part) { return part === '..'; })) {\n+      return;\n+    }\n+    var currentDest = path.join(destpath, relativePath);\n     // Copy a single file.\n-    file._copy(srcpath, destpath, options);\n+    file._copy(srcpath, currentDest, options);\n   }\n };\n \n\n"}
{"cve": "CVE-2022-23857", "fix_patch": "--- a/model/criteria/criteria.go\n+++ b/model/criteria/criteria.go\n@@ -21,7 +21,7 @@\n \tOffset int\n }\n \n-func (c Criteria) OrderBy() string {\n+func (c Criteria) OrderBy() squirrel.Sqlizer {\n \tif c.Sort == \"\" {\n \t\tc.Sort = \"title\"\n \t}\n@@ -37,14 +37,21 @@\n \t\t\tmapped = f.order\n \t\t}\n \t}\n+\t\n+\torderBy := squirrel.OrderBy(mapped)\n \tif c.Order != \"\" {\n-\t\tmapped = mapped + \" \" + c.Order\n+\t\torderBy = orderBy.Desc()\n \t}\n-\treturn mapped\n+\treturn orderBy\n }\n \n func (c Criteria) ToSql() (sql string, args []interface{}, err error) {\n-\treturn c.Expression.ToSql()\n+\tquery := c.Expression\n+\tif c.Sort != \"\" {\n+\t\torderBy := c.OrderBy()\n+\t\tquery = squirrel.Select(\"*\").From(\"\").OrderBy(orderBy) // Dummy from clause to satisfy squirrel\n+\t}\n+\treturn query.ToSql()\n }\n \n func (c Criteria) MarshalJSON() ([]byte, error) {\n\n"}
{"cve": "CVE-2021-3281", "fix_patch": "--- a/django/utils/archive.py\n+++ b/django/utils/archive.py\n@@ -156,6 +156,11 @@\n             if leading:\n                 name = self.split_leading_dir(name)[1]\n             filename = os.path.join(to_path, name)\n+            # Prevent path traversal by ensuring extracted paths are within target directory\n+            abs_to_path = os.path.abspath(to_path)\n+            abs_filename = os.path.abspath(filename)\n+            if os.path.commonpath([abs_to_path, abs_filename]) != abs_to_path:\n+                continue\n             if member.isdir():\n                 if filename:\n                     os.makedirs(filename, exist_ok=True)\n@@ -199,6 +204,11 @@\n             if leading:\n                 name = self.split_leading_dir(name)[1]\n             filename = os.path.join(to_path, name)\n+            # Prevent path traversal by ensuring extracted paths are within target directory\n+            abs_to_path = os.path.abspath(to_path)\n+            abs_filename = os.path.abspath(filename)\n+            if os.path.commonpath([abs_to_path, abs_filename]) != abs_to_path:\n+                continue\n             if filename.endswith(('/', '\\\\')):\n                 # A directory\n                 os.makedirs(filename, exist_ok=True)\n\n"}
{"cve": "CVE-2022-41672", "fix_patch": "\n\n"}
{"cve": "CVE-2020-26299", "fix_patch": "--- a/src/fs.js\n+++ b/src/fs.js\n@@ -29,7 +29,15 @@\n \n     const fsPath = (() => {\n       const resolvedPath = nodePath.join(this.root, clientPath);\n-      return nodePath.resolve(nodePath.normalize(nodePath.join(resolvedPath)));\n+      const finalPath = nodePath.resolve(nodePath.normalize(resolvedPath));\n+      \n+      // Validate path is within root directory (fix for path traversal)\n+      const relativePath = nodePath.relative(this.root, finalPath);\n+      if (relativePath.startsWith('..')) {\n+        throw new errors.FileSystemError('Path traversal outside root directory is not allowed');\n+      }\n+\n+      return finalPath;\n     })();\n \n     return {\n\n"}
{"cve": "CVE-2025-24366", "fix_patch": "--- a/internal/sftpd/ssh_cmd.go\n+++ b/internal/sftpd/ssh_cmd.go\n@@ -425,6 +425,10 @@\n \t\treturn command, errUnsupportedConfig\n \t}\n \tif c.command == \"rsync\" {\n+\t\t// Validate rsync arguments to prevent command injection\n+\t\tif err := c.validateRsyncArgs(args); err != nil {\n+\t\t\treturn command, err\n+\t\t}\n \t\t// we cannot avoid that rsync creates symlinks so if the user has the permission\n \t\t// to create symlinks we add the option --safe-links to the received rsync command if\n \t\t// it is not already set. This should prevent to create symlinks that point outside\n@@ -454,6 +458,49 @@\n \treturn command, nil\n }\n \n+// validateRsyncArgs checks for potentially dangerous rsync options that could be used for command injection\n+func (c *sshCommand) validateRsyncArgs(args []string) error {\n+\t// List of dangerous rsync options that could be used for command injection or accessing unauthorized files\n+\tdangerousOptions := map[string]bool{\n+\t\t\"--include-from\": true,\n+\t\t\"--exclude-from\": true,\n+\t\t\"--filter\":       true,\n+\t\t\"--files-from\":   true,\n+\t\t\"--link-dest\":    true,\n+\t\t\"--copy-dest\":    true,\n+\t\t\"--backup-dir\":   true,\n+\t\t\"--suffix\":       true,\n+\t\t\"--remove-source-files\": true,\n+\t\t\"--delete\":          true,\n+\t\t\"--delete-excluded\": true,\n+\t\t\"--delete-after\":    true,\n+\t\t\"--delete-before\":   true,\n+\t\t\"--delete-delay\":    true,\n+\t\t\"--prune-empty-dirs\": true,\n+\t}\n+\n+\tfor _, arg := range args {\n+\t\t// Check for long options with parameters\n+\t\tif strings.HasPrefix(arg, \"--\") && strings.Contains(arg, \"=\") {\n+\t\t\toption := strings.SplitN(arg, \"=\", 2)[0]\n+\t\t\tif dangerousOptions[option] {\n+\t\t\t\treturn errors.New(\"dangerous rsync option not allowed: \" + option)\n+\t\t\t}\n+\t\t} else if strings.HasPrefix(arg, \"--\") {\n+\t\t\t// Check for long options without parameters\n+\t\t\tif dangerousOptions[arg] {\n+\t\t\t\treturn errors.New(\"dangerous rsync option not allowed: \" + arg)\n+\t\t\t}\n+\t\t} else if len(arg) == 1 && strings.HasPrefix(arg, \"-\") {\n+\t\t\t// Check for short options (single character)\n+\t\t\t// Note: This is a basic check and may need to be expanded based on specific risks\n+\t\t\treturn errors.New(\"short rsync options not allowed for security reasons\")\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n // for the supported commands, the destination path, if any, is the last argument\n func (c *sshCommand) getDestPath() string {\n \tif len(c.args) == 0 {\n\n"}
{"cve": "CVE-2025-23042", "fix_patch": "--- a/gradio/utils.py\n+++ b/gradio/utils.py\n@@ -1512,14 +1512,20 @@\n ) -> tuple[\n     bool, Literal[\"in_blocklist\", \"allowed\", \"created\", \"not_created_or_allowed\"]\n ]:\n+    # Case-normalize paths for case-insensitive file systems\n+    normalized_path = path.resolve().casefold()\n+    normalized_blocked = [Path(p).resolve().casefold() for p in blocked_paths]\n+    normalized_allowed = [Path(p).resolve().casefold() for p in allowed_paths]\n+    normalized_created = [Path(p).resolve().casefold() for p in created_paths]\n+    \n     in_blocklist = any(\n-        is_in_or_equal(path, blocked_path) for blocked_path in blocked_paths\n+        is_in_or_equal(normalized_path, blocked_path) for blocked_path in normalized_blocked\n     )\n     if in_blocklist:\n         return False, \"in_blocklist\"\n-    if any(is_in_or_equal(path, allowed_path) for allowed_path in allowed_paths):\n+    if any(is_in_or_equal(normalized_path, allowed_path) for allowed_path in normalized_allowed):\n         return True, \"allowed\"\n-    if any(is_in_or_equal(path, created_path) for created_path in created_paths):\n+    if any(is_in_or_equal(normalized_path, created_path) for created_path in normalized_created):\n         return True, \"created\"\n     return False, \"not_created_or_allowed\"\n \n\n"}
{"cve": "CVE-2018-12976", "fix_patch": "--- a/gosrc/gosrc.go\n+++ b/gosrc/gosrc.go\n@@ -380,6 +380,16 @@\n \trepo := strings.TrimSuffix(clonePath, \".\"+im.vcs)\n \tdirName := importPath[len(im.projectRoot):]\n \n+\t// Prevent path traversal in import path\n+\ttrimmedRepo := strings.TrimSuffix(repo, \"/\")\n+\tif dirName != \"\" {\n+\t\tfullPath := trimmedRepo + dirName\n+\t\tcleanPath := path.Clean(fullPath)\n+\t\tif !strings.HasPrefix(cleanPath, trimmedRepo+\"/\") {\n+\t\t\treturn nil, NotFoundError{Message: \"invalid import path: path traversal detected\"}\n+\t\t}\n+\t}\n+\n \tresolvedPath := repo + dirName\n \tdir, err := getStatic(ctx, client, resolvedPath, etag)\n \tif err == errNoMatch {\n\n"}
{"cve": "CVE-2021-3987", "fix_patch": "--- a/cps/shelf.py\n+++ b/cps/shelf.py\n@@ -248,6 +248,13 @@\n         if config.config_kobo_sync:\n             shelf.kobo_sync = True if to_save.get(\"kobo_sync\") else False\n         shelf_title = to_save.get(\"title\", \"\")\n+        \n+        # Verify permission to create public shelves\n+        if not shelf_id and shelf.is_public == 1:\n+            if not current_user.role_edit_shelfs():\n+                flash(_(u\"Sorry you are not allowed to create public shelves\"), category=\"error\")\n+                return redirect(url_for('web.index'))\n+        \n         if check_shelf_is_unique(shelf, shelf_title, shelf_id):\n             shelf.name = shelf_title\n             if not shelf_id:\n\n"}
{"cve": "CVE-2022-29822", "fix_patch": "\n\n"}
{"cve": "CVE-2023-5122", "fix_patch": ""}
{"cve": "CVE-2024-5138", "fix_patch": "--- a/overlord/hookstate/ctlcmd/ctlcmd.go\n+++ b/overlord/hookstate/ctlcmd/ctlcmd.go\n@@ -183,11 +183,19 @@\n func isAllowedToRun(uid uint32, args []string) bool {\n \t// A command can run if any of the following are true:\n \t//\t* It runs as root\n-\t//\t* It's contained in nonRootAllowed\n-\t//\t* It's used with the -h or --help flags\n+\t//\t* It's contained in nonRootAllowed (and has valid args)\n+\t//\t* It's help for an allowed command (non-root)\n \t// note: commands still need valid context and snaps can only access own config.\n-\treturn uid == 0 ||\n-\t\tstrutil.ListContains(nonRootAllowed, args[0]) ||\n-\t\tstrutil.ListContains(args, \"-h\") ||\n-\t\tstrutil.ListContains(args, \"--help\")\n-}\n+\tif uid == 0 {\n+\t\treturn true\n+\t}\n+\n+\tif len(args) == 0 {\n+\t\treturn false\n+\t}\n+\n+\tcmd := args[0]\n+\thasHelpFlag := strutil.ListContains(args, \"-h\") || strutil.ListContains(args, \"--help\")\n+\n+\treturn strutil.ListContains(nonRootAllowed, cmd) && (!hasHelpFlag || strutil.ListContains(nonRootAllowed, cmd))\n+}\n\n"}
{"cve": "CVE-2018-3733", "fix_patch": "--- a/crud-file-server.js\n+++ b/crud-file-server.js\n@@ -3,8 +3,19 @@\n // don't let users crawl up the folder structure by using a/../../../c/d\n var cleanUrl = function(url) { \n \turl = decodeURIComponent(url);\n-\twhile(url.indexOf('..').length > 0) { url = url.replace('..', ''); }\n-\treturn url;\n+\tvar segments = url.split('/');\n+\tvar cleaned = [];\n+\tfor (var i = 0; i < segments.length; i++) {\n+\t\tvar segment = segments[i];\n+\t\tif (segment === '..') {\n+\t\t\tif (cleaned.length > 0) {\n+\t\t\t\tcleaned.pop();\n+\t\t\t}\n+\t\t} else if (segment !== '.' && segment !== '') {\n+\t\t\tcleaned.push(segment);\n+\t\t}\n+\t}\n+\treturn cleaned.join('/');\n };\n \n /*  \n\n"}
{"cve": "CVE-2025-27154", "fix_patch": "--- a/spotipy/cache_handler.py\n+++ b/spotipy/cache_handler.py\n@@ -94,6 +94,7 @@\n         try:\n             with open(self.cache_path, \"w\", encoding='utf-8') as f:\n                 f.write(json.dumps(token_info, cls=self.encoder_cls))\n+            os.chmod(self.cache_path, 0o600)\n         except OSError:\n             logger.warning(f\"Couldn't write token to cache at: {self.cache_path}\")\n \n\n"}
{"cve": "CVE-2024-27289", "fix_patch": "--- a/internal/sanitize/sanitize.go\n+++ b/internal/sanitize/sanitize.go\n@@ -44,18 +44,14 @@\n \t\t\t\tstr = \"null\"\n \t\t\tcase int64:\n \t\t\t\tstr = strconv.FormatInt(arg, 10)\n-\t\t\t\t// Prevent SQL injection via Line Comment Creation\n-\t\t\t\t// https://github.com/jackc/pgx/security/advisories/GHSA-m7wr-2xf7-cm9p\n-\t\t\t\tif arg < 0 {\n-\t\t\t\t\tstr = \"(\" + str + \")\"\n-\t\t\t\t}\n+\t\t\t\t// Always wrap numeric values in parentheses to prevent SQL injection\n+\t\t\t\t// Fixes: CVE-2023-39325 - SQL injection via numeric placeholder with preceding minus\n+\t\t\t\tstr = \"(\" + str + \")\"\n \t\t\tcase float64:\n-\t\t\t\t// Prevent SQL injection via Line Comment Creation\n-\t\t\t\t// https://github.com/jackc/pgx/security/advisories/GHSA-m7wr-2xf7-cm9p\n \t\t\t\tstr = strconv.FormatFloat(arg, 'f', -1, 64)\n-\t\t\t\tif arg < 0 {\n-\t\t\t\t\tstr = \"(\" + str + \")\"\n-\t\t\t\t}\n+\t\t\t\t// Always wrap numeric values in parentheses to prevent SQL injection\n+\t\t\t\t// Fixes: CVE-2023-39325 - SQL injection via numeric placeholder with preceding minus\n+\t\t\t\tstr = \"(\" + str + \")\"\n \t\t\tcase bool:\n \t\t\t\tstr = strconv.FormatBool(arg)\n \t\t\tcase []byte:\n\n"}
{"cve": "CVE-2017-16083", "fix_patch": "--- a/lib/router.js\n+++ b/lib/router.js\n@@ -730,7 +730,18 @@\n     };\n     dispatch[\"static\"] = function(pathname, req, res) {\n       var full_path;\n-      full_path = \"\" + dispatch.static_route + (unescape(pathname));\n+      const userPath = decodeURIComponent(pathname);\n+      const resolvedPath = path_tools.resolve(dispatch.static_route, userPath);\n+      const normalizedStatic = path_tools.normalize(dispatch.static_route);\n+      const normalizedResolved = path_tools.normalize(resolvedPath);\n+      \n+      // Prevent path traversal attacks by restricting to static directory\n+      const isWithinStatic = normalizedResolved === normalizedStatic || normalizedResolved.startsWith(normalizedStatic + path_tools.sep);\n+      if (!isWithinStatic) {\n+        return dispatch._404(req, res, pathname);\n+      }\n+      \n+      full_path = resolvedPath;\n       return fs.exists(full_path, function(exists) {\n         var e, error;\n         if (exists) {\n\n"}
{"cve": "CVE-2021-3583", "fix_patch": "\n\n"}
{"cve": "CVE-2021-43798", "fix_patch": "--- a/pkg/api/plugins.go\n+++ b/pkg/api/plugins.go\n@@ -292,6 +292,24 @@\n \trequestedFile := filepath.Clean(web.Params(c.Req)[\"*\"])\n \tpluginFilePath := filepath.Join(plugin.PluginDir, requestedFile)\n \n+\t// Resolve absolute paths for security validation\n+\tpluginDirAbs, err := filepath.Abs(plugin.PluginDir)\n+\tif err != nil {\n+\t\tc.JsonApiErr(500, \"Could not resolve plugin directory\", err)\n+\t\treturn\n+\t}\n+\tpluginFilePathAbs, err := filepath.Abs(pluginFilePath)\n+\tif err != nil {\n+\t\tc.JsonApiErr(500, \"Could not resolve plugin file path\", err)\n+\t\treturn\n+\t}\n+\n+\t// Prevent directory traversal by enforcing plugin directory boundary\n+\tif !strings.HasPrefix(pluginFilePathAbs, pluginDirAbs+string(os.PathSeparator)) {\n+\t\tc.JsonApiErr(403, \"Access to plugin file is forbidden\", nil)\n+\t\treturn\n+\t}\n+\n \tif !plugin.IncludedInSignature(requestedFile) {\n \t\ths.log.Warn(\"Access to requested plugin file will be forbidden in upcoming Grafana versions as the file \"+\n \t\t\t\"is not included in the plugin signature\", \"file\", requestedFile)\n\n"}
{"cve": "CVE-2021-33203", "fix_patch": "--- a/django/contrib/admindocs/views.py\n+++ b/django/contrib/admindocs/views.py\n@@ -329,15 +329,22 @@\n         else:\n             # This doesn't account for template loaders (#24128).\n             for index, directory in enumerate(default_engine.dirs):\n-                template_file = Path(directory) / template\n-                if template_file.exists():\n-                    template_contents = template_file.read_text()\n+                tmpl_path = Path(directory) / template\n+                abs_dir = Path(directory).resolve()\n+                abs_tmpl = tmpl_path.resolve()\n+                \n+                # Check if template is inside the allowed directory\n+                if abs_tmpl.is_relative_to(abs_dir):\n+                    exists = abs_tmpl.exists()\n+                    contents = abs_tmpl.read_text() if exists else ''\n                 else:\n-                    template_contents = ''\n+                    exists = False\n+                    contents = ''\n+                \n                 templates.append({\n-                    'file': template_file,\n-                    'exists': template_file.exists(),\n-                    'contents': template_contents,\n+                    'file': tmpl_path,\n+                    'exists': exists,\n+                    'contents': contents,\n                     'order': index,\n                 })\n         return super().get_context_data(**{\n\n"}
{"cve": "CVE-2023-32303", "fix_patch": "--- a/planet/auth.py\n+++ b/planet/auth.py\n@@ -242,6 +242,8 @@\n         LOGGER.debug(f'Writing to {self.path}')\n         with open(self.path, 'w') as fp:\n             fp.write(json.dumps(contents))\n+        # Restrict permissions to user-read/write only (0o600)\n+        os.chmod(self.path, 0o600)\n \n     def read(self) -> dict:\n         LOGGER.debug(f'Reading from {self.path}')\n\n"}
{"cve": "CVE-2024-3571", "fix_patch": "--- a/libs/langchain/langchain/storage/file_system.py\n+++ b/libs/langchain/langchain/storage/file_system.py\n@@ -55,7 +55,15 @@\n         \"\"\"\n         if not re.match(r\"^[a-zA-Z0-9_.\\-/]+$\", key):\n             raise InvalidKeyException(f\"Invalid characters in key: {key}\")\n-        return self.root_path / key\n+        \n+        full_path = self.root_path / key\n+        # Ensure path doesn't escape root directory\n+        try:\n+            full_path.relative_to(self.root_path)\n+        except ValueError:\n+            raise InvalidKeyException(f\"Path traversal attempt blocked for key: {key}\")\n+        \n+        return full_path\n \n     def mget(self, keys: Sequence[str]) -> List[Optional[bytes]]:\n         \"\"\"Get the values associated with the given keys.\n\n"}
{"cve": "CVE-2022-0577", "fix_patch": "--- a/scrapy/downloadermiddlewares/redirect.py\n+++ b/scrapy/downloadermiddlewares/redirect.py\n@@ -1,4 +1,5 @@\n import logging\n+import fnmatch\n from urllib.parse import urljoin, urlparse\n \n from w3lib.url import safe_url_string\n@@ -29,6 +30,18 @@\n     def _redirect(self, redirected, request, spider, reason):\n         ttl = request.meta.setdefault('redirect_ttl', self.max_redirect_times)\n         redirects = request.meta.get('redirect_times', 0) + 1\n+\n+        # Validate redirect URL against spider's allowed domains\n+        parsed_url = urlparse(redirected.url)\n+        netloc = parsed_url.netloc\n+        if hasattr(spider, 'allowed_domains') and spider.allowed_domains:\n+            if not any(fnmatch.fnmatch(netloc, domain) for domain in spider.allowed_domains):\n+                logger.debug(\n+                    \"Redirect to %(url)s blocked: Not in allowed domains %(domains)s\",\n+                    {\"url\": redirected.url, \"domains\": spider.allowed_domains},\n+                    extra={\"spider\": spider}\n+                )\n+                raise IgnoreRequest(\"Redirect URL not in allowed domains\")\n \n         if ttl and redirects <= self.max_redirect_times:\n             redirected.meta['redirect_times'] = redirects\n@@ -107,7 +120,8 @@\n         interval, url = get_meta_refresh(response,\n                                          ignore_tags=self._ignore_tags)\n         if url and interval < self._maxdelay:\n-            redirected = self._redirect_request_using_get(request, url)\n+            redirected_url = urljoin(request.url, url)\n+            redirected = self._redirect_request_using_get(request, redirected_url)\n             return self._redirect(redirected, request, spider, 'meta refresh')\n \n         return response\n\n"}
{"cve": "CVE-2022-35936", "fix_patch": ""}
{"cve": "CVE-2020-28360", "fix_patch": "--- a/src/index.js\n+++ b/src/index.js\n@@ -4,8 +4,16 @@\n   /^(::f{4}:)?172\\.(1[6-9]|2\\d|30|31)\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(ip) ||\n   /^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(ip) ||\n   /^(::f{4}:)?169\\.254\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(ip) ||\n+  /^(::f{4}:)?0\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$/i.test(ip) ||\n+  /^(::f{4}:)?100\\.(6[4-9]|7[0-9]|8[0-9]|9[0-9]|1[0-1][0-9]|12[0-7])\\.[0-9]{1,3}\\.[0-9]{1,3}$/i.test(ip) ||\n+  /^(::f{4}:)?198\\.(18|19)\\.[0-9]{1,3}\\.[0-9]{1,3}$/i.test(ip) ||\n+  /^(::f{4}:)?198\\.51\\.100\\.[0-9]{1,3}$/i.test(ip) ||\n+  /^(::f{4}:)?203\\.0\\.113\\.[0-9]{1,3}$/i.test(ip) ||\n+  /^(::f{4}:)?(24[0-9]|25[0-5])\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$/i.test(ip) ||\n   /^f[cd][0-9a-f]{2}:/i.test(ip) ||\n   /^fe80:/i.test(ip) ||\n   /^::1$/.test(ip) ||\n-  /^::$/.test(ip)\n+  /^::$/.test(ip) ||\n+  /^ff[0-9a-f]{2}:/i.test(ip) ||\n+  /^fec0:/i.test(ip)\n )\n\n"}
{"cve": "CVE-2018-3772", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -1,31 +1,10 @@\n-var cp = require('child_process');\n+var which = require('which');\n \n module.exports = function whereis(name, cb) {\n-  cp.exec('which ' + name, function(error, stdout, stderr) {\n-    stdout = stdout.split('\\n')[0];\n-    if (error || stderr || stdout === '' || stdout.charAt(0) !== '/') {\n-      stdout = stdout.split('\\n')[0];\n-      cp.exec('whereis ' + name, function(error, stdout, stderr) {\n-        if (error || stderr || stdout === '' || stdout.indexOf( '/' ) === -1) {\n-          cp.exec('where ' + name, function (error, stdout, stderr) { //windows\n-            if (error || stderr || stdout === '' || stdout.indexOf('\\\\') === -1) {\n-              cp.exec('for %i in (' + name + '.exe) do @echo. %~$PATH:i', function (error, stdout, stderr) { //windows xp\n-                if (error || stderr || stdout === '' || stdout.indexOf('\\\\') === -1) {\n-                  return cb(new Error('Could not find ' + name + ' on your system'));\n-                }\n-                return cb(null, stdout);\n-              });\n-            } else {\n-              return cb(null, stdout);\n-            }\n-          });\n-        }\n-        else {\n-          return cb(null, stdout.split(' ')[1]);\n-        }\n-      });\n-    } else {\n-      return cb(null, stdout);\n+  which(name, function(error, path) {\n+    if (error) {\n+      return cb(new Error('Could not find ' + name + ' on your system'));\n     }\n+    return cb(null, path);\n   });\n };\n\n"}
{"cve": "CVE-2020-8132", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -6,6 +6,7 @@\n var fs   = require(\"fs\");\n var util = require(\"util\");\n var exec = require(\"child_process\").exec;\n+var execFile = require(\"child_process\").execFile;\n \n function PDFImage(pdfFilePath, options) {\n   if (!options) options = {};\n@@ -23,10 +24,7 @@\n \n PDFImage.prototype = {\n   constructGetInfoCommand: function () {\n-    return util.format(\n-      \"pdfinfo \\\"%s\\\"\",\n-      this.pdfFilePath\n-    );\n+    return [ \"pdfinfo\", this.pdfFilePath ];\n   },\n   parseGetInfoCommandOutput: function (output) {\n     var info = {};\n@@ -40,8 +38,10 @@\n   getInfo: function () {\n     var self = this;\n     var getInfoCommand = this.constructGetInfoCommand();\n+    var command = getInfoCommand[0];\n+    var args = getInfoCommand.slice(1);\n     var promise = new Promise(function (resolve, reject) {\n-      exec(getInfoCommand, function (err, stdout, stderr) {\n+      execFile(command, args, {}, function (err, stdout, stderr) {\n         if (err) {\n           return reject({\n             message: \"Failed to get PDF'S information\",\n\n"}
{"cve": "CVE-2023-26145", "fix_patch": "--- a/src/pydash/helpers.py\n+++ b/src/pydash/helpers.py\n@@ -179,10 +179,12 @@\n     value = _base_get_item(obj, key, default=UNSET)\n     if value is UNSET:\n         value = default\n-        try:\n-            value = getattr(obj, key)\n-        except Exception:\n-            pass\n+        # Block access to private/dunder attributes to prevent code injection\n+        if not key.startswith('__'):\n+            try:\n+                value = getattr(obj, key)\n+            except Exception:\n+                pass\n     return value\n \n \n@@ -212,7 +214,7 @@\n                 # into the key index.\n                 obj[:] = (obj + [None] * key)[:key]\n             obj.append(value)\n-    elif (allow_override or not hasattr(obj, key)) and obj is not None:\n+    elif obj is not None and not key.startswith('__') and (allow_override or not hasattr(obj, key)):\n         setattr(obj, key, value)\n \n     return obj\n\n"}
{"cve": "CVE-2020-10691", "fix_patch": "--- a/lib/ansible/galaxy/collection.py\n+++ b/lib/ansible/galaxy/collection.py\n@@ -185,7 +185,13 @@\n                     _extract_tar_file(collection_tar, file_name, b_collection_path, b_temp_path,\n                                       expected_hash=file_info['chksum_sha256'])\n                 else:\n-                    os.makedirs(os.path.join(b_collection_path, to_bytes(file_name, errors='surrogate_or_strict')))\n+                    b_dir_path = os.path.join(b_collection_path, to_bytes(file_name, errors='surrogate_or_strict'))\n+                    # Validate path is within collection directory to prevent path traversal\n+                    abs_collection = os.path.abspath(b_collection_path)\n+                    abs_dir_path = os.path.abspath(b_dir_path)\n+                    if not abs_dir_path.startswith(abs_collection + os.path.sep):\n+                        raise AnsibleError(f\"Path traversal attempt detected in directory '{to_text(file_name)}'\")\n+                    os.makedirs(b_dir_path)\n \n     def set_latest_version(self):\n         self.versions = set([self.latest_version])\n@@ -926,6 +932,13 @@\n                                % (n_filename, to_native(tar.name)))\n \n         b_dest_filepath = os.path.join(b_dest, to_bytes(filename, errors='surrogate_or_strict'))\n+        \n+        # Validate path is within destination directory to prevent path traversal\n+        abs_dest = os.path.abspath(b_dest)\n+        abs_dest_filepath = os.path.abspath(b_dest_filepath)\n+        if not abs_dest_filepath.startswith(abs_dest + os.path.sep):\n+            raise AnsibleError(f\"Path traversal attempt detected in file '{to_text(filename)}'\")\n+        \n         b_parent_dir = os.path.split(b_dest_filepath)[0]\n         if not os.path.exists(b_parent_dir):\n             # Seems like Galaxy does not validate if all file entries have a corresponding dir ftype entry. This check\n\n"}
{"cve": "CVE-2020-7649", "fix_patch": "--- a/lib/filters/index.js\n+++ b/lib/filters/index.js\n@@ -77,11 +77,37 @@\n         return false;\n       }\n \n-      // reconstruct the url from the user config\n+      // Helper function to check for path traversal attempts\n+      const isPathSafe = (basePath, newPath) => {\n+        const baseSegments = basePath.split('/').filter(Boolean);\n+        const newSegments = newPath.split('/').filter(Boolean);\n+        let traversalCount = 0;\n+        \n+        for (const segment of newSegments) {\n+          if (segment === '..') {\n+            traversalCount++;\n+          } else if (segment !== '.') {\n+            if (traversalCount > 0) {\n+              traversalCount--;\n+            }\n+          }\n+        }\n+        \n+        return traversalCount === 0 && newSegments.length + traversalCount <= baseSegments.length;\n+      };\n+\n+      // reconstruct the url from the user config with path validation\n       for (let i = 1; i < res.length; i++) {\n         const val = fromConfig[keys[i - 1].name];\n         if (val) {\n+          const originalPath = url;\n           url = url.replace(res[i], val);\n+          \n+          // Validate that path traversal doesn't occur\n+          if (!isPathSafe('/', url)) {\n+            logger.warn({ originalPath, val, url }, 'Path traversal attempt detected');\n+            return false;\n+          }\n         }\n       }\n \n\n"}
{"cve": "CVE-2022-0155", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -392,9 +392,16 @@\n     var redirectUrlParts = url.parse(redirectUrl);\n     Object.assign(this._options, redirectUrlParts);\n \n-    // Drop the Authorization header if redirecting to another domain\n+    // Drop sensitive headers when redirecting to another domain\n     if (!(redirectUrlParts.host === currentHost || isSubdomainOf(redirectUrlParts.host, currentHost))) {\n+      // Remove authorization headers\n       removeMatchingHeaders(/^authorization$/i, this._options.headers);\n+      // Remove cookie headers to prevent session leakage\n+      removeMatchingHeaders(/^cookie$/i, this._options.headers);\n+      // Remove any set-cookie headers that might establish new sessions\n+      removeMatchingHeaders(/^set-cookie$/i, this._options.headers);\n+      // Remove any other sensitive headers that could expose personal information\n+      removeMatchingHeaders(/^(x-)?auth(enticate|orization|session|token)$/i, this._options.headers);\n     }\n \n     // Evaluate the beforeRedirect callback\n\n"}
{"cve": "CVE-2020-7627", "fix_patch": "--- a/key-sender.js\n+++ b/key-sender.js\n@@ -1,4 +1,4 @@\n-var exec = require('child_process').exec;\n+var spawn = require('child_process').spawn;\n var path = require(\"path\");\n \n module.exports = function() {\n\n"}
{"cve": "CVE-2024-29041", "fix_patch": ""}
{"cve": "CVE-2022-31145", "fix_patch": "--- a/auth/authzserver/resource_server.go\n+++ b/auth/authzserver/resource_server.go\n@@ -4,7 +4,8 @@\n \t\"context\"\n \t\"encoding/json\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"io\"\n+\t\"time\"\n \t\"mime\"\n \t\"net/http\"\n \t\"net/url\"\n@@ -36,6 +37,16 @@\n \tclaimsRaw := map[string]interface{}{}\n \tif err = json.Unmarshal(raw, &claimsRaw); err != nil {\n \t\treturn nil, fmt.Errorf(\"failed to unmarshal user info claim into UserInfo type. Error: %w\", err)\n+\t}\n+\n+\t// Verify token expiration\n+\texp, expOk := claimsRaw[\"exp\"].(float64)\n+\tif !expOk {\n+\t\treturn nil, fmt.Errorf(\"token missing exp claim\")\n+\t}\n+\tnow := time.Now().Unix()\n+\tif int64(exp) < now {\n+\t\treturn nil, fmt.Errorf(\"token has expired\")\n \t}\n \n \treturn verifyClaims(sets.NewString(append(r.allowedAudience, expectedAudience)...), claimsRaw)\n\n"}
{"cve": "CVE-2021-23387", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -15,7 +15,10 @@\n \n     var req = args[0]\n     var res = args[1]\n-    var url = u.parse(req.url)\n+    var protocol = req.connection.encrypted ? 'https' : 'http'\n+    var host = req.headers.host\n+    var fullUrl = protocol + '://' + host + req.url\n+    var url = u.parse(fullUrl)\n     var length = url.pathname.length\n     var hasSlash = url.pathname.charAt(length - 1) === '/'\n \n\n"}
{"cve": "CVE-2019-10856", "fix_patch": "--- a/notebook/auth/login.py\n+++ b/notebook/auth/login.py\n@@ -44,18 +44,24 @@\n         # instead of %5C, causing `\\\\` to behave as `//`\n         url = url.replace(\"\\\\\", \"%5C\")\n         parsed = urlparse(url)\n-        if parsed.netloc or not (parsed.path + '/').startswith(self.base_url):\n-            # require that next_url be absolute path within our path\n+        # Check if URL needs validation (has netloc or doesn't start with base_url)\n+        needs_validation = parsed.netloc or not (parsed.path + '/').startswith(self.base_url)\n+        \n+        if needs_validation:\n             allow = False\n-            # OR pass our cross-origin check\n+            # Always run CORS check if we have a netloc (even empty string)\n             if parsed.netloc:\n-                # if full URL, run our cross-origin check:\n-                origin = '%s://%s' % (parsed.scheme, parsed.netloc)\n-                origin = origin.lower()\n-                if self.allow_origin:\n-                    allow = self.allow_origin == origin\n-                elif self.allow_origin_pat:\n-                    allow = bool(self.allow_origin_pat.match(origin))\n+                # Handle empty netloc case first\n+                if not parsed.netloc:\n+                    allow = False\n+                else:\n+                    # For non-empty netloc, run standard cross-origin check\n+                    origin = '%s://%s' % (parsed.scheme, parsed.netloc)\n+                    origin = origin.lower()\n+                    if self.allow_origin:\n+                        allow = self.allow_origin == origin\n+                    elif self.allow_origin_pat:\n+                        allow = bool(self.allow_origin_pat.match(origin))\n             if not allow:\n                 # not allowed, use default\n                 self.log.warning(\"Not allowing login redirect to %r\" % url)\n\n"}
{"cve": "CVE-2017-0360", "fix_patch": "--- a/trytond/tools/misc.py\n+++ b/trytond/tools/misc.py\n@@ -32,7 +32,12 @@\n         \"Join paths and ensure it still below root\"\n         path = os.path.join(root, *paths)\n         path = os.path.normpath(path)\n-        if not path.startswith(root):\n+        if not os.path.isabs(path):\n+            raise IOError(\"Permission denied: %s\" % name)\n+        try:\n+            if os.path.commonpath([root, path]) != root:\n+                raise IOError(\"Permission denied: %s\" % name)\n+        except ValueError:\n             raise IOError(\"Permission denied: %s\" % name)\n         return path\n \n\n"}
{"cve": "CVE-2021-4315", "fix_patch": ""}
{"cve": "CVE-2020-15278", "fix_patch": "--- a/redbot/cogs/mod/kickban.py\n+++ b/redbot/cogs/mod/kickban.py\n@@ -471,46 +471,22 @@\n \n         for user_id in user_ids:\n             user = discord.Object(id=user_id)\n-            audit_reason = get_audit_reason(author, reason)\n-            queue_entry = (guild.id, user_id)\n-            async with self.config.guild(guild).current_tempbans() as tempbans:\n+            success, message = await self.ban_user(\n+                user=user, ctx=ctx, days=days, reason=reason, create_modlog_case=True\n+            )\n+            if success:\n+                banned.append(user_id)\n+                # Handle tempban upgrade (already removed from tempbans in ban_user if applicable)\n+                tempbans = await self.config.guild(guild).current_tempbans()\n                 if user_id in tempbans:\n-                    tempbans.remove(user_id)\n+                    async with self.config.guild(guild).current_tempbans() as tempbans:\n+                        tempbans.remove(user_id)\n                     upgrades.append(str(user_id))\n                     log.info(\n-                        \"{}({}) upgraded the tempban for {} to a permaban.\".format(\n-                            author.name, author.id, user_id\n-                        )\n+                        f\"{author.name}({author.id}) upgraded the tempban for {user_id} to a permaban.\"\n                     )\n-                    banned.append(user_id)\n-                else:\n-                    try:\n-                        await guild.ban(user, reason=audit_reason, delete_message_days=days)\n-                        log.info(\"{}({}) hackbanned {}\".format(author.name, author.id, user_id))\n-                    except discord.NotFound:\n-                        errors[user_id] = _(\"User with ID {user_id} not found\").format(\n-                            user_id=user_id\n-                        )\n-                        continue\n-                    except discord.Forbidden:\n-                        errors[user_id] = _(\n-                            \"Could not ban user with ID {user_id}: missing permissions.\"\n-                        ).format(user_id=user_id)\n-                        continue\n-                    else:\n-                        banned.append(user_id)\n-\n-            await modlog.create_case(\n-                self.bot,\n-                guild,\n-                ctx.message.created_at.replace(tzinfo=timezone.utc),\n-                \"hackban\",\n-                user_id,\n-                author,\n-                reason,\n-                until=None,\n-                channel=None,\n-            )\n+            else:\n+                errors[user_id] = message\n         await show_results()\n \n     @commands.command()\n\n"}
{"cve": "CVE-2022-1986", "fix_patch": "--- a/internal/db/repo_editor.go\n+++ b/internal/db/repo_editor.go\n@@ -466,11 +466,13 @@\n // isRepositoryGitPath returns true if given path is or resides inside \".git\"\n // path of the repository.\n func isRepositoryGitPath(path string) bool {\n-\treturn strings.HasSuffix(path, \".git\") ||\n-\t\tstrings.Contains(path, \".git\"+string(os.PathSeparator)) ||\n-\t\t// Windows treats \".git.\" the same as \".git\"\n-\t\tstrings.HasSuffix(path, \".git.\") ||\n-\t\tstrings.Contains(path, \".git.\"+string(os.PathSeparator))\n+\tcleanPath := filepath.Clean(path)\n+\t// Absolute paths are not part of the repository\n+\tif filepath.IsAbs(cleanPath) {\n+\t\treturn false\n+\t}\n+\t// Check if path is exactly \".git\" or starts with \".git/\" (or \".git\\\" on Windows)\n+\treturn cleanPath == \".git\" || strings.HasPrefix(cleanPath, \".git\"+string(os.PathSeparator))\n }\n \n func (repo *Repository) UploadRepoFiles(doer *User, opts UploadRepoFileOptions) error {\n\n"}
{"cve": "CVE-2022-24450", "fix_patch": "--- a/server/consumer.go\n+++ b/server/consumer.go\n@@ -2884,6 +2884,11 @@\n \tmset := o.mset\n \tap := o.cfg.AckPolicy\n \n+\t// Authorization check: prevent non-system accounts from accessing system resources (CVE fix)\n+\tif o.acc != o.srv.SystemAccount() && (strings.HasPrefix(dsubj, \"$JS.SYSTEM.\") || mset.jsa.account == o.srv.SystemAccount()) {\n+\t\treturn\n+\t}\n+\n \t// Send message.\n \to.outq.send(pmsg)\n \n@@ -2914,6 +2919,10 @@\n \n func (o *consumer) needFlowControl() bool {\n \tif o.maxpb == 0 {\n+\t\treturn false\n+\t}\n+\t// System account check: prevent non-system accounts from triggering flow control on system resources\n+\tif o.acc != o.srv.SystemAccount() && (strings.HasPrefix(o.cfg.DeliverSubject, \"$JS.SYSTEM.\") || o.mset.jsa.account == o.srv.SystemAccount()) {\n \t\treturn false\n \t}\n \t// Decide whether to send a flow control message which we will need the user to respond.\n\n"}
{"cve": "CVE-2021-21411", "fix_patch": "--- a/providers/gitlab.go\n+++ b/providers/gitlab.go\n@@ -296,7 +296,7 @@\n \ts.User = userInfo.Username\n \ts.Email = userInfo.Email\n \n-\tp.addGroupsToSession(ctx, s)\n+\tp.addGroupsToSession(userInfo, s)\n \n \tp.addProjectsToSession(ctx, s)\n \n@@ -304,10 +304,10 @@\n \n }\n \n-// addGroupsToSession projects into session.Groups\n-func (p *GitLabProvider) addGroupsToSession(ctx context.Context, s *sessions.SessionState) {\n-\t// Iterate over projects, check if oauth2-proxy can get project information on behalf of the user\n-\tfor _, group := range p.Groups {\n+// addGroupsToSession adds user's actual GitLab groups to session.Groups\n+func (p *GitLabProvider) addGroupsToSession(userInfo *gitlabUserInfo, s *sessions.SessionState) {\n+\t// Add user's actual GitLab groups with group: prefix\n+\tfor _, group := range userInfo.Groups {\n \t\ts.Groups = append(s.Groups, fmt.Sprintf(\"group:%s\", group))\n \t}\n }\n\n"}
{"cve": "CVE-2018-3734", "fix_patch": "\n\n"}
{"cve": "CVE-2025-24976", "fix_patch": "--- a/registry/auth/token/token.go\n+++ b/registry/auth/token/token.go\n@@ -214,17 +214,24 @@\n \n func verifyJWK(header jose.Header, verifyOpts VerifyOptions) (signingKey crypto.PublicKey, err error) {\n \tjwk := header.JSONWebKey\n-\tsigningKey = jwk.Key\n \n \t// Check to see if the key includes a certificate chain.\n \tif len(jwk.Certificates) == 0 {\n-\t\t// The JWK should be one of the trusted root keys.\n-\t\tif _, trusted := verifyOpts.TrustedKeys[jwk.KeyID]; !trusted {\n+\t\t// The JWK should be one of the trusted root keys and match the key material\n+\t\ttrustedKey, trusted := verifyOpts.TrustedKeys[jwk.KeyID]\n+\t\tif !trusted {\n \t\t\treturn nil, errors.New(\"untrusted JWK with no certificate chain\")\n \t\t}\n-\t\t// The JWK is one of the trusted keys.\n-\t\treturn\n-\t}\n+\t\t\n+\t\t// Verify the actual key material matches the trusted key\n+\t\tif !jwk.Key.Equal(trustedKey) {\n+\t\t\treturn nil, errors.New(\"JWK key material does not match trusted key\")\n+\t\t}\n+\t\t\n+\t\treturn trustedKey, nil\n+\t}\n+\n+\tsigningKey = jwk.Key\n \n \topts := x509.VerifyOptions{\n \t\tRoots:     verifyOpts.Roots,\n\n"}
{"cve": "CVE-2024-25620", "fix_patch": "--- a/pkg/chart/metadata.go\n+++ b/pkg/chart/metadata.go\n@@ -110,6 +110,9 @@\n \tif md.Name == \"\" {\n \t\treturn ValidationError(\"chart.metadata.name is required\")\n \t}\n+\tif isPathTraversal(md.Name) {\n+\t\treturn ValidationErrorf(\"chart.metadata.name %q contains invalid path traversal characters\", md.Name)\n+\t}\n \tif md.Version == \"\" {\n \t\treturn ValidationError(\"chart.metadata.version is required\")\n \t}\n@@ -153,6 +156,12 @@\n \treturn false\n }\n \n+// isPathTraversal checks if a string contains path traversal sequences\n+func isPathTraversal(path string) bool {\n+\tpath = strings.TrimSpace(path)\n+\treturn strings.Contains(path, \"..\") || strings.Contains(path, \"/\") || strings.Contains(path, \"\\\\\")\n+}\n+\n func isValidSemver(v string) bool {\n \t_, err := semver.NewVersion(v)\n \treturn err == nil\n\n"}
{"cve": "CVE-2020-7613", "fix_patch": ""}
{"cve": "CVE-2022-0235", "fix_patch": "--- a/src/index.js\n+++ b/src/index.js\n@@ -165,6 +165,22 @@\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n \n+\t\t\t\t\t\t// Validate redirect target is same origin or in allowed list\n+\t\t\t\t\t\tconst parsedOriginalURL = new URL(request.url);\n+\t\t\t\t\t\tconst redirectHostname = locationURL.hostname;\n+\t\t\t\t\t\tconst originalHostname = parsedOriginalURL.hostname;\n+\t\t\t\t\t\t\n+\t\t\t\t\t\t// Check if redirect is to different origin and not in allowed list\n+\t\t\t\t\t\tif (redirectHostname !== originalHostname && \n+\t\t\t\t\t\t    (!request.redirectAllowedDomains || \n+\t\t\t\t\t\t     !request.redirectAllowedDomains.some(domain => \n+\t\t\t\t\t\t\t redirectHostname.endsWith(domain) || redirectHostname === domain\n+\t\t\t\t\t\t   ))) {\n+\t\t\t\t\t\t\treject(new FetchError(`Redirect to ${locationURL.href} is not allowed by redirectAllowedDomains configuration`, 'no-redirect'));\n+\t\t\t\t\t\t\tfinalize();\n+\t\t\t\t\t\t\treturn;\n+\t\t\t\t\t\t}\n+\n \t\t\t\t\t\t// HTTP-redirect fetch step 5\n \t\t\t\t\t\tif (request.counter >= request.follow) {\n \t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n\n"}
{"cve": "CVE-2022-3920", "fix_patch": "--- a/agent/structs/aclfilter/filter.go\n+++ b/agent/structs/aclfilter/filter.go\n@@ -142,7 +142,22 @@\n \t\tif f.filterGatewayServices(&v.Gateways) {\n \t\t\tv.QueryMeta.ResultsFilteredByACLs = true\n \t\t}\n-\t\tif f.filterCheckServiceNodes(&v.ImportedNodes) {\n+\n+\t\t// Filter imported nodes with both node and service level checks\n+\t\timported := v.ImportedNodes\n+\t\tvar authzContext acl.AuthorizerContext\n+\t\tvar removed bool\n+\t\tfor i := 0; i < len(imported); i++ {\n+\t\t\tnode := &imported[i]\n+\t\t\tnode.FillAuthzContext(&authzContext)\n+\t\t\tif !f.allowNode(node.Node.Node, &authzContext) || !f.allowService(node.ServiceName, &authzContext) {\n+\t\t\t\tremoved = true\n+\t\t\t\timported = append(imported[:i], imported[i+1:]...)\n+\t\t\t\ti--\n+\t\t\t}\n+\t\t}\n+\t\tv.ImportedNodes = imported\n+\t\tif removed {\n \t\t\tv.QueryMeta.ResultsFilteredByACLs = true\n \t\t}\n \n\n"}
{"cve": "CVE-2023-22736", "fix_patch": "--- a/controller/appcontroller.go\n+++ b/controller/appcontroller.go\n@@ -1773,18 +1773,19 @@\n \tif !ok {\n \t\treturn false\n \t}\n+\n+\t// Enforce namespace restrictions first (fix for authorization bypass)\n+\tif app.Namespace != ctrl.namespace && !glob.MatchStringInList(ctrl.applicationNamespaces, app.Namespace, false) {\n+\t\treturn false\n+\t}\n+\n+\t// Apply cluster filter if sharding is enabled\n \tif ctrl.clusterFilter != nil {\n \t\tcluster, err := ctrl.db.GetCluster(context.Background(), app.Spec.Destination.Server)\n \t\tif err != nil {\n \t\t\treturn ctrl.clusterFilter(nil)\n \t\t}\n \t\treturn ctrl.clusterFilter(cluster)\n-\t}\n-\n-\t// Only process given app if it exists in a watched namespace, or in the\n-\t// control plane's namespace.\n-\tif app.Namespace != ctrl.namespace && !glob.MatchStringInList(ctrl.applicationNamespaces, app.Namespace, false) {\n-\t\treturn false\n \t}\n \n \treturn true\n\n"}
{"cve": "CVE-2022-37109", "fix_patch": "--- a/server.py\n+++ b/server.py\n@@ -23,6 +23,8 @@\n ROOT = os.path.normpath(os.path.dirname(__file__))\n with open(os.path.join(ROOT, \"password.txt\")) as in_file:\n     PASSWORD = in_file.read().strip()\n+with open(os.path.join(ROOT, \"secret_key.txt\")) as in_file:\n+    COOKIE_SECRET = in_file.read().strip()\n COOKIE_NAME = \"camp\"\n \n \n@@ -126,11 +128,11 @@\n else:\n     raise Exception(\"%s not in resolution options.\" % args.resolution)\n \n+STATIC_PATH = os.path.join(ROOT, \"static\")\n handlers = [(r\"/\", IndexHandler), (r\"/login\", LoginHandler),\n             (r\"/websocket\", WebSocket),\n-            (r\"/static/password.txt\", ErrorHandler),\n-            (r'/static/(.*)', tornado.web.StaticFileHandler, {'path': ROOT})]\n-application = tornado.web.Application(handlers, cookie_secret=PASSWORD)\n+            (r'/static/(.*)', tornado.web.StaticFileHandler, {'path': STATIC_PATH})]\n+application = tornado.web.Application(handlers, cookie_secret=COOKIE_SECRET)\n application.listen(args.port)\n \n webbrowser.open(\"http://localhost:%d/\" % args.port, new=2)\n\n"}
{"cve": "CVE-2022-35949", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -53,6 +53,15 @@\n         throw new InvalidArgumentError('invalid opts.path')\n       }\n \n+      // Prevent SSRF by validating path does not alter origin\n+      const trimmedPath = opts.path.replace(/^\\s+/, '')\n+      if (trimmedPath.startsWith('http://') || trimmedPath.startsWith('https://')) {\n+        throw new InvalidArgumentError('opts.path cannot contain a protocol')\n+      }\n+      if (trimmedPath.startsWith('//')) {\n+        throw new InvalidArgumentError('opts.path cannot start with double slash')\n+      }\n+\n       url = new URL(opts.path, util.parseOrigin(url))\n     } else {\n       if (!opts) {\n\n"}
{"cve": "CVE-2022-39340", "fix_patch": "--- a/pkg/cmd/service/service.go\n+++ b/pkg/cmd/service/service.go\n@@ -359,9 +359,14 @@\n \t\treturn nil, errors.Errorf(\"failed to initialize authenticator: %v\", err)\n \t}\n \n-\tinterceptors := []grpc.UnaryServerInterceptor{\n+\t// Add authentication interceptors for both unary and streaming RPCs\n+\tunaryInterceptors := []grpc.UnaryServerInterceptor{\n \t\tgrpc_auth.UnaryServerInterceptor(middleware.AuthFunc(authenticator)),\n \t\tmiddleware.NewErrorLoggingInterceptor(logger),\n+\t}\n+\n+\tstreamInterceptors := []grpc.StreamServerInterceptor{\n+\t\tgrpc_auth.StreamServerInterceptor(middleware.AuthFunc(authenticator)),\n \t}\n \n \tgrpcHostAddr, grpcHostPort, err := net.SplitHostPort(config.GRPC.Addr)\n\n"}
{"cve": "CVE-2021-36157", "fix_patch": "--- a/pkg/tenant/resolver.go\n+++ b/pkg/tenant/resolver.go\n@@ -70,6 +70,11 @@\n \tif err != nil {\n \t\treturn nil, err\n \t}\n+\n+\tif err := ValidTenantID(orgID); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n \treturn []string{orgID}, err\n }\n \n\n"}
{"cve": "CVE-2023-33967", "fix_patch": "--- a/probe/client/mysql/mysql.go\n+++ b/probe/client/mysql/mysql.go\n@@ -108,12 +108,12 @@\n \tif len(r.Data) > 0 {\n \t\tfor k, v := range r.Data {\n \t\t\tlog.Debugf(\"[%s / %s / %s] - Verifying Data - [%s] : [%s]\", r.ProbeKind, r.ProbeName, r.ProbeTag, k, v)\n-\t\t\tsql, err := r.getSQL(k)\n+\t\t\tsql, param, err := r.getSQL(k)\n \t\t\tif err != nil {\n \t\t\t\treturn false, err.Error()\n \t\t\t}\n-\t\t\tlog.Debugf(\"[%s / %s / %s] - SQL - [%s]\", r.ProbeKind, r.ProbeName, r.ProbeTag, sql)\n-\t\t\trows, err := db.Query(sql)\n+\t\t\tlog.Debugf(\"[%s / %s / %s] - SQL - [%s] (param: %v)\", r.ProbeKind, r.ProbeName, r.ProbeTag, sql, param)\n+\t\t\trows, err := db.Query(sql, param)\n \t\t\tif err != nil {\n \t\t\t\treturn false, err.Error()\n \t\t\t}\n@@ -153,24 +153,28 @@\n // getSQL get the SQL statement\n // input: database:table:column:key:value\n // output: SELECT column FROM database.table WHERE key = value\n-func (r *MySQL) getSQL(str string) (string, error) {\n+func (r *MySQL) getSQL(str string) (string, interface{}, error) {\n \tif len(strings.TrimSpace(str)) == 0 {\n-\t\treturn \"\", fmt.Errorf(\"Empty SQL data\")\n+\t\treturn \"\", nil, fmt.Errorf(\"Empty SQL data\")\n \t}\n \tfields := strings.Split(str, \":\")\n \tif len(fields) != 5 {\n-\t\treturn \"\", fmt.Errorf(\"Invalid SQL data - [%s]. (syntax: database:table:field:key:value)\", str)\n+\t\treturn \"\", nil, fmt.Errorf(\"Invalid SQL data - [%s]. (syntax: database:table:field:key:value)\", str)\n \t}\n-\tdb := fields[0]\n-\ttable := fields[1]\n-\tfield := fields[2]\n-\tkey := fields[3]\n+\t// Quote identifiers to prevent SQL injection and escape existing backticks\n+\tdb := \"`\" + strings.ReplaceAll(fields[0], \"`\", \"``\") + \"`\"\n+\ttable := \"`\" + strings.ReplaceAll(fields[1], \"`\", \"``\") + \"`\"\n+\tfield := \"`\" + strings.ReplaceAll(fields[2], \"`\", \"``\") + \"`\"\n+\tkey := \"`\" + strings.ReplaceAll(fields[3], \"`\", \"``\") + \"`\"\n \tvalue := fields[4]\n-\t//check value is int or not\n-\tif _, err := strconv.Atoi(value); err != nil {\n-\t\treturn \"\", fmt.Errorf(\"Invalid SQL data - [%s], the value must be int\", str)\n+\n+\t// Check if value is an integer\n+\tintValue, err := strconv.Atoi(value)\n+\tif err != nil {\n+\t\treturn \"\", nil, fmt.Errorf(\"Invalid SQL data - [%s], the value must be int\", str)\n \t}\n \n-\tsql := fmt.Sprintf(\"SELECT %s FROM %s.%s WHERE %s = %s\", field, db, table, key, value)\n-\treturn sql, nil\n+\t// Use parameterized query for value to prevent SQL injection\n+\tsql := fmt.Sprintf(\"SELECT %s FROM %s.%s WHERE %s = ?\", field, db, table, key)\n+\treturn sql, intValue, nil\n }\n\n"}
{"cve": "CVE-2023-41040", "fix_patch": "--- a/git/refs/symbolic.py\n+++ b/git/refs/symbolic.py\n@@ -172,8 +172,18 @@\n             raise ValueError(f\"Invalid reference '{ref_path}'\")\n         tokens: Union[None, List[str], Tuple[str, str]] = None\n         repodir = _git_dir(repo, ref_path)\n+        # Calculate full path and verify it's within the repo directory\n+        full_path = os.path.join(repodir, str(ref_path))\n+        # Resolve real paths to handle symlinks correctly\n+        real_repodir = os.path.realpath(repodir)\n+        real_full_path = os.path.realpath(full_path)\n+        \n+        # Verify the path doesn't escape the repository directory\n+        if not real_full_path.startswith(real_repodir + os.path.sep):\n+            raise ValueError(f\"Path '{ref_path}' escapes repository directory\")\n+            \n         try:\n-            with open(os.path.join(repodir, str(ref_path)), \"rt\", encoding=\"UTF-8\") as fp:\n+            with open(full_path, \"rt\", encoding=\"UTF-8\") as fp:\n                 value = fp.read().rstrip()\n             # Don't only split on spaces, but on whitespace, which allows to parse lines like\n             # 60b64ef992065e2600bfef6187a97f92398a9144                branch 'master' of git-server:/path/to/repo\n\n"}
{"cve": "CVE-2021-32701", "fix_patch": "--- a/pipeline/authn/authenticator_oauth2_introspection.go\n+++ b/pipeline/authn/authenticator_oauth2_introspection.go\n@@ -200,34 +200,40 @@\n \t\t\treturn errors.WithStack(err)\n \t\t}\n \n-\t\tif len(i.TokenUse) > 0 && i.TokenUse != \"access_token\" {\n-\t\t\treturn errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf(\"Use of introspected token is not an access token but \\\"%s\\\"\", i.TokenUse)))\n-\t\t}\n-\n-\t\tif !i.Active {\n-\t\t\treturn errors.WithStack(helper.ErrUnauthorized.WithReason(\"Access token i says token is not active\"))\n-\t\t}\n-\n-\t\tfor _, audience := range cf.Audience {\n-\t\t\tif !stringslice.Has(i.Audience, audience) {\n-\t\t\t\treturn errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf(\"Token audience is not intended for target audience %s\", audience)))\n+\t\ta.tokenToCache(cf, i, token)\n+\t}\n+\n+\t// Validate token even when retrieved from cache\n+\tif len(i.TokenUse) > 0 && i.TokenUse != \"access_token\" {\n+\t\treturn errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf(\"Use of introspected token is not an access token but \\\"%s\\\"\", i.TokenUse)))\n+\t}\n+\n+\tif !i.Active {\n+\t\treturn errors.WithStack(helper.ErrUnauthorized.WithReason(\"Access token i says token is not active\"))\n+\t}\n+\n+\tfor _, audience := range cf.Audience {\n+\t\tif !stringslice.Has(i.Audience, audience) {\n+\t\t\treturn errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf(\"Token audience is not intended for target audience %s\", audience)))\n+\t\t}\n+\t}\n+\n+\tif len(cf.Issuers) > 0 {\n+\t\tif !stringslice.Has(cf.Issuers, i.Issuer) {\n+\t\t\treturn errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf(\"Token issuer does not match any trusted issuer\")))\n+\t\t}\n+\t}\n+\n+\tif ss != nil {\n+\t\tfor _, scope := range cf.Scopes {\n+\t\t\tif !ss(strings.Split(i.Scope, \" \"), scope) {\n+\t\t\t\treturn errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf(\"Scope %s was not granted\", scope)))\n \t\t\t}\n \t\t}\n-\n-\t\tif len(cf.Issuers) > 0 {\n-\t\t\tif !stringslice.Has(cf.Issuers, i.Issuer) {\n-\t\t\t\treturn errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf(\"Token issuer does not match any trusted issuer\")))\n-\t\t\t}\n-\t\t}\n-\n-\t\tif ss != nil {\n-\t\t\tfor _, scope := range cf.Scopes {\n-\t\t\t\tif !ss(strings.Split(i.Scope, \" \"), scope) {\n-\t\t\t\t\treturn errors.WithStack(helper.ErrForbidden.WithReason(fmt.Sprintf(\"Scope %s was not granted\", scope)))\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n+\t}\n+\n+\t// Set extra fields only when fresh from introspection\n+\tif !ok {\n \t\tif len(i.Extra) == 0 {\n \t\t\ti.Extra = map[string]interface{}{}\n \t\t}\n@@ -239,8 +245,6 @@\n \t\tif len(i.Audience) != 0 {\n \t\t\ti.Extra[\"aud\"] = i.Audience\n \t\t}\n-\n-\t\ta.tokenToCache(cf, i, token)\n \t}\n \n \tsession.Subject = i.Subject\n\n"}
{"cve": "CVE-2022-39286", "fix_patch": "--- a/jupyter_core/application.py\n+++ b/jupyter_core/application.py\n@@ -89,7 +89,6 @@\n         path = jupyter_config_path()\n         if self.config_dir not in path:\n             path.insert(0, self.config_dir)\n-        path.insert(0, os.getcwd())\n         return path\n \n     data_dir = Unicode()\n\n"}
{"cve": "CVE-2022-2900", "fix_patch": "--- a/lib/index.js\n+++ b/lib/index.js\n@@ -68,6 +68,26 @@\n         }\n     }\n \n+    // SSRF Protection: Block forbidden hosts\n+    const forbiddenHostPatterns = [\n+        /^10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/,          // 10.x.x.x/8 private network\n+        /^172\\.(1[6-9]|2\\d|3[0-1])\\.\\d{1,3}\\.\\d{1,3}$/, // 172.16-31.x.x/12 private network\n+        /^192\\.168\\.\\d{1,3}\\.\\d{1,3}$/,              // 192.168.x.x/16 private network\n+        /^127\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/,          // 127.x.x.x/8 loopback\n+        /^localhost$/i,                               // localhost (case-insensitive)\n+        /^\\[\\:\\:1\\]$/                                 // IPv6 loopback (::1)\n+    ];\n+\n+    const resource = parsed.resource || '';\n+    const isForbidden = forbiddenHostPatterns.some(pattern => pattern.test(resource));\n+\n+    if (isForbidden) {\n+        const err = new Error(\"Forbidden host address to prevent SSRF.\");\n+        err.subject_url = url;\n+        err.forbidden_host = resource;\n+        throw err;\n+    }\n+\n     return parsed;\n }\n \n\n"}
{"cve": "CVE-2022-46146", "fix_patch": "--- a/web/handler.go\n+++ b/web/handler.go\n@@ -113,11 +113,11 @@\n \t\t\thashedPassword = \"$2y$10$QOauhQNbBCuQDKes6eFzPeMqBSjb7Mr5DUmpZ/VcEd00UAV/LDeSi\"\n \t\t}\n \n-\t\tcacheKey := hex.EncodeToString(append(append([]byte(user), []byte(hashedPassword)...), []byte(pass)...))\n+\t\tcacheKey := hex.EncodeToString(append([]byte(user), []byte(pass)...))\n \t\tauthOk, ok := u.cache.get(cacheKey)\n \n \t\tif !ok {\n-\t\t\t// This user, hashedPassword, password is not cached.\n+\t\t\t// This user, password is not cached.\n \t\t\tu.bcryptMtx.Lock()\n \t\t\terr := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(pass))\n \t\t\tu.bcryptMtx.Unlock()\n\n"}
{"cve": "CVE-2021-21354", "fix_patch": "--- a/pollbot/middlewares.py\n+++ b/pollbot/middlewares.py\n@@ -60,8 +60,9 @@\n \n async def handle_404(request, response):\n     if 'json' not in response.headers['Content-Type']:\n-        if request.path.endswith('/'):\n-            return web.HTTPFound(request.path.rstrip('/'))\n+        stripped_path = request.path.rstrip('/')\n+        if request.path.endswith('/') and not stripped_path.startswith('//'):\n+            return web.HTTPFound(stripped_path)\n         return web.json_response({\n             \"status\": 404,\n             \"message\": \"Page '{}' not found\".format(request.path)\n\n"}
{"cve": "CVE-2022-0512", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -33,10 +33,10 @@\n var rules = [\n   ['#', 'hash'],                        // Extract from the back.\n   ['?', 'query'],                       // Extract from the back.\n+  ['/', 'pathname'],                    // Extract from the back.\n   function sanitize(address, url) {     // Sanitize what is left of the address\n     return isSpecial(url.protocol) ? address.replace(/\\\\/g, '/') : address;\n   },\n-  ['/', 'pathname'],                    // Extract from the back.\n   ['@', 'auth', 1],                     // Extract from the front.\n   [NaN, 'host', undefined, 1, 1],       // Set left over value.\n   [/:(\\d+)$/, 'port', undefined, 1],    // RegExp the back.\n\n"}
{"cve": "CVE-2019-15597", "fix_patch": "--- a/lib/index.js\n+++ b/lib/index.js\n@@ -1,4 +1,4 @@\n-var exec = require('child_process').exec\n+var execFile = require('child_process').execFile\n var parse = require('./parse')\n \n module.exports = function df(aOptions, aCallback) {\n@@ -33,12 +33,12 @@\n \n     // TODO: should fail if unit is not a string\n \n-    var command = 'df -kP'\n+    var cmd = ['df', '-kP'];\n     if (options.file) {\n-        command += ' ' + options.file\n+        cmd.push(options.file);\n     }\n \n-    exec(command, function(err, stdout, stderr) {\n+    execFile(cmd[0], cmd.slice(1), function(err, stdout, stderr) {\n         if (err) {\n             callback(err)\n             return\n\n"}
{"cve": "CVE-2021-41803", "fix_patch": "--- a/agent/consul/auto_config_endpoint.go\n+++ b/agent/consul/auto_config_endpoint.go\n@@ -59,6 +59,21 @@\n \tif err != nil {\n \t\t// TODO (autoconf) maybe we should add a more generic permission denied error not tied to the ACL package?\n \t\treturn AutoConfigOptions{}, acl.PermissionDenied(\"Failed JWT authorization: %v\", err)\n+\t}\n+\n+\t// Validate node name exists and matches JWT claims\n+\tif req.Node == \"\" {\n+\t\treturn AutoConfigOptions{}, acl.PermissionDenied(\"node name is required\")\n+\t}\n+\tif nodeClaim, ok := identity.SelectableFields[\"node\"].(string); !ok || nodeClaim != req.Node {\n+\t\treturn AutoConfigOptions{}, acl.PermissionDenied(\"node name does not match JWT authorization\")\n+\t}\n+\n+\t// Validate segment name if provided and matches JWT claims\n+\tif req.Segment != \"\" {\n+\t\tif segmentClaim, ok := identity.SelectableFields[\"segment\"].(string); !ok || segmentClaim != req.Segment {\n+\t\t\treturn AutoConfigOptions{}, acl.PermissionDenied(\"segment name does not match JWT authorization\")\n+\t\t}\n \t}\n \n \tvarMap := map[string]string{\n\n"}
{"cve": "CVE-2024-39330", "fix_patch": "--- a/django/core/files/storage/base.py\n+++ b/django/core/files/storage/base.py\n@@ -34,6 +34,8 @@\n         if not hasattr(content, \"chunks\"):\n             content = File(content, name)\n \n+        # Validate filename before availability check (critical for path traversal protection)\n+        name = self.generate_filename(name)\n         name = self.get_available_name(name, max_length=max_length)\n         name = self._save(name, content)\n         # Ensure that the name returned from the storage system is still valid.\n\n--- a/django/core/files/utils.py\n+++ b/django/core/files/utils.py\n@@ -9,14 +9,20 @@\n     if os.path.basename(name) in {\"\", \".\", \"..\"}:\n         raise SuspiciousFileOperation(\"Could not derive file name from '%s'\" % name)\n \n+    # Always check for path traversal in relative paths (even when not explicitly allowed)\n+    path = pathlib.PurePosixPath(name)\n+    if \"..\" in path.parts:\n+        raise SuspiciousFileOperation(\n+            \"Detected path traversal attempt in '%s'\" % name\n+        )\n+\n     if allow_relative_path:\n         # Use PurePosixPath() because this branch is checked only in\n         # FileField.generate_filename() where all file paths are expected to be\n         # Unix style (with forward slashes).\n-        path = pathlib.PurePosixPath(name)\n-        if path.is_absolute() or \"..\" in path.parts:\n+        if path.is_absolute():\n             raise SuspiciousFileOperation(\n-                \"Detected path traversal attempt in '%s'\" % name\n+                \"Detected absolute path attempt in '%s'\" % name\n             )\n     elif name != os.path.basename(name):\n         raise SuspiciousFileOperation(\"File name '%s' includes path elements\" % name)\n\n"}
{"cve": "CVE-2018-18074", "fix_patch": "--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -242,7 +242,7 @@\n             original_parsed = urlparse(response.request.url)\n             redirect_parsed = urlparse(url)\n \n-            if (original_parsed.hostname != redirect_parsed.hostname):\n+            if (original_parsed.hostname != redirect_parsed.hostname) or (original_parsed.scheme == 'https' and redirect_parsed.scheme == 'http'):\n                 del headers['Authorization']\n \n         # .netrc might have more auth for us on our new host.\n\n"}
{"cve": "CVE-2021-23376", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -215,6 +215,12 @@\n   },\n   trimvideo: (input, start, duration, output) => {\n     return new Promise(function(resolve, reject) {\n+      // Validate input parameters to prevent command injection\n+      const timeRegex = /^(\\d+(:\\d+){0,2})|\\d+$/; // Matches HH:MM:SS or just seconds\n+      if (!timeRegex.test(start) || !timeRegex.test(duration)) {\n+        return reject(new Error(\"Invalid time format. Use HH:MM:SS or seconds.\"));\n+      }\n+      \n       if (fs.existsSync(input)) {\n         exec(\n           `ffmpeg -hide_banner -loglevel quiet -ss ${start} -i ${input} -t ${duration} -c copy -y ${output}.mp4`,\n\n"}
{"cve": "CVE-2022-36009", "fix_patch": "\n\n"}
{"cve": "CVE-2017-16025", "fix_patch": "--- a/lib/socket.js\n+++ b/lib/socket.js\n@@ -539,7 +539,11 @@\n \n     this._listener._connection.states.parse(cookies, (ignoreErr, state, failed) => {\n \n-        const auth = state[config.cookie];\n+        if (ignoreErr) {\n+            return;\n+        }\n+\n+        const auth = state && state[config.cookie];\n         if (auth) {\n             this.auth._error = this._setCredentials(auth.credentials, auth.artifacts);\n         }\n\n"}
{"cve": "CVE-2023-50726", "fix_patch": "\n\n"}
{"cve": "CVE-2021-41125", "fix_patch": "--- a/scrapy/downloadermiddlewares/httpauth.py\n+++ b/scrapy/downloadermiddlewares/httpauth.py\n@@ -5,6 +5,7 @@\n \"\"\"\n \n from w3lib.http import basic_auth_header\n+from urllib.parse import urlparse\n \n from scrapy import signals\n \n@@ -22,10 +23,30 @@\n     def spider_opened(self, spider):\n         usr = getattr(spider, 'http_user', '')\n         pwd = getattr(spider, 'http_pass', '')\n+        auth_domain = getattr(spider, 'http_auth_domain', '')\n         if usr or pwd:\n             self.auth = basic_auth_header(usr, pwd)\n+            # Parse allowed domains (supports string or list of domains)\n+            if isinstance(auth_domain, str):\n+                self.allowed_domains = {d.strip().lower() for d in auth_domain.split(',') if d.strip()}\n+            else:\n+                self.allowed_domains = {d.strip().lower() for d in auth_domain if isinstance(d, str) and d.strip()}\n+        else:\n+            self.allowed_domains = set()\n \n     def process_request(self, request, spider):\n         auth = getattr(self, 'auth', None)\n-        if auth and b'Authorization' not in request.headers:\n+        allowed_domains = getattr(self, 'allowed_domains', set())\n+        \n+        if not auth or not allowed_domains:\n+            return\n+            \n+        # Get domain from request URL (ignore port)\n+        parsed_url = urlparse(request.url)\n+        domain = parsed_url.hostname.lower() if parsed_url.hostname else ''\n+        \n+        if domain not in allowed_domains:\n+            return\n+            \n+        if b'Authorization' not in request.headers:\n             request.headers[b'Authorization'] = auth\n\n"}
{"cve": "CVE-2017-16042", "fix_patch": "--- a/lib/growl.js\n+++ b/lib/growl.js\n@@ -200,7 +200,7 @@\n         if (!options.sticky) args.push('--hint=int:transient:1');\n         break;\n       case 'Windows':\n-        args.push(cmd.icon + quote(image));\n+        args.push(cmd.icon, quote(image));\n         break;\n     }\n   }\n@@ -211,20 +211,19 @@\n   // priority\n   if (options.priority) {\n     var priority = options.priority + '';\n-    var checkindexOf = cmd.priority.range.indexOf(priority);\n     if (~cmd.priority.range.indexOf(priority)) {\n-      args.push(cmd.priority, options.priority);\n-    }\n-  }\n-\n-  //sound\n+      args.push(cmd.priority, quote(priority));\n+    }\n+  }\n+\n+  // sound\n   if(options.sound && cmd.type === 'Darwin-NotificationCenter'){\n-    args.push(cmd.sound, options.sound)\n+    args.push(cmd.sound, quote(options.sound))\n   }\n \n   // name\n   if (options.name && cmd.type === \"Darwin-Growl\") {\n-    args.push('--name', options.name);\n+    args.push('--name', quote(options.name));\n   }\n \n   switch(cmd.type) {\n@@ -256,7 +255,7 @@\n       args.push(quote(msg).replace(/\\\\n/g, '\\n'));\n       if (options.title) args.push(quote(options.title));\n       if (cmd.host) {\n-        args.push(cmd.host.cmd, cmd.host.hostname)\n+        args.push(cmd.host.cmd, quote(cmd.host.hostname))\n       }\n       break;\n     case 'Linux':\n@@ -270,21 +269,15 @@\n       break;\n     case 'Windows':\n       args.push(quote(msg).replace(/\\\\n/g, '\\n'));\n-      if (options.title) args.push(cmd.title + quote(options.title));\n-      if (options.url) args.push(cmd.url + quote(options.url));\n+      if (options.title) args.push(cmd.title, quote(options.title));\n+      if (options.url) args.push(cmd.url, quote(options.url));\n       break;\n     case 'Custom':\n-      args[0] = (function(origCommand) {\n-        var message = options.title\n-          ? options.title + ': ' + msg\n-          : msg;\n-        var command = origCommand.replace(/(^|[^%])%s/g, '$1' + quote(message));\n-        if (command === origCommand) args.push(quote(message));\n-        return command;\n-      })(args[0]);\n+      var message = options.title ? options.title + ': ' + msg : msg;\n+      args = [options.exec, quote(message)];\n       break;\n   }\n \n   // execute\n-  exec(args.join(' '), fn);\n+  exec(args, fn);\n };\n\n"}
{"cve": "CVE-2023-39660", "fix_patch": "--- a/pandasai/__init__.py\n+++ b/pandasai/__init__.py\n@@ -596,10 +596,15 @@\n         Returns (str): Returns a Clean Code String\n \n         \"\"\"\n-\n         tree = ast.parse(code)\n-\n         new_body = []\n+        \n+        # Define dangerous functions to block\n+        dangerous_builtins = {\"exec\", \"eval\", \"compile\", \"__import__\"}\n+        dangerous_module_calls = {\n+            \"os\": {\"system\", \"popen\", \"fork\", \"execv\"},\n+            \"subprocess\": {\"run\", \"call\", \"check_output\", \"Popen\"},\n+        }\n \n         # clear recent optional dependencies\n         self._additional_dependencies = []\n@@ -610,6 +615,29 @@\n                 continue\n             if self._is_df_overwrite(node):\n                 continue\n+\n+            # Check for dangerous function calls in this node\n+            has_dangerous_call = False\n+            for child in ast.walk(node):\n+                if isinstance(child, ast.Call):\n+                    # Check for direct built-in function calls (e.g. exec(...))\n+                    if isinstance(child.func, ast.Name):\n+                        if child.func.id in dangerous_builtins:\n+                            has_dangerous_call = True\n+                            break\n+                    # Check for module attribute calls (e.g. os.system(...))\n+                    elif isinstance(child.func, ast.Attribute):\n+                        if (\n+                            isinstance(child.func.value, ast.Name)\n+                            and child.func.value.id in dangerous_module_calls\n+                            and child.func.attr in dangerous_module_calls[child.func.value.id]\n+                        ):\n+                            has_dangerous_call = True\n+                            break\n+\n+            if has_dangerous_call:\n+                raise BadImportError(\"Dangerous function call detected\")\n+\n             new_body.append(node)\n \n         new_tree = ast.Module(body=new_body)\n\n"}
{"cve": "CVE-2022-29188", "fix_patch": "--- a/pkg/smokescreen/smokescreen.go\n+++ b/pkg/smokescreen/smokescreen.go\n@@ -869,7 +869,7 @@\n \tdecision.role = role\n \n \tsubmatch := hostExtractRE.FindStringSubmatch(outboundHost)\n-\tdestination := submatch[1]\n+\tdestination := strings.Trim(submatch[1], \"[]\")\n \n \taclDecision, err := config.EgressACL.Decide(role, destination)\n \tdecision.project = aclDecision.Project\n\n"}
{"cve": "CVE-2021-21360", "fix_patch": "--- a/src/Products/GenericSetup/context.py\n+++ b/src/Products/GenericSetup/context.py\n@@ -558,7 +558,10 @@\n \n             if element not in current.objectIds():\n                 # No Unicode IDs!\n-                current._setObject(str(element), Folder(element))\n+                folder = Folder(element)\n+                # Restrict access to Manager role only\n+                folder.manage_permission('View', roles=['Manager'], acquire=False)\n+                current._setObject(str(element), folder)\n \n             current = current._getOb(element)\n \n\n"}
{"cve": "CVE-2024-5823", "fix_patch": "--- a/modules/utils.py\n+++ b/modules/utils.py\n@@ -421,6 +421,8 @@\n         filename = filename[:-3]\n     if not filename.endswith(\".json\") and not filename.endswith(\".md\"):\n         filename += \".json\"\n+    # Sanitize filename to prevent path traversal attacks\n+    filename = os.path.basename(filename)\n     if filename == \".json\":\n         raise Exception(\"\u6587\u4ef6\u540d\u4e0d\u80fd\u4e3a\u7a7a\")\n \n@@ -443,14 +445,19 @@\n         \"stream\": model.stream,\n         \"metadata\": model.metadata,\n     }\n-    if not filename == os.path.basename(filename):\n-        history_file_path = filename\n-    else:\n-        history_file_path = os.path.join(HISTORY_DIR, user_name, filename)\n-\n-    # check if history file path matches user_name\n-    # if user access control is not enabled, user_name is empty, don't check\n+    # Construct path safely within user's history directory\n+    base_dir = os.path.join(HISTORY_DIR, user_name)\n+    history_file_path = os.path.join(base_dir, filename)\n+\n+    # Verify path is within allowed directory boundaries\n+    real_base = os.path.realpath(base_dir)\n+    real_history = os.path.realpath(history_file_path)\n+    if not os.path.commonpath([real_base, real_history]) == real_base:\n+        raise ValueError(\"Invalid filename - path traversal detected\")\n+\n+    # check if history file path matches user_name (now redundant but maintained for safety)\n     assert os.path.basename(os.path.dirname(history_file_path)) == model.user_name or model.user_name == \"\"\n+    \n     with open(history_file_path, \"w\", encoding=\"utf-8\") as f:\n         json.dump(json_s, f, ensure_ascii=False, indent=4)\n \n\n"}
{"cve": "CVE-2015-8213", "fix_patch": "--- a/django/utils/formats.py\n+++ b/django/utils/formats.py\n@@ -27,6 +27,12 @@\n         '%Y-%m-%d %H:%M',\n         '%Y-%m-%d'\n     ],\n+}\n+\n+VALID_FORMATS = {\n+    'DATE_FORMAT', 'TIME_FORMAT', 'DATETIME_FORMAT',\n+    'DATE_INPUT_FORMATS', 'TIME_INPUT_FORMATS', 'DATETIME_INPUT_FORMATS',\n+    'DECIMAL_SEPARATOR', 'THOUSAND_SEPARATOR', 'NUMBER_GROUPING',\n }\n \n \n@@ -102,6 +108,8 @@\n                 return cached\n             else:\n                 # Return the general setting by default\n+                if format_type not in VALID_FORMATS:\n+                    raise ValueError(\"Invalid format type: %r\" % format_type)\n                 return getattr(settings, format_type)\n         except KeyError:\n             for module in get_format_modules(lang):\n@@ -117,6 +125,8 @@\n                 except AttributeError:\n                     pass\n             _format_cache[cache_key] = None\n+    if format_type not in VALID_FORMATS:\n+        raise ValueError(\"Invalid format type: %r\" % format_type)\n     return getattr(settings, format_type)\n \n get_format_lazy = lazy(get_format, six.text_type, list, tuple)\n\n"}
{"cve": "CVE-2020-28494", "fix_patch": "--- a/image.js\n+++ b/image.js\n@@ -287,8 +287,13 @@\n \t!self.builder.length && self.minify();\n \t!type && (type = self.outputType);\n \n+\t// Sanitize type to prevent command injection (only allow letters)\n+\tif (type && !/^[a-zA-Z]+$/.test(type)) {\n+\t\tthrow new Error('Invalid image type: ' + type);\n+\t}\n+\n \tF.stats.performance.open++;\n-\tvar cmd = spawn(CMD_CONVERT[self.cmdarg], self.arg(self.filename ? wrap(self.filename) : '-', (type ? type + ':' : '') + '-'), SPAWN_OPT);\n+\tvar cmd = spawn(CMD_CONVERT[self.cmdarg], self.arg(self.filename ? wrap(self.filename) : '-', (type ? type + ':' : '') + '-'), { shell: false });\n \tcmd.stderr.on('data', stream.emit.bind(stream, 'error'));\n \tcmd.stdout.on('data', stream.emit.bind(stream, 'data'));\n \tcmd.stdout.on('end', stream.emit.bind(stream, 'end'));\n@@ -325,8 +330,13 @@\n \tif (!type)\n \t\ttype = self.outputType;\n \n+\t// Sanitize type to prevent command injection (only allow letters)\n+\tif (type && !/^[a-zA-Z]+$/.test(type)) {\n+\t\tthrow new Error('Invalid image type: ' + type);\n+\t}\n+\n \tF.stats.performance.open++;\n-\tvar cmd = spawn(CMD_CONVERT[self.cmdarg], self.arg(self.filename ? wrap(self.filename) : '-', (type ? type + ':' : '') + '-'), SPAWN_OPT);\n+\tvar cmd = spawn(CMD_CONVERT[self.cmdarg], self.arg(self.filename ? wrap(self.filename) : '-', (type ? type + ':' : '') + '-'), { shell: false });\n \tif (self.currentStream) {\n \t\tif (self.currentStream instanceof Buffer)\n \t\t\tcmd.stdin.end(self.currentStream);\n\n"}
{"cve": "CVE-2022-4643", "fix_patch": "--- a/pdf_ocr.go\n+++ b/pdf_ocr.go\n@@ -3,6 +3,7 @@\n package docconv\n \n import (\n+\t\"bytes\"\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n@@ -110,13 +111,63 @@\n \n // PdfHasImage verify if `path` (PDF) has images\n func PDFHasImage(path string) bool {\n-\tcmd := \"pdffonts -l 5 %s | tail -n +3 | cut -d' ' -f1 | sort | uniq\"\n-\tout, err := exec.Command(\"bash\", \"-c\", fmt.Sprintf(cmd, path)).Output()\n-\tif err != nil {\n-\t\tlog.Println(err)\n-\t\treturn false\n-\t}\n-\tif string(out) == \"\" {\n+\tvar out bytes.Buffer\n+\n+\t// Create pipeline: pdffonts \u2192 tail \u2192 cut \u2192 sort \u2192 uniq (no shell involved)\n+\tpdfCmd := exec.Command(\"pdffonts\", \"-l\", \"5\", path)\n+\tstdout, err := pdfCmd.StdoutPipe()\n+\tif err != nil {\n+\t\tlog.Println(err)\n+\t\treturn false\n+\t}\n+\n+\ttailCmd := exec.Command(\"tail\", \"-n\", \"+3\")\n+\ttailCmd.Stdin = stdout\n+\tstdout, err = tailCmd.StdoutPipe()\n+\tif err != nil {\n+\t\tlog.Println(err)\n+\t\treturn false\n+\t}\n+\n+\tcutCmd := exec.Command(\"cut\", \"-d\", \" \", \"-f1\")\n+\tcutCmd.Stdin = stdout\n+\tstdout, err = cutCmd.StdoutPipe()\n+\tif err != nil {\n+\t\tlog.Println(err)\n+\t\treturn false\n+\t}\n+\n+\tsortCmd := exec.Command(\"sort\")\n+\tsortCmd.Stdin = stdout\n+\tstdout, err = sortCmd.StdoutPipe()\n+\tif err != nil {\n+\t\tlog.Println(err)\n+\t\treturn false\n+\t}\n+\n+\tuniqCmd := exec.Command(\"uniq\")\n+\tuniqCmd.Stdin = stdout\n+\tuniqCmd.Stdout = &out\n+\n+\t// Start all pipeline commands\n+\tcmds := []*exec.Cmd{pdfCmd, tailCmd, cutCmd, sortCmd, uniqCmd}\n+\tfor _, cmd := range cmds {\n+\t\tif err := cmd.Start(); err != nil {\n+\t\t\tlog.Println(err)\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\n+\t// Wait for all commands to complete with error checking\n+\tfor _, cmd := range cmds {\n+\t\tif err := cmd.Wait(); err != nil {\n+\t\t\tlog.Println(err)\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\n+\t// Preserve original logic: empty output \u2192 return true\n+\tif string(out.Bytes()) == \"\" {\n \t\treturn true\n \t}\n \treturn false\n\n"}
{"cve": "CVE-2021-39163", "fix_patch": "--- a/synapse/groups/groups_server.py\n+++ b/synapse/groups/groups_server.py\n@@ -331,6 +331,9 @@\n         is_user_in_group = await self.store.is_user_in_group(\n             requester_user_id, group_id\n         )\n+\n+        if not is_user_in_group:\n+            raise SynapseError(403, \"User not in group\")\n \n         room_results = await self.store.get_rooms_in_group(\n             group_id, include_private=is_user_in_group\n\n"}
{"cve": "CVE-2021-35042", "fix_patch": "--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1898,14 +1898,10 @@\n         for item in ordering:\n             if isinstance(item, str):\n                 if '.' in item:\n-                    warnings.warn(\n-                        'Passing column raw column aliases to order_by() is '\n-                        'deprecated. Wrap %r in a RawSQL expression before '\n-                        'passing it to order_by().' % item,\n-                        category=RemovedInDjango40Warning,\n-                        stacklevel=3,\n+                    raise FieldError(\n+                        'Raw column aliases are not permitted in order_by(). '\n+                        'Use RawSQL(%r) instead.' % item\n                     )\n-                    continue\n                 if item == '?':\n                     continue\n                 if item.startswith('-'):\n\n"}
{"cve": "CVE-2023-22480", "fix_patch": "--- a/pkg/router/v1/v1api.go\n+++ b/pkg/router/v1/v1api.go\n@@ -19,19 +19,22 @@\n \n func V1(parent iris.Party) {\n \tv1 := parent.Party(\"/v1\")\n-\tauthParty := v1.Party(\"/auth\")\n-\tmvc.New(authParty.Party(\"/session\")).HandleError(ErrorHandler).Handle(controller.NewSessionController())\n-\tmvc.New(v1.Party(\"/user\")).HandleError(ErrorHandler).Handle(controller.NewForgotPasswordController())\n+\t\n+\t// Create AuthScope first with all security middleware\n \tAuthScope = v1.Party(\"/\")\n \tAuthScope.Use(middleware.JWTMiddleware().Serve)\n \tAuthScope.Use(middleware.UserMiddleware)\n \tAuthScope.Use(middleware.RBACMiddleware())\n \tAuthScope.Use(middleware.PagerMiddleware)\n \tAuthScope.Use(middleware.ForceMiddleware)\n+\t\n+\t// Register all protected routes under AuthScope\n+\tmvc.New(AuthScope.Party(\"/auth/session\")).HandleError(ErrorHandler).Handle(controller.NewSessionController())\n+\tmvc.New(AuthScope.Party(\"/user\")).HandleError(ErrorHandler).Handle(controller.NewForgotPasswordController())\n+\tmvc.New(AuthScope.Party(\"/users\")).HandleError(ErrorHandler).Handle(controller.NewUserController())\n \tmvc.New(AuthScope.Party(\"/clusters\")).HandleError(ErrorHandler).Handle(controller.NewClusterController())\n \tmvc.New(AuthScope.Party(\"/credentials\")).HandleError(ErrorHandler).Handle(controller.NewCredentialController())\n \tmvc.New(AuthScope.Party(\"/hosts\")).HandleError(ErrorHandler).Handle(controller.NewHostController())\n-\tmvc.New(AuthScope.Party(\"/users\")).HandleError(ErrorHandler).Handle(controller.NewUserController())\n \tmvc.New(AuthScope.Party(\"/dashboard\")).HandleError(ErrorHandler).Handle(controller.NewKubePiController())\n \tmvc.New(AuthScope.Party(\"/regions\")).HandleError(ErrorHandler).Handle(controller.NewRegionController())\n \tmvc.New(AuthScope.Party(\"/zones\")).HandleError(ErrorHandler).Handle(controller.NewZoneController())\n@@ -48,7 +51,7 @@\n \tmvc.New(AuthScope.Party(\"/clusters/monitor\")).HandleError(ErrorHandler).Handle(controller.NewMonitorController())\n \tmvc.New(AuthScope.Party(\"/tasks\")).Handle(ErrorHandler).Handle(controller.NewTaskLogController())\n \tmvc.New(AuthScope.Party(\"/components\")).Handle(ErrorHandler).Handle(controller.NewComponentController())\n-\tmvc.New(AuthScope.Party(\"/license\")).Handle(ErrorHandler).Handle(controller.NewLicenseController())\n+\tmvc.New(AuthScope.Party(\"/license\")).HandleError(ErrorHandler).Handle(controller.NewLicenseController())\n \tmvc.New(AuthScope.Party(\"/clusters/backup/files\")).HandleError(ErrorHandler).Handle(controller.NewClusterBackupFileController())\n \tmvc.New(AuthScope.Party(\"/clusters/velero/{cluster}/{operate}\")).HandleError(ErrorHandler).Handle(controller.NewClusterVeleroBackupController())\n \tmvc.New(AuthScope.Party(\"/manifests\")).HandleError(ErrorHandler).Handle(controller.NewManifestController())\n@@ -66,11 +69,12 @@\n \tmvc.New(AuthScope.Party(\"/msg/subscribes\")).HandleError(ErrorHandler).Handle(controller.NewMessageSubscribeController())\n \tmvc.New(AuthScope.Party(\"/user/messages\")).HandleError(ErrorHandler).Handle(controller.NewUserMsgController())\n \tmvc.New(AuthScope.Party(\"/user/settings\")).HandleError(ErrorHandler).Handle(controller.NewUserSettingController())\n+\n+\t// Create WhiteScope for truly public endpoints only\n \tWhiteScope = v1.Party(\"/\")\n \tWhiteScope.Get(\"/clusters/kubeconfig/{name}\", downloadKubeconfig)\n \tWhiteScope.Get(\"/captcha\", generateCaptcha)\n \tmvc.New(WhiteScope.Party(\"/theme\")).HandleError(ErrorHandler).Handle(controller.NewThemeController())\n-\n }\n \n func ErrorHandler(ctx context.Context, err error) {\n\n"}
{"cve": "CVE-2019-7539", "fix_patch": "--- a/ipycache.py\n+++ b/ipycache.py\n@@ -120,25 +120,27 @@\n             cache={}\n             #raise IOError(str(e))\n         \n+        # Create a clean result dict with only requested variables\n+        result = {}\n+        \n         # Check that all requested variables could be loaded successfully\n-        # from the cache.\n         missing_vars = sorted(set(vars) - set(cache.keys()))\n         if missing_vars:\n             raise ValueError((\"The following variables could not be loaded \"\n                 \"from the cache: {0:s}\").format(\n                 ', '.join([\"'{0:s}'\".format(var) for var in missing_vars])))\n-        additional_vars = sorted(set(cache.keys()) - set(vars))\n-        for hidden_variable in '_captured_io', '_cell_md5':\n-            try:\n-                additional_vars.remove(hidden_variable)\n-            except ValueError:\n-                pass\n-        if additional_vars:\n-            raise ValueError(\"The following variables were present in the cache, \"\n-                    \"but removed from the storage request: {0:s}\".format(\n-                ', '.join([\"'{0:s}'\".format(var) for var in additional_vars])))\n-        \n-        return cache\n+        \n+        # Only keep explicitly requested variables to prevent code injection\n+        # through unexpected/untrusted variables in the cache\n+        for var in vars:\n+            result[var] = cache[var]\n+            \n+        # Preserve internal variables but keep them separate from user variables\n+        for hidden_var in ['_captured_io', '_cell_md5']:\n+            if hidden_var in cache:\n+                result[hidden_var] = cache[hidden_var]\n+        \n+        return result\n \n def save_vars(path, vars_d):\n     \"\"\"Save variables into a pickle file.\n\n"}
{"cve": "CVE-2020-26215", "fix_patch": "--- a/notebook/base/handlers.py\n+++ b/notebook/base/handlers.py\n@@ -908,8 +908,23 @@\n \n     def get(self):\n         sep = '&' if '?' in self._url else '?'\n-        url = sep.join([self._url, self.request.query])\n-        self.redirect(url, permanent=self._permanent)\n+        target_url = sep.join([self._url, self.request.query])\n+        \n+        # Validate redirect target is same origin\n+        parsed = urlparse(target_url)\n+        if parsed.netloc:\n+            # Check for same origin (scheme + netloc)\n+            expected_scheme = self.request.protocol\n+            expected_netloc = self.request.host\n+            if parsed.scheme:\n+                if parsed.scheme != expected_scheme or parsed.netloc != expected_netloc:\n+                    raise web.HTTPError(403, \"Redirect to untrusted site blocked\")\n+            else:\n+                # Protocol-relative URL (//example.com) - treat as absolute with current scheme\n+                if parsed.netloc != expected_netloc:\n+                    raise web.HTTPError(403, \"Redirect to untrusted site blocked\")\n+        \n+        self.redirect(target_url, permanent=self._permanent)\n \n class PrometheusMetricsHandler(IPythonHandler):\n     \"\"\"\n\n"}
{"cve": "CVE-2022-3298", "fix_patch": "--- a/rdiffweb/controller/pref_sshkeys.py\n+++ b/rdiffweb/controller/pref_sshkeys.py\n@@ -56,9 +56,9 @@\n         _('Key'),\n         widget=TextArea(),\n         description=_(\n-            \"Enter a SSH public key. It should start with 'ssh-dss', 'ssh-ed25519', 'ssh-rsa', 'ecdsa-sha2-nistp256', 'ecdsa-sha2-nistp384' or 'ecdsa-sha2-nistp521'.\"\n+            \"Enter a SSH public key. It should start with 'ssh-dss', 'ssh-ed25519', 'ssh-rsa', 'ecdsa-sha2-nistp256', 'ecdsa-sha2-nistp384' or 'ecdsa-sha2-nistp521'. (Maximum 8192 characters)\"\n         ),\n-        validators=[validators.data_required(), validate_key],\n+        validators=[validators.data_required(), validate_key, validators.Length(max=8192)],\n     )\n     fingerprint = StringField('Fingerprint')\n \n\n"}
{"cve": "CVE-2021-22538", "fix_patch": ""}
{"cve": "CVE-2024-23334", "fix_patch": "--- a/aiohttp/web_urldispatcher.py\n+++ b/aiohttp/web_urldispatcher.py\n@@ -575,8 +575,7 @@\n         if append_version:\n             try:\n                 filepath = self._directory.joinpath(filename).resolve()\n-                if not self._follow_symlinks:\n-                    filepath.relative_to(self._directory)\n+                filepath.relative_to(self._directory)\n             except (ValueError, FileNotFoundError):\n                 # ValueError for case when path point to symlink\n                 # with follow_symlinks is False\n@@ -641,8 +640,7 @@\n                 # where the static dir is totally different\n                 raise HTTPForbidden()\n             filepath = self._directory.joinpath(filename).resolve()\n-            if not self._follow_symlinks:\n-                filepath.relative_to(self._directory)\n+            filepath.relative_to(self._directory)\n         except (ValueError, FileNotFoundError) as error:\n             # relatively safe\n             raise HTTPNotFound() from error\n\n"}
{"cve": "CVE-2020-26294", "fix_patch": "--- a/template/native/render.go\n+++ b/template/native/render.go\n@@ -22,10 +22,16 @@\n \t\t\"vela\": velaFuncs.returnPlatformVar,\n \t}\n \n-\t// parse the template with Masterminds/sprig functions\n+\t// parse the template with Masterminds/sprig functions (env function removed to prevent config exposure)\n \t//\n \t// https://pkg.go.dev/github.com/Masterminds/sprig?tab=doc#TxtFuncMap\n-\tt, err := template.New(s.Name).Funcs(sprig.TxtFuncMap()).Funcs(templateFuncMap).Parse(tmpl)\n+\tsprigFuncs := make(map[string]interface{})\n+\tfor k, v := range sprig.TxtFuncMap() {\n+\t\tsprigFuncs[k] = v\n+\t}\n+\tdelete(sprigFuncs, \"env\")\n+\n+\tt, err := template.New(s.Name).Funcs(sprigFuncs).Funcs(templateFuncMap).Parse(tmpl)\n \tif err != nil {\n \t\treturn types.StepSlice{}, fmt.Errorf(\"unable to parse template %s: %v\", s.Template.Name, err)\n \t}\n\n"}
{"cve": "CVE-2016-10548", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -30,6 +30,118 @@\n function reduceCSSCalc(value, decimalPrecision) {\n   stack = 0\n   decimalPrecision = Math.pow(10, decimalPrecision === undefined ? 5 : decimalPrecision)\n+\n+  // Safe arithmetic evaluator (replaces eval to prevent code injection)\n+  function tokenize(expr) {\n+    const tokens = [];\n+    let numBuffer = '';\n+    const ops = '+*-/()';\n+    let expectNumber = true;\n+\n+    for (let i = 0; i < expr.length; i++) {\n+      const char = expr[i];\n+      if (char === ' ') {\n+        if (numBuffer) {\n+          tokens.push(numBuffer);\n+          numBuffer = '';\n+          expectNumber = false;\n+        }\n+        continue;\n+      }\n+\n+      if (ops.includes(char)) {\n+        if (char === '-' && expectNumber) {\n+          numBuffer += char;\n+          expectNumber = false;\n+        } else {\n+          if (numBuffer) {\n+            tokens.push(numBuffer);\n+            numBuffer = '';\n+            expectNumber = false;\n+          }\n+          tokens.push(char);\n+          expectNumber = (char === '(');\n+        }\n+      } else {\n+        numBuffer += char;\n+        expectNumber = false;\n+      }\n+    }\n+\n+    if (numBuffer) tokens.push(numBuffer);\n+\n+    for (let i = 0; i < tokens.length; i++) {\n+      const token = tokens[i];\n+      if (token === '-' && (i === 0 || tokens[i-1] === '(' || ops.includes(tokens[i-1]))) {\n+        if (i+1 >= tokens.length || !/^\\d+(\\.\\d+)?$/.test(tokens[i+1])) throw new Error('Invalid unary minus');\n+        tokens[i+1] = '-' + tokens[i+1];\n+        tokens.splice(i, 1);\n+      }\n+    }\n+\n+    return tokens;\n+  }\n+\n+  function shuntingYard(tokens) {\n+    const output = [];\n+    const stack = [];\n+    const precedence = { '+': 1, '-': 1, '*': 2, '/': 2 };\n+    const associativity = { '+': 'left', '-': 'left', '*': 'left', '/': 'left' };\n+\n+    for (let token of tokens) {\n+      if (/^-?\\d+(\\.\\d+)?$/.test(token)) {\n+        output.push(token);\n+      } else if (token === '(') {\n+        stack.push(token);\n+      } else if (token === ')') {\n+        while (stack.length && stack[stack.length-1] !== '(') output.push(stack.pop());\n+        stack.pop();\n+      } else if (precedence[token]) {\n+        while (stack.length && stack[stack.length-1] !== '(' && \n+               (precedence[stack[stack.length-1]] > precedence[token] || \n+                (precedence[stack[stack.length-1]] === precedence[token] && associativity[token] === 'left'))) {\n+          output.push(stack.pop());\n+        }\n+        stack.push(token);\n+      } else {\n+        throw new Error('Invalid token: ' + token);\n+      }\n+    }\n+\n+    while (stack.length) output.push(stack.pop());\n+    return output;\n+  }\n+\n+  function evaluatePostfix(postfix) {\n+    const stack = [];\n+    for (let token of postfix) {\n+      if (/^-?\\d+(\\.\\d+)?$/.test(token)) {\n+        stack.push(parseFloat(token));\n+      } else {\n+        const b = stack.pop();\n+        const a = stack.pop();\n+        switch (token) {\n+          case '+': stack.push(a + b); break;\n+          case '-': stack.push(a - b); break;\n+          case '*': stack.push(a * b); break;\n+          case '/': \n+            if (b === 0) throw new Error('Division by zero');\n+            stack.push(a / b); \n+            break;\n+          default: throw new Error('Unknown operator: ' + token);\n+        }\n+      }\n+    }\n+    if (stack.length !== 1) throw new Error('Invalid expression');\n+    return stack[0];\n+  }\n+\n+  function safeEval(expr) {\n+    if (typeof expr !== 'string' || expr.trim() === '') throw new Error('Empty expression');\n+    const tokens = tokenize(expr);\n+    const postfix = shuntingYard(tokens);\n+    return evaluatePostfix(postfix);\n+  }\n \n   /**\n    * Evaluates an expression\n\n"}
{"cve": "CVE-2022-2421", "fix_patch": ""}
{"cve": "CVE-2023-23947", "fix_patch": "--- a/server/cluster/cluster.go\n+++ b/server/cluster/cluster.go\n@@ -221,13 +221,13 @@\n \t}\n \n \t// verify that user can do update inside project where cluster is located\n-\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceClusters, rbacpolicy.ActionUpdate, createRBACObject(c.Project, q.Cluster.Server)); err != nil {\n+\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceClusters, rbacpolicy.ActionUpdate, createRBACObject(c.Project, c.Server)); err != nil {\n \t\treturn nil, err\n \t}\n \n \tif len(q.UpdatedFields) == 0 || sets.NewString(q.UpdatedFields...).Has(\"project\") {\n \t\t// verify that user can do update inside project where cluster will be located\n-\t\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceClusters, rbacpolicy.ActionUpdate, createRBACObject(q.Cluster.Project, q.Cluster.Server)); err != nil {\n+\t\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceClusters, rbacpolicy.ActionUpdate, createRBACObject(q.Cluster.Project, c.Server)); err != nil {\n \t\t\treturn nil, err\n \t\t}\n \t}\n\n"}
{"cve": "CVE-2024-30260", "fix_patch": "--- a/lib/handler/redirect-handler.js\n+++ b/lib/handler/redirect-handler.js\n@@ -201,9 +201,9 @@\n   if (removeContent && util.headerNameToString(header).startsWith('content-')) {\n     return true\n   }\n-  if (unknownOrigin && (header.length === 13 || header.length === 6)) {\n+  if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 18)) {\n     const name = util.headerNameToString(header)\n-    return name === 'authorization' || name === 'cookie'\n+    return name === 'authorization' || name === 'proxy-authorization' || name === 'cookie'\n   }\n   return false\n }\n\n"}
{"cve": "CVE-2021-41246", "fix_patch": "--- a/middleware/auth.js\n+++ b/middleware/auth.js\n@@ -130,8 +130,16 @@\n           }\n \n           Object.assign(req[config.session.name], session);\n+\n+          // Regenerate session to prevent session fixation\n+          await new Promise((resolve, reject) => {\n+            req.session.regenerate((err) => {\n+              if (err) return reject(err);\n+              resolve();\n+            });\n+          });\n+\n           attemptSilentLogin.resumeSilentLogin(req, res);\n-\n           next();\n         } catch (err) {\n           // Swallow errors if this is a silentLogin\n\n"}
{"cve": "CVE-2022-0722", "fix_patch": "--- a/lib/index.js\n+++ b/lib/index.js\n@@ -45,6 +45,7 @@\n         url = normalizeUrl(url, normalize)\n     }\n     const parsed = parsePath(url)\n+    delete parsed.password;\n     return parsed;\n }\n \n\n"}
{"cve": "CVE-2019-10788", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -22,6 +22,8 @@\n \n module.exports.cmd = function(path, opts) {\n   opts = opts || {};\n+  // Sanitize path to prevent command injection and quote for shell safety\n+  const sanitizedPath = path.replace(/[;|&><$`]/g, '').replace(/'/g, \"'\\\\''\");\n   var format = [\n     'name=',\n     'size=%[size]',\n@@ -33,7 +35,7 @@\n     (opts.exif ? '%[exif:*]' : '')\n   ].join(\"\\n\");\n \n-  return 'identify -format \"' + format + '\" ' + path;\n+  return 'identify -format \"' + format + '\" \\'' + sanitizedPath + '\\'';\n };\n \n module.exports.parse = function(path, stdout, opts) {\n\n"}
{"cve": "CVE-2018-14574", "fix_patch": "\n\n"}
{"cve": "CVE-2022-31506", "fix_patch": "--- a/opendiamond/dataretriever/diamond_store.py\n+++ b/opendiamond/dataretriever/diamond_store.py\n@@ -120,7 +120,12 @@\n \n \n def _get_obj_absolute_path(obj_path):\n-    return os.path.join(DATAROOT, obj_path)\n+    path = os.path.join(DATAROOT, obj_path)\n+    # Prevent path traversal by ensuring path is within DATAROOT\n+    real_path = os.path.realpath(path)\n+    if not real_path.startswith(os.path.realpath(DATAROOT) + os.path.sep):\n+        raise ValueError(\"Invalid path traversal attempt\")\n+    return real_path\n \n \n def _get_index_absolute_path(index):\n\n"}
{"cve": "CVE-2023-25168", "fix_patch": ""}
{"cve": "CVE-2024-24579", "fix_patch": "--- a/pkg/file/tarutil.go\n+++ b/pkg/file/tarutil.go\n@@ -126,8 +126,21 @@\n \n // UntarToDirectory writes the contents of the given tar reader to the given destination\n func UntarToDirectory(reader io.Reader, dst string) error {\n+\t// Clean destination path to ensure consistent validation\n+\tdstClean := filepath.Clean(dst)\n+\t\n \tvisitor := func(entry TarFileEntry) error {\n+\t\t// Validate path doesn't escape destination directory\n \t\ttarget := filepath.Join(dst, entry.Header.Name)\n+\t\ttargetClean := filepath.Clean(target)\n+\t\t\n+\t\t// Check that target path remains within destination directory\n+\t\tif !filepath.IsAbs(dstClean) {\n+\t\t\tdstClean = filepath.Join(\"/\", dstClean) // Make absolute for proper prefix check\n+\t\t}\n+\t\tif !strings.HasPrefix(targetClean, dstClean) {\n+\t\t\treturn fmt.Errorf(\"path traversal attempt detected in tar entry: %q\", entry.Header.Name)\n+\t\t}\n \n \t\tswitch entry.Header.Typeflag {\n \t\tcase tar.TypeDir:\n\n"}
{"cve": "CVE-2019-19499", "fix_patch": "--- a/pkg/tsdb/mysql/mysql.go\n+++ b/pkg/tsdb/mysql/mysql.go\n@@ -31,12 +31,24 @@\n \tif strings.HasPrefix(datasource.Url, \"/\") {\n \t\tprotocol = \"unix\"\n \t}\n+\t\n+\t// Sanitize database name to prevent SQL injection\n+\tsanitizedDB := strings.Map(func(r rune) rune {\n+\t\tif r >= 'a' && r <= 'z' || r >= 'A' && r <= 'Z' || r >= '0' && r <= '9' || r == '_' || r == '-' {\n+\t\t\treturn r\n+\t\t}\n+\t\treturn -1\n+\t}, datasource.Database)\n+\t\n+\t// Escape URL to prevent SQL injection and connection string parsing issues\n+\tescapedUrl := url.QueryEscape(datasource.Url)\n+\t\n \tcnnstr := fmt.Sprintf(\"%s:%s@%s(%s)/%s?collation=utf8mb4_unicode_ci&parseTime=true&loc=UTC&allowNativePasswords=true\",\n \t\tdatasource.User,\n \t\tdatasource.DecryptedPassword(),\n \t\tprotocol,\n-\t\tdatasource.Url,\n-\t\tdatasource.Database,\n+\t\tescapedUrl,\n+\t\tsanitizedDB,\n \t)\n \n \ttlsConfig, err := datasource.GetTLSConfig()\n\n"}
{"cve": "CVE-2017-16100", "fix_patch": "\n\n"}
{"cve": "CVE-2020-7631", "fix_patch": "--- a/lib/posix.js\n+++ b/lib/posix.js\n@@ -1,14 +1,10 @@\n 'use strict';\n \n-var exec = require('child_process').exec;\n+var execFile = require('child_process').execFile;\n var isDigits = require('./utils').isDigits;\n \n function diskusage(path, cb) {\n-    if (path.indexOf('\"') !== -1) {\n-        return cb(new Error('Paths with double quotes are not supported yet'));\n-    }\n-\n-    exec('df -k \"' + path + '\"', function(err, stdout) {\n+    execFile('df', ['-k', path], function(err, stdout) {\n         if (err) {\n             return cb(err);\n         }\n\n"}
{"cve": "CVE-2023-25165", "fix_patch": "--- a/pkg/engine/engine.go\n+++ b/pkg/engine/engine.go\n@@ -106,6 +106,8 @@\n // initFunMap creates the Engine's FuncMap and adds context-specific functions.\n func (e Engine) initFunMap(t *template.Template, referenceTpls map[string]renderable) {\n \tfuncMap := funcMap()\n+\t// Remove getHostByName to prevent DNS leakage of sensitive information (CVE-2023-3518)\n+\tdelete(funcMap, \"getHostByName\")\n \tincludedNames := make(map[string]int)\n \n \t// Add the 'include' function here so we can close over t.\n\n"}
{"cve": "CVE-2020-7675", "fix_patch": "--- a/src/messenger-node.js\n+++ b/src/messenger-node.js\n@@ -68,7 +68,11 @@\n   line: color => {\n     if (color.length > 0) {\n       try {\n-        eval(`cl.${color}()`); // eslint-disable-line\n+        if (typeof cl[color] === 'function') {\n+          cl[color]();\n+        } else {\n+          throw new Error('Invalid color');\n+        }\n       }\n       catch (e) {\n         console.error(chalk.bgRed.bold(`Invalid Color: ${color}`));\n\n"}
{"cve": "CVE-2017-16198", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -29,16 +29,29 @@\n \n         //\u8865\u5168\u6587\u4ef6\u8def\u5f84\n         if (path.extname(pathName) == \"\") {\n-\n-            if(!/\\/$/.test(pathName)){\n+            if (!/\\/$/.test(pathName)) {\n                 pathName += '/';\n             }\n-\n             pathName += argvs.getDefault();\n         }\n \n-        //\u4f7f\u7528\u8def\u5f84\u89e3\u6790\u6a21\u5757,\u7ec4\u88c5\u5b9e\u9645\u6587\u4ef6\u8def\u5f84 \n-        var filePath = path.join(argvs.getPath(), pathName);\n+        // Remove leading slashes to ensure path is relative to base directory\n+        pathName = pathName.replace(/^\\/+/, '');\n+\n+        // Get absolute base directory and resolve file path\n+        const baseDir = path.resolve(argvs.getPath());\n+        const filePath = path.resolve(baseDir, pathName);\n+\n+        // Check for path traversal (ensure file is within base directory)\n+        const normalizedBase = path.normalize(baseDir);\n+        const normalizedPath = path.normalize(filePath);\n+        const isPathInside = normalizedPath === normalizedBase || normalizedPath.startsWith(normalizedBase + path.sep);\n+\n+        if (!isPathInside) {\n+            res.writeHead(403, { 'Content-Type': 'text/html' });\n+            res.end('<h1>403 Forbidden: Invalid path</h1>');\n+            return;\n+        }\n \n         //\u5224\u65ad\u6587\u4ef6\u662f\u5426\u5b58\u5728 \n         fs.exists(filePath, function(exists) {\n\n"}
{"cve": "CVE-2024-21542", "fix_patch": "--- a/luigi/contrib/lsf_runner.py\n+++ b/luigi/contrib/lsf_runner.py\n@@ -49,17 +49,19 @@\n     if not os.path.exists(package_file):\n         return\n \n-    curdir = os.path.abspath(os.curdir)\n-\n-    os.chdir(work_dir)\n     tar = tarfile.open(package_file)\n+    work_dir_abspath = os.path.abspath(work_dir)\n     for tarinfo in tar:\n-        tar.extract(tarinfo)\n+        dest_path = os.path.join(work_dir_abspath, tarinfo.name)\n+        dest_path_abspath = os.path.abspath(dest_path)\n+        # Prevent Zip Slip vulnerability by checking path traversal\n+        if os.path.commonpath([dest_path_abspath, work_dir_abspath]) != work_dir_abspath:\n+            logging.warning(f\"Skipping unsafe path in archive: {tarinfo.name}\")\n+            continue\n+        tar.extract(tarinfo, path=work_dir_abspath)\n     tar.close()\n-    if '' not in sys.path:\n-        sys.path.insert(0, '')\n-\n-    os.chdir(curdir)\n+    if work_dir_abspath not in sys.path:\n+        sys.path.insert(0, work_dir_abspath)\n \n \n def main(args=sys.argv):\n\n--- a/luigi/contrib/sge_runner.py\n+++ b/luigi/contrib/sge_runner.py\n@@ -61,17 +61,19 @@\n     if not os.path.exists(package_file):\n         return\n \n-    curdir = os.path.abspath(os.curdir)\n-\n-    os.chdir(work_dir)\n     tar = tarfile.open(package_file)\n+    work_dir_abspath = os.path.abspath(work_dir)\n     for tarinfo in tar:\n-        tar.extract(tarinfo)\n+        dest_path = os.path.join(work_dir_abspath, tarinfo.name)\n+        dest_path_abspath = os.path.abspath(dest_path)\n+        # Prevent Zip Slip vulnerability by checking path traversal\n+        if os.path.commonpath([dest_path_abspath, work_dir_abspath]) != work_dir_abspath:\n+            logging.warning(f\"Skipping unsafe path in archive: {tarinfo.name}\")\n+            continue\n+        tar.extract(tarinfo, path=work_dir_abspath)\n     tar.close()\n-    if '' not in sys.path:\n-        sys.path.insert(0, '')\n-\n-    os.chdir(curdir)\n+    if work_dir_abspath not in sys.path:\n+        sys.path.insert(0, work_dir_abspath)\n \n \n def main(args=sys.argv):\n\n"}
{"cve": "CVE-2021-32783", "fix_patch": "--- a/internal/dag/accessors.go\n+++ b/internal/dag/accessors.go\n@@ -55,6 +55,14 @@\n \tsvc, svcPort, err := cache.LookupService(meta, port)\n \tif err != nil {\n \t\treturn nil, err\n+\t}\n+\n+\t// Validate ExternalName services to prevent access to restricted resources like Envoy admin interface\n+\tif svc.Spec.Type == v1.ServiceTypeExternalName {\n+\t\tif isRestrictedExternalName(svc.Spec.ExternalName) {\n+\t\t\treturn nil, fmt.Errorf(\"service %q in namespace %q uses restricted external name %q that could access Envoy admin interface\", \n+\t\t\t\tsvc.Name, svc.Namespace, svc.Spec.ExternalName)\n+\t\t}\n \t}\n \n \tif dagSvc := dag.GetService(k8s.NamespacedNameOf(svc), svcPort.Port); dagSvc != nil {\n@@ -78,6 +86,26 @@\n \treturn dagSvc, nil\n }\n \n+// isRestrictedExternalName checks if an external name references a restricted resource\n+// that could be used to access Envoy's admin interface or other local services\n+func isRestrictedExternalName(name string) bool {\n+\t// Block common local addresses that could access Envoy admin interface\n+\trestrictedPatterns := []string{\n+\t\t\"127.0.0.1\",      // Localhost IPv4\n+\t\t\"::1\",            // Localhost IPv6\n+\t\t\"localhost\",      // Localhost hostname\n+\t\t\"envoy\",          // Common Envoy container name\n+\t\t\"envoy-admin\",    // Explicit admin interface reference\n+\t}\n+\n+\tfor _, pattern := range restrictedPatterns {\n+\t\tif name == pattern {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n func upstreamProtocol(svc *v1.Service, port v1.ServicePort) string {\n \tup := annotation.ParseUpstreamProtocols(svc.Annotations)\n \tprotocol := up[port.Name]\n\n"}
{"cve": "CVE-2022-24738", "fix_patch": ""}
{"cve": "CVE-2023-41891", "fix_patch": "--- a/pkg/common/sorting.go\n+++ b/pkg/common/sorting.go\n@@ -24,6 +24,20 @@\n }\n \n func NewSortParameter(sort admin.Sort) (SortParameter, error) {\n+\t// Validate sort key is a valid column name to prevent SQL injection\n+\tvalidColumns := map[string]bool{\n+\t\t\"id\":         true,\n+\t\t\"name\":       true,\n+\t\t\"created_at\": true,\n+\t\t\"updated_at\": true,\n+\t\t\"status\":     true,\n+\t\t// Add other valid column names as needed for your schema\n+\t}\n+\n+\tif !validColumns[sort.Key] {\n+\t\treturn nil, errors.NewFlyteAdminErrorf(codes.InvalidArgument, \"invalid sort key: %s\", sort.Key)\n+\t}\n+\n \tvar gormOrderExpression string\n \tswitch sort.Direction {\n \tcase admin.Sort_DESCENDING:\n\n"}
{"cve": "CVE-2021-31542", "fix_patch": "\n\n"}
{"cve": "CVE-2018-3785", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -25,13 +25,13 @@\n \t\t\tmsg.forEach(function (m) {\n \t\t\t\tm = makeDefault(m);\n \n-\t\t\t\targ += '-m\"' + m + '\" ';\n+\t\t\t\targ += '-m\"' + shell.escape(m) + '\" ';\n \t\t\t});\n \t\t} else {\n-\t\t\targ = '-m\"' + defaultMsg + '\"';\n+\t\t\targ = '-m\"' + shell.escape(defaultMsg) + '\"';\n \t\t}\n \t} else {\n-\t\targ = '-m\"' + msg + '\"';\n+\t\targ = '-m\"' + shell.escape(msg) + '\"';\n \t}\n \n \tshell.exec('git commit ' + arg + ' --allow-empty --no-gpg-sign', {\n\n"}
{"cve": "CVE-2022-31130", "fix_patch": "--- a/pkg/util/proxyutil/reverse_proxy.go\n+++ b/pkg/util/proxyutil/reverse_proxy.go\n@@ -72,6 +72,10 @@\n \t\t// Clear Origin and Referer to avoid CORS issues\n \t\treq.Header.Del(\"Origin\")\n \t\treq.Header.Del(\"Referer\")\n+\n+\t\t// Remove authentication headers to prevent token leakage to plugins\n+\t\treq.Header.Del(\"Authorization\")\n+\t\treq.Header.Del(\"Cookie\")\n \t}\n }\n \n\n"}
{"cve": "CVE-2020-7781", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -10,9 +10,9 @@\n function testSync(host, port, connectTimeout) {\n     const nodeBinary = process.execPath;\n     const scriptPath = path.join(__dirname, \"./scripts/connection-tester\");\n-    const cmd = util.format('\"%s\" \"%s\" %s %s %s', nodeBinary, scriptPath, host, port, connectTimeout);\n+    const args = [scriptPath, host, port, connectTimeout];\n \n-    const shellOut = shell.execSync(cmd).toString();\n+    const shellOut = shell.execFileSync(nodeBinary, args, { encoding: 'utf8' });\n \n     const output = {\n         success: false,\n\n"}
{"cve": "CVE-2021-37712", "fix_patch": "--- a/lib/path-reservations.js\n+++ b/lib/path-reservations.js\n@@ -19,17 +19,31 @@\n   // fn => {paths:[path,...], dirs:[path, ...]}\n   const reservations = new Map()\n \n-  // return a set of parent dirs for a given path\n-  const getDirs = path =>\n-    path.split('/').slice(0, -1).reduce((set, path) =>\n-      set.length ? set.concat(normPath(join(set[set.length - 1], path)))\n-      : [path], [])\n+  // Return a set of parent dirs for a given path with proper normalization\n+  const getDirs = path => {\n+    const parts = path.split('/').slice(0, -1)\n+    return parts.reduce((dirs, part) => {\n+      const newPath = dirs.length \n+        ? normPath(join(dirs[dirs.length - 1], part))\n+        : normPath(part)\n+      return dirs.concat(newPath)\n+    }, [])\n+  }\n \n-  // functions currently running\n+  // Check if a path exists and is not a symlink\n+  const isRealDirectory = async (path) => {\n+    try {\n+      const stats = await fs.promises.lstat(path)\n+      return stats.isDirectory() && !stats.isSymbolicLink()\n+    } catch {\n+      return false\n+    }\n+  }\n+\n+  // Functions currently running\n   const running = new Set()\n \n-  // return the queues for each path the function cares about\n-  // fn => {paths, dirs}\n+  // Return the queues for each path the function cares about\n   const getQueues = fn => {\n     const res = reservations.get(fn)\n     /* istanbul ignore if - unpossible */\n@@ -41,15 +55,15 @@\n     }\n   }\n \n-  // check if fn is first in line for all its paths, and is\n+  // Check if fn is first in line for all its paths, and is\n   // included in the first set for all its dir queues\n   const check = fn => {\n     const {paths, dirs} = getQueues(fn)\n-    return paths.every(q => q[0] === fn) &&\n-      dirs.every(q => q[0] instanceof Set && q[0].has(fn))\n+    return paths.every(q => q && q[0] === fn) &&\n+      dirs.every(q => q && q[0] instanceof Set && q[0].has(fn))\n   }\n \n-  // run the function if it's first in line and not already running\n+  // Run the function if it's first in line and not already running\n   const run = fn => {\n     if (running.has(fn) || !check(fn))\n       return false\n@@ -67,30 +81,33 @@\n \n     paths.forEach(path => {\n       const q = queues.get(path)\n-      assert.equal(q[0], fn)\n-      if (q.length === 1)\n-        queues.delete(path)\n-      else {\n-        q.shift()\n-        if (typeof q[0] === 'function')\n-          next.add(q[0])\n-        else\n-          q[0].forEach(fn => next.add(fn))\n+      if (q) {\n+        assert.equal(q[0], fn)\n+        if (q.length === 1)\n+          queues.delete(path)\n+        else {\n+          q.shift()\n+          if (typeof q[0] === 'function')\n+            next.add(q[0])\n+          else\n+            q[0].forEach(fn => next.add(fn))\n+        }\n       }\n     })\n \n     dirs.forEach(dir => {\n       const q = queues.get(dir)\n-      assert(q[0] instanceof Set)\n-      if (q[0].size === 1 && q.length === 1) {\n-        queues.delete(dir)\n-      } else if (q[0].size === 1) {\n-        q.shift()\n-\n-        // must be a function or else the Set would've been reused\n-        next.add(q[0])\n-      } else\n-        q[0].delete(fn)\n+      if (q) {\n+        assert(q[0] instanceof Set)\n+        if (q[0].size === 1 && q.length === 1) {\n+          queues.delete(dir)\n+        } else if (q[0].size === 1) {\n+          q.shift()\n+          next.add(q[0])\n+        } else {\n+          q[0].delete(fn)\n+        }\n+      }\n     })\n     running.delete(fn)\n \n@@ -98,19 +115,41 @@\n     return true\n   }\n \n-  const reserve = (paths, fn) => {\n-    paths = paths.map(p => normPath(join(p)).toLowerCase())\n+  const reserve = async (paths, fn) => {\n+    // Enhanced path normalization with security checks\n+    const normalizedPaths = paths.map(p => {\n+      let path = normPath(join(p))\n+      // Add additional normalization for Unicode and Windows paths\n+      path = path.normalize('NFC') // Unicode normalization\n+      return path.toLowerCase()\n+    })\n+\n+    // Get directory paths with proper normalization\n     const dirs = new Set(\n-      paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b))\n+      normalizedPaths.map(path => getDirs(path)).reduce((a, b) => a.concat(b))\n     )\n-    reservations.set(fn, {dirs, paths})\n-    paths.forEach(path => {\n+\n+    // Verify all directories exist and are not symlinks\n+    const allDirsReal = await Promise.all(\n+      [...dirs].map(dir => isRealDirectory(dir))\n+    )\n+\n+    if (!allDirsReal.every(Boolean)) {\n+      return false\n+    }\n+\n+    reservations.set(fn, {dirs, paths: normalizedPaths})\n+    \n+    // Add path reservations\n+    normalizedPaths.forEach(path => {\n       const q = queues.get(path)\n       if (!q)\n         queues.set(path, [fn])\n       else\n         q.push(fn)\n     })\n+\n+    // Add directory reservations\n     dirs.forEach(dir => {\n       const q = queues.get(dir)\n       if (!q)\n\n"}
{"cve": "CVE-2023-25173", "fix_patch": "--- a/oci/spec_opts.go\n+++ b/oci/spec_opts.go\n@@ -759,17 +759,20 @@\n \t\t\t} else {\n \t\t\t\tusername = userstr\n \t\t\t}\n+\t\t\tprimaryGID := s.Process.User.GID\n \t\t\tgids, err := getSupplementalGroupsFromPath(root, func(g user.Group) bool {\n-\t\t\t\t// we only want supplemental groups\n-\t\t\t\tif g.Name == username {\n-\t\t\t\t\treturn false\n-\t\t\t\t}\n-\t\t\t\tfor _, entry := range g.List {\n-\t\t\t\t\tif entry == username {\n-\t\t\t\t\t\treturn true\n+\t\t\t\t// Check if user is a member of the group (primary or supplementary)\n+\t\t\t\tisMember := g.Name == username\n+\t\t\t\tif !isMember {\n+\t\t\t\t\tfor _, entry := range g.List {\n+\t\t\t\t\t\tif entry == username {\n+\t\t\t\t\t\t\tisMember = true\n+\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\treturn false\n+\t\t\t\t// Return supplementary groups (member but not primary group)\n+\t\t\t\treturn isMember && (uint32(g.Gid) != primaryGID)\n \t\t\t})\n \t\t\tif err != nil {\n \t\t\t\tif os.IsNotExist(err) {\n\n"}
{"cve": "CVE-2022-24825", "fix_patch": "--- a/pkg/smokescreen/acl/v1/acl.go\n+++ b/pkg/smokescreen/acl/v1/acl.go\n@@ -222,6 +222,10 @@\n }\n \n func hostMatchesGlob(host string, domainGlob string) bool {\n+\t// Normalize: lowercase and remove trailing dot from both values\n+\thost = strings.TrimSuffix(strings.ToLower(host), \".\")\n+\tdomainGlob = strings.TrimSuffix(strings.ToLower(domainGlob), \".\")\n+\n \tif domainGlob != \"\" && domainGlob[0] == '*' {\n \t\tsuffix := domainGlob[1:]\n \t\tif strings.HasSuffix(host, suffix) {\n\n"}
{"cve": "CVE-2021-21384", "fix_patch": "--- a/src/unix.js\n+++ b/src/unix.js\n@@ -11,7 +11,7 @@\n  * @returns {string} The escaped argument.\n  */\n function escapeShellArg(arg) {\n-  return arg.replace(/'/g, `'\\\\''`);\n+  return `'${arg.replace(/'/g, \"'\\\\''\")}'`;\n }\n \n module.exports.escapeShellArg = escapeShellArg;\n\n"}
{"cve": "CVE-2018-20834", "fix_patch": ""}
{"cve": "CVE-2021-33420", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -428,7 +428,10 @@\n         },\n \n         fromSerializable: function (val) {\n-            return typeof GLOBAL[val.ctorName] === 'function' ? new GLOBAL[val.ctorName](val.arr) : val.arr;\n+            if (TYPED_ARRAY_CTORS.indexOf(val.ctorName) > -1 && typeof GLOBAL[val.ctorName] === 'function') {\n+                return new GLOBAL[val.ctorName](val.arr);\n+            }\n+            return val.arr;\n         }\n     },\n \n\n"}
{"cve": "CVE-2020-7764", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -27,6 +27,14 @@\n \n const acceptVersionStrategy = require('./lib/accept-version')\n \n+const noopVersioning = {\n+  storage: () => ({\n+    get: () => undefined,\n+    set: () => {}\n+  }),\n+  deriveVersion: () => undefined\n+}\n+\n function Router (opts) {\n   if (!(this instanceof Router)) {\n     return new Router(opts)\n@@ -51,7 +59,7 @@\n   this.ignoreTrailingSlash = opts.ignoreTrailingSlash || false\n   this.maxParamLength = opts.maxParamLength || 100\n   this.allowUnsafeRegex = opts.allowUnsafeRegex || false\n-  this.versioning = opts.versioning || acceptVersionStrategy\n+  this.versioning = opts.versioning || noopVersioning\n   this.trees = {}\n   this.routes = []\n }\n@@ -404,16 +412,32 @@\n         var paramsObj = {}\n         if (handle.paramsLength > 0) {\n           var paramNames = handle.params\n-\n           for (i = 0; i < handle.paramsLength; i++) {\n             paramsObj[paramNames[i]] = params[i]\n           }\n         }\n-\n         return {\n           handler: handle.handler,\n           params: paramsObj,\n           store: handle.store\n+        }\n+      }\n+      // Fallback to non-versioned handler if version is present but no versioned handler exists\n+      if (version !== undefined) {\n+        handle = currentNode.handler\n+        if (handle !== null && handle !== undefined) {\n+          var paramsObj = {}\n+          if (handle.paramsLength > 0) {\n+            var paramNames = handle.params\n+            for (i = 0; i < handle.paramsLength; i++) {\n+              paramsObj[paramNames[i]] = params[i]\n+            }\n+          }\n+          return {\n+            handler: handle.handler,\n+            params: paramsObj,\n+            store: handle.store\n+          }\n         }\n       }\n     }\n\n"}
{"cve": "CVE-2017-1001004", "fix_patch": "--- a/typed-function.js\n+++ b/typed-function.js\n@@ -1098,10 +1098,11 @@\n       // generate code for the typed function\n       var code = [];\n       var _name = name || '';\n+      var sanitizedName = _name.replace(/'/g, \"\\\\'\"); // Escape single quotes to prevent code injection\n       var _args = getArgs(maxParams(_signatures));\n-      code.push('function ' + _name + '(' + _args.join(', ') + ') {');\n+      code.push('function ' + sanitizedName + '(' + _args.join(', ') + ') {');\n       code.push('  \"use strict\";');\n-      code.push('  var name = \\'' + _name + '\\';');\n+      code.push('  var name = \\'' + sanitizedName + '\\';');\n       code.push(node.toCode(refs, '  ', false));\n       code.push('}');\n \n\n"}
{"cve": "CVE-2017-1000189", "fix_patch": "--- a/lib/ejs.js\n+++ b/lib/ejs.js\n@@ -268,11 +268,9 @@\n function cpOptsInData(data, opts) {\n   _OPTS.forEach(function (p) {\n     if (typeof data[p] != 'undefined') {\n-      // Disallow setting the root opt for includes via a passed data obj\n-      // Unsanitized, parameterized use of `render` could allow the\n-      // include directory to be reset, opening up the possibility of\n-      // remote code execution\n-      if (p == 'root') {\n+      // Disallow setting root/delimiter via data object to prevent\n+      // directory traversal (root) and ReDoS (delimiter) attacks\n+      if (p == 'root' || p == 'delimiter') {\n         return;\n       }\n       opts[p] = data[p];\n\n"}
{"cve": "CVE-2017-1001003", "fix_patch": "--- a/lib/expression/node/ObjectNode.js\n+++ b/lib/expression/node/ObjectNode.js\n@@ -60,6 +60,10 @@\n     var entries = [];\n     for (var key in node.properties) {\n       if (hasOwnProperty(node.properties, key)) {\n+        // Validate property key is a valid ASCII identifier\n+        if (!/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key)) {\n+          throw new Error('Invalid property key: ' + key);\n+        }\n         if (!isSafeProperty(node.properties, key)) {\n           throw new Error('No access to property \"' + key + '\"');\n         }\n\n"}
{"cve": "CVE-2016-1000232", "fix_patch": "--- a/lib/cookie.js\n+++ b/lib/cookie.js\n@@ -90,6 +90,7 @@\n \n var MAX_TIME = 2147483647000; // 31-bit max\n var MIN_TIME = 0; // 31-bit min\n+var MAX_COOKIE_LENGTH = 4096; // Prevent ReDoS by limiting cookie size\n \n \n // RFC6265 S5.1.1 date parser:\n@@ -351,6 +352,12 @@\n     c.key = '';\n   }\n   c.value = result[3].trim();\n+\n+  // Prevent ReDoS by limiting cookie key/value size\n+  if (c.key.length > MAX_COOKIE_LENGTH || c.value.length > MAX_COOKIE_LENGTH) {\n+    return;\n+  }\n+\n   if (CONTROL_CHARS.test(c.key) || CONTROL_CHARS.test(c.value)) {\n     return;\n   }\n\n"}
{"cve": "CVE-2021-21321", "fix_patch": "--- a/lib/utils.js\n+++ b/lib/utils.js\n@@ -63,6 +63,13 @@\n     throw new Error('source must be a relative path string')\n   }\n \n+  // Ensure the path doesn't escape the base path prefix\n+  const reqBasePath = new URL(reqBase).pathname\n+  const destPath = dest.pathname\n+  if (!destPath.startsWith(reqBasePath)) {\n+    throw new Error('source must be a relative path string')\n+  }\n+\n   return dest\n }\n \n\n"}
{"cve": "CVE-2020-17479", "fix_patch": "--- a/index.js\n+++ b/index.js\n@@ -138,6 +138,12 @@\n         return result;\n     };\n \n+    // Validate null/undefined first\n+    if (value === null || typeof value === 'undefined') {\n+        if (pattern === null || typeof pattern === 'undefined') return res(true);\n+        return res(false);\n+    }\n+\n     // simple types pattern = number | boolean | symbol | bigint\n     if ((typeof pattern === 'number') || (typeof pattern === 'symbol') || (typeof pattern === 'boolean') ||\n         (typeof pattern === 'bigint') || (typeof pattern === 'undefined') || (pattern === null)) {\n@@ -179,6 +185,10 @@\n         // Patterns\n         let logicalMatches = pattern.match(/^(!)?\\[(.*)\\](\\?)?$/i);\n         if (logicalMatches !== null) {\n+            // Validate value is valid type before pattern comparison\n+            if (typeof value !== 'string' && typeof value !== 'number') {\n+                return res(false);\n+            }\n             const valid = comparePattern(value, logicalMatches[2]);\n \n             // ------------------------> Deprecated\n@@ -204,6 +214,8 @@\n         let functionalRegexMatches = pattern.match(/^(?!=^|,)(!)?\\{\\/(.*)\\/([a-z]*)\\}(\\?)?$/i);\n         if (functionalRegexMatches !== null) {\n             depricated('tag');\n+            // Validate value is string before regex match\n+            if (typeof value !== 'string') return res(false);\n             let match = (String(value).match(new RegExp(functionalRegexMatches[2], functionalRegexMatches[3])) !== null);\n             // Negation ? Operator\n             if (typeof functionalRegexMatches[4] !== 'undefined') {\n@@ -218,6 +230,8 @@\n         let functionalFixedMatches = pattern.match(/^(!)?\\{(.*)\\}(\\?)?$/i);\n         if (functionalFixedMatches !== null) {\n             depricated('tag');\n+            // Validate value is string before comparison\n+            if (typeof value !== 'string') return res(false);\n             let match = (String(value) === String(functionalFixedMatches[2]));\n             // Negation ? Operator\n             if (typeof functionalFixedMatches[3] !== 'undefined') {\n@@ -233,12 +247,33 @@\n         return res(value === pattern);\n     }\n \n+    // Array pattern validation\n+    if (pattern.constructor === Array) {\n+        // Pattern is array but value is not - fail validation\n+        if (value.constructor !== Array) return res(false);\n+        \n+        // Validate array structure before processing\n+        if (!Array.isArray(value) || value.length === 0) return res(false);\n+        \n+        // For array patterns, validate all elements match the first pattern\n+        const firstPattern = pattern[0];\n+        for (let i = 0; i < value.length; i++) {\n+            if (!compare(value[i], firstPattern, options)) {\n+                return res(false);\n+            }\n+        }\n+        return res(true);\n+    }\n+\n     // Constructor is JpvObject\n     if (typeof pattern === 'object' && pattern.constructor === JpvObject) {\n         if (pattern.type === 'not') {\n             return res(!compare(value, pattern.value, options));\n         }\n         if (pattern.type === 'and') {\n+            // Validate pattern array is valid before iteration\n+            if (!Array.isArray(pattern.value) || pattern.value.length === 0) return res(false);\n+            \n             for (let i = 0; i < pattern.value.length; i++) {\n                 if (!compare(value, pattern.value[i])) {\n                     return res(false);\n@@ -247,6 +282,9 @@\n             return true;\n         }\n         if (pattern.type === 'or') {\n+            // Validate pattern array is valid before iteration\n+            if (!Array.isArray(pattern.value) || pattern.value.length === 0) return res(false);\n+            \n             for (let i = 0; i < pattern.value.length; i++) {\n                 if (compare(value, pattern.value[i])) {\n                     return true;\n@@ -264,21 +302,28 @@\n         }\n \n         if (pattern.type === 'is') {\n+            // Validate value type before pattern comparison\n+            if (typeof value !== 'string' && typeof value !== 'number') return res(false);\n             return res(comparePattern(value, pattern.value));\n         }\n     }\n \n     // pattern = object\n     if (typeof pattern === 'object') {\n-        if (value !== null) {\n-            return res(value.constructor === pattern.constructor);\n-        }\n-        return res(value === pattern);\n+        // Validate both are objects before constructor comparison\n+        if (value === null || pattern === null) return res(value === pattern);\n+        if (typeof value !== 'object' || typeof pattern !== 'object') return res(false);\n+        \n+        return res(value.constructor === pattern.constructor);\n     }\n \n     // pattern is a function\n     if (typeof pattern === 'function') {\n-        return res(!!pattern(value));\n+        try {\n+            return res(!!pattern(value));\n+        } catch (e) {\n+            return res(false);\n+        }\n     }\n \n     throw new Error('invalid data type');\n\n"}
{"cve": "CVE-2019-10792", "fix_patch": "--- a/src/index.js\n+++ b/src/index.js\n@@ -19,6 +19,10 @@\n  */\n export function handler (type, name, fn) {\n   if (arguments.length > 2) {\n+    const forbidden = ['__proto__', 'constructor', 'prototype']\n+    if (forbidden.includes(name)) {\n+      throw new Error(`Forbidden handler name: ${name}`)\n+    }\n     handlers[type][name] = fn\n   }\n \n\n"}
{"cve": "CVE-2019-10795", "fix_patch": "--- a/lib/undefsafe.js\n+++ b/lib/undefsafe.js\n@@ -69,6 +69,10 @@\n     key = parts[i];\n     parent = obj;\n \n+    if (key === '__proto__') {\n+      return undefined;\n+    }\n+\n     if (key === '*') {\n       // loop through each property\n       var prop = '';\n@@ -111,7 +115,9 @@\n     obj = undefined;\n   } else if (!star && value) {\n     key = path.split('.').pop();\n-    parent[key] = value;\n+    if (key !== '__proto__') {\n+      parent[key] = value;\n+    }\n   }\n   return obj;\n }\n\n"}
{"cve": "CVE-2021-32796", "fix_patch": "--- a/lib/dom.js\n+++ b/lib/dom.js\n@@ -1271,7 +1271,7 @@\n \t\t * @see https://www.w3.org/TR/xml/#NT-CharData\n \t\t */\n \t\treturn buf.push(node.data\n-\t\t\t.replace(/[<&]/g,_xmlEncoder)\n+\t\t\t.replace(/[<&>]/g,_xmlEncoder)\n \t\t\t.replace(/]]>/g, ']]&gt;')\n \t\t);\n \tcase CDATA_SECTION_NODE:\n\n"}
{"cve": "CVE-2020-26226", "fix_patch": "--- a/lib/hide-sensitive.js\n+++ b/lib/hide-sensitive.js\n@@ -11,7 +11,14 @@\n     return /token|password|credential|secret|private/i.test(envVar) && size(env[envVar].trim()) >= SECRET_MIN_SIZE;\n   });\n \n-  const regexp = new RegExp(toReplace.map((envVar) => escapeRegExp(env[envVar])).join('|'), 'g');\n+  // Create regex patterns for both original and URL-encoded secret values\n+  const patterns = toReplace.flatMap((envVar) => {\n+    const value = env[envVar];\n+    const encodedValue = encodeURIComponent(value);\n+    return [escapeRegExp(value), escapeRegExp(encodedValue)];\n+  });\n+  \n+  const regexp = new RegExp(patterns.join('|'), 'g');\n   return (output) =>\n     output && isString(output) && toReplace.length > 0 ? output.toString().replace(regexp, SECRET_REPLACEMENT) : output;\n };\n\n"}
{"cve": "CVE-2020-26237", "fix_patch": "--- a/src/highlight.js\n+++ b/src/highlight.js\n@@ -785,6 +785,10 @@\n    */\n   function getLanguage(name) {\n     name = (name || '').toLowerCase();\n+    // Prevent prototype pollution by blocking names with prototype chain indicators\n+    if (/(__|prototype|constructor)/.test(name)) {\n+      return undefined;\n+    }\n     return languages[name] || languages[aliases[name]];\n   }\n \n@@ -797,7 +801,15 @@\n     if (typeof aliasList === 'string') {\n       aliasList = [aliasList];\n     }\n-    aliasList.forEach(alias => { aliases[alias] = languageName; });\n+    aliasList.forEach(alias => {\n+      const normalizedAlias = alias.toLowerCase();\n+      // Prevent prototype pollution by blocking dangerous alias names\n+      if (/(__|prototype|constructor)/.test(normalizedAlias)) {\n+        console.warn(`Highlight.js: Rejected dangerous alias '${alias}' for language '${languageName}'`);\n+        return;\n+      }\n+      aliases[normalizedAlias] = languageName;\n+    });\n   }\n \n   /**\n\n"}
{"cve": "CVE-2019-16789", "fix_patch": "--- a/waitress/parser.py\n+++ b/waitress/parser.py\n@@ -29,6 +29,9 @@\n     ServerNotImplemented,\n     find_double_newline,\n )\n+\n+# RFC 7230 tchar: !#$%&'*+-.^_`|~0-9A-Za-z (valid for transfer-coding tokens)\n+tchar_str = frozenset('!#$%&\\'*+-.^_`|~0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz')\n \n \n class ParsingError(Exception):\n\n"}
{"cve": "CVE-2022-29217", "fix_patch": "--- a/jwt/algorithms.py\n+++ b/jwt/algorithms.py\n@@ -75,7 +75,6 @@\n     Returns the algorithms that are implemented by the library.\n     \"\"\"\n     default_algorithms = {\n-        \"none\": NoneAlgorithm(),\n         \"HS256\": HMACAlgorithm(HMACAlgorithm.SHA256),\n         \"HS384\": HMACAlgorithm(HMACAlgorithm.SHA384),\n         \"HS512\": HMACAlgorithm(HMACAlgorithm.SHA512),\n\n"}
{"cve": "CVE-2023-45809", "fix_patch": "--- a/wagtail/users/views/bulk_actions/user_bulk_action.py\n+++ b/wagtail/users/views/bulk_actions/user_bulk_action.py\n@@ -8,7 +8,7 @@\n     models = [get_user_model()]\n \n     def get_all_objects_in_listing_query(self, parent_id):\n-        listing_objects = self.model.objects.all().values_list(\"pk\", flat=True)\n+        listing_objects = self.get_listing_queryset().values_list(\"pk\", flat=True)\n         if \"q\" in self.request.GET:\n             q = self.request.GET.get(\"q\")\n             model_fields = {f.name for f in self.model._meta.get_fields()}\n\n"}
{"cve": "CVE-2025-43859", "fix_patch": "--- a/h11/_readers.py\n+++ b/h11/_readers.py\n@@ -164,10 +164,11 @@\n             data = buf.maybe_extract_at_most(self._bytes_to_discard)\n             if data is None:\n                 return None\n-            self._bytes_to_discard -= len(data)\n-            if self._bytes_to_discard > 0:\n-                return None\n-            # else, fall through and read some more\n+            # Verify we're discarding exactly \\r\\n\n+            if data != b\"\\r\\n\":\n+                raise LocalProtocolError(f\"Expected chunk terminator \\\\r\\\\n but got {data!r}\")\n+            self._bytes_to_discard = 0\n+            # Fall through to continue reading\n         assert self._bytes_to_discard == 0\n         if self._bytes_in_chunk == 0:\n             # We need to refill our chunk count\n@@ -194,6 +195,9 @@\n             return None\n         self._bytes_in_chunk -= len(data)\n         if self._bytes_in_chunk == 0:\n+            # Enforce chunk data is followed by \\r\\n\n+            if len(buf) < 2 or buf.peek(2) != b\"\\r\\n\":\n+                raise LocalProtocolError(\"Chunk data must end with \\\\r\\\\n terminator\")\n             self._bytes_to_discard = 2\n             chunk_end = True\n         else:\n\n"}
{"cve": "CVE-2024-49750", "fix_patch": "--- a/src/snowflake/connector/auth/_auth.py\n+++ b/src/snowflake/connector/auth/_auth.py\n@@ -243,7 +243,7 @@\n \n         logger.debug(\n             \"body['data']: %s\",\n-            {k: v for (k, v) in body[\"data\"].items() if k != \"PASSWORD\"},\n+            {k: v for (k, v) in body[\"data\"].items() if k not in (\"PASSWORD\", \"PASSCODE\")},\n         )\n \n         try:\n\n--- a/src/snowflake/connector/secret_detector.py\n+++ b/src/snowflake/connector/secret_detector.py\n@@ -33,14 +33,14 @@\n         flags=re.IGNORECASE,\n     )\n     PRIVATE_KEY_PATTERN = re.compile(\n-        r\"-----BEGIN PRIVATE KEY-----\\\\n([a-z0-9/+=\\\\n]{32,})\\\\n-----END PRIVATE KEY-----\",\n+        r\"-----BEGIN PRIVATE KEY-----\\n([a-z0-9/+=\\\\n]{32,})\\n-----END PRIVATE KEY-----\",\n         flags=re.MULTILINE | re.IGNORECASE,\n     )\n     PRIVATE_KEY_DATA_PATTERN = re.compile(\n         r'\"privateKeyData\": \"([a-z0-9/+=\\\\n]{10,})\"', flags=re.MULTILINE | re.IGNORECASE\n     )\n     CONNECTION_TOKEN_PATTERN = re.compile(\n-        r\"(token|assertion content)\" r\"([\\'\\\"\\s:=]+)\" r\"([a-z0-9=/_\\-\\+]{8,})\",\n+        r\"(token|assertion content)\" r\"([\\'\\\"\\s:=]+)\" r\"([a-zA-Z0-9_\\-+=]+\\.[a-zA-Z0-9_\\-+=]+\\.[a-zA-Z0-9_\\-+=]+)\",\n         flags=re.IGNORECASE,\n     )\n \n@@ -75,7 +75,7 @@\n     @staticmethod\n     def mask_private_key(text: str) -> str:\n         return SecretDetector.PRIVATE_KEY_PATTERN.sub(\n-            \"-----BEGIN PRIVATE KEY-----\\\\\\\\nXXXX\\\\\\\\n-----END PRIVATE KEY-----\", text\n+            r\"-----BEGIN PRIVATE KEY-----\\nXXXX\\n-----END PRIVATE KEY-----\", text\n         )\n \n     @staticmethod\n\n"}
{"cve": "CVE-2023-41039", "fix_patch": "--- a/src/RestrictedPython/Guards.py\n+++ b/src/RestrictedPython/Guards.py\n@@ -240,15 +240,18 @@\n \n \n def safer_getattr(object, name, default=None, getattr=getattr):\n-    \"\"\"Getattr implementation which prevents using format on string objects.\n-\n-    format() is considered harmful:\n+    \"\"\"Getattr implementation which prevents using format methods on string objects.\n+\n+    format() and format_map() are considered harmful:\n     http://lucumr.pocoo.org/2016/12/29/careful-with-str-format/\n \n     \"\"\"\n-    if isinstance(object, str) and name == 'format':\n+    if isinstance(object, str) and name in ('format', 'format_map'):\n         raise NotImplementedError(\n-            'Using format() on a %s is not safe.' % object.__class__.__name__)\n+            'Using {name}() on a {cls} is not safe.'.format(\n+                name=name, cls=object.__class__.__name__\n+            )\n+        )\n     if name.startswith('_'):\n         raise AttributeError(\n             '\"{name}\" is an invalid attribute name because it '\n\n--- a/src/RestrictedPython/Utilities.py\n+++ b/src/RestrictedPython/Utilities.py\n@@ -14,11 +14,17 @@\n import math\n import random\n import string\n+import types\n \n \n utility_builtins = {}\n \n-utility_builtins['string'] = string\n+# Create a safe string module without Formatter class\n+safe_string = types.ModuleType('string')\n+safe_string.__dict__.update(string.__dict__)\n+if 'Formatter' in safe_string.__dict__:\n+    del safe_string.__dict__['Formatter']\n+utility_builtins['string'] = safe_string\n utility_builtins['math'] = math\n utility_builtins['random'] = random\n utility_builtins['whrandom'] = random\n\n"}
{"cve": "CVE-2023-34457", "fix_patch": "--- a/mechanicalsoup/form.py\n+++ b/mechanicalsoup/form.py\n@@ -43,6 +43,10 @@\n \n         self.form = form\n         self._submit_chosen = False\n+\n+        # Reset file input values to prevent arbitrary file uploads from malicious servers\n+        for input_tag in self.form.select('input[type=\"file\" i]'):\n+            input_tag[\"value\"] = \"\"\n \n         # Aliases for backwards compatibility\n         # (Included specifically in __init__ to suppress them in Sphinx docs)\n\n"}
{"cve": "CVE-2018-7753", "fix_patch": "--- a/bleach/sanitizer.py\n+++ b/bleach/sanitizer.py\n@@ -510,10 +510,11 @@\n \n                 # Look at attributes that have uri values\n                 if namespaced_name in self.attr_val_is_uri:\n+                    val_unescaped = unescape(val).lower()\n                     val_unescaped = re.sub(\n                         \"[`\\000-\\040\\177-\\240\\s]+\",\n                         '',\n-                        unescape(val)).lower()\n+                        val_unescaped)\n \n                     # Remove replacement characters from unescaped characters.\n                     val_unescaped = val_unescaped.replace(\"\\ufffd\", \"\")\n\n"}
{"cve": "CVE-2015-1326", "fix_patch": "--- a/dbusmock/mockobject.py\n+++ b/dbusmock/mockobject.py\n@@ -39,10 +39,17 @@\n \n \n def load_module(name):\n-    if os.path.exists(name) and os.path.splitext(name)[1] == '.py':\n+    if os.path.exists(name):\n+        ext = os.path.splitext(name)[1]\n+        if ext != '.py':\n+            raise ImportError('Not a Python module file (must be .py): %s' % name)\n+        \n         sys.path.insert(0, os.path.dirname(os.path.abspath(name)))\n         try:\n-            m = os.path.splitext(os.path.basename(name))[0]\n+            base = os.path.basename(name)\n+            if os.path.splitext(base)[1] != '.py':\n+                raise ImportError('Not a Python module file (must be .py): %s' % name)\n+            m = os.path.splitext(base)[0]\n             module = importlib.import_module(m)\n         finally:\n             sys.path.pop(0)\n\n"}
{"cve": "CVE-2023-45128", "fix_patch": "--- a/middleware/csrf/csrf.go\n+++ b/middleware/csrf/csrf.go\n@@ -3,6 +3,7 @@\n import (\n \t\"errors\"\n \t\"reflect\"\n+\t\"strings\"\n \t\"time\"\n \n \t\"github.com/gofiber/fiber/v2\"\n@@ -72,11 +73,9 @@\n \t\tdefault:\n \t\t\t// Assume that anything not defined as 'safe' by RFC7231 needs protection\n \n-\t\t\t// Enforce an origin check for HTTPS connections.\n-\t\t\tif c.Protocol() == \"https\" {\n-\t\t\t\tif err := refererMatchesHost(c); err != nil {\n-\t\t\t\t\treturn cfg.ErrorHandler(c, err)\n-\t\t\t\t}\n+\t\t\t// Enforce origin check for all connections\n+\t\t\tif err := refererMatchesHost(c); err != nil {\n+\t\t\t\treturn cfg.ErrorHandler(c, err)\n \t\t\t}\n \n \t\t\t// Extract token from client request i.e. header, query, param, form or cookie\n@@ -157,7 +156,7 @@\n \n func deleteTokenFromStorage(c *fiber.Ctx, token string, cfg Config, sessionManager *sessionManager, storageManager *storageManager) {\n \tif cfg.Session != nil {\n-\t\tsessionManager.delRaw(c)\n+\t\tsessionManager.delRaw(c, token)\n \t} else {\n \t\tstorageManager.delRaw(token)\n \t}\n@@ -223,7 +222,8 @@\n \tif referer == \"\" {\n \t\treturn ErrNoReferer\n \t}\n-\tif referer != c.Protocol()+\"://\"+c.Hostname() {\n+\torigin := c.Protocol() + \"://\" + c.Host()\n+\tif !strings.HasPrefix(referer, origin) {\n \t\treturn ErrBadReferer\n \t}\n \treturn nil\n\n"}
{"cve": "CVE-2024-22199", "fix_patch": "--- a/django/django.go\n+++ b/django/django.go\n@@ -101,7 +101,7 @@\n \tpongoset := pongo2.NewSet(\"default\", pongoloader)\n \t// Set template settings\n \tpongoset.Globals.Update(e.Funcmap)\n-\tpongo2.SetAutoescape(false)\n+\tpongo2.SetAutoescape(true)\n \n \t// Loop trough each Directory and register template files\n \twalkFn := func(path string, info os.FileInfo, err error) error {\n\n"}
{"cve": "CVE-2024-52309", "fix_patch": "--- a/internal/common/common.go\n+++ b/internal/common/common.go\n@@ -182,8 +182,40 @@\n \tversion.SetConfig(c.ServerVersion)\n \tdataprovider.SetTZ(c.TZ)\n \tConfig = c\n-\tConfig.Actions.ExecuteOn = util.RemoveDuplicates(Config.Actions.ExecuteOn, true)\n-\tConfig.Actions.ExecuteSync = util.RemoveDuplicates(Config.Actions.ExecuteSync, true)\n+\n+\t// Apply command allowlist restrictions (CVE-2024-XXXX fix)\n+\tif c.CommandAllowListStatus > 0 {\n+\t\t// Filter synchronous commands\n+\t\tvar allowedSync []string\n+\t\tfor _, cmd := range c.Actions.ExecuteSync {\n+\t\t\tif slices.Contains(c.CommandAllowList, cmd) {\n+\t\t\t\tallowedSync = append(allowedSync, cmd)\n+\t\t\t} else {\n+\t\t\t\tlogger.Warn(logSender, \"\", \"Command %q blocked - not in allowlist\", cmd)\n+\t\t\t}\n+\t\t}\n+\t\tConfig.Actions.ExecuteSync = util.RemoveDuplicates(allowedSync, true)\n+\n+\t\t// Filter asynchronous commands\n+\t\tvar allowedAsync []string\n+\t\tfor _, cmd := range c.Actions.ExecuteOn {\n+\t\t\tif slices.Contains(c.CommandAllowList, cmd) {\n+\t\t\t\tallowedAsync = append(allowedAsync, cmd)\n+\t\t\t} else {\n+\t\t\t\tlogger.Warn(logSender, \"\", \"Command %q blocked - not in allowlist\", cmd)\n+\t\t\t}\n+\t\t}\n+\t\tConfig.Actions.ExecuteOn = util.RemoveDuplicates(allowedAsync, true)\n+\n+\t\tlogger.Info(logSender, \"\", \"Command allowlist enforced: %d sync/%d async commands allowed\",\n+\t\t\tlen(Config.Actions.ExecuteSync), len(Config.Actions.ExecuteOn))\n+\t} else {\n+\t\t// Disable system commands by default per security best practices\n+\t\tConfig.Actions.ExecuteSync = nil\n+\t\tConfig.Actions.ExecuteOn = nil\n+\t\tlogger.Info(logSender, \"\", \"System command execution DISABLED by default. Enable via CommandAllowList configuration.\")\n+\t}\n+\n \tConfig.ProxyAllowed = util.RemoveDuplicates(Config.ProxyAllowed, true)\n \tConfig.idleLoginTimeout = 2 * time.Minute\n \tConfig.idleTimeoutAsDuration = time.Duration(Config.IdleTimeout) * time.Minute\n\n"}
{"cve": "CVE-2024-56362", "fix_patch": "--- a/core/auth/auth.go\n+++ b/core/auth/auth.go\n@@ -21,17 +21,56 @@\n \tTokenAuth *jwtauth.JWTAuth\n )\n \n+// Add utils import (already exists in file but included for completeness)\n+// import \"github.com/navidrome/navidrome/utils\"\n+\n func Init(ds model.DataStore) {\n \tonce.Do(func() {\n \t\tlog.Info(\"Setting Session Timeout\", \"value\", conf.Server.SessionTimeout)\n+\t\t\n+\t\t// Get or generate JWT secret\n \t\tsecret, err := ds.Property(context.TODO()).Get(consts.JWTSecretKey)\n \t\tif err != nil || secret == \"\" {\n-\t\t\tlog.Error(\"No JWT secret found in DB. Setting a temp one, but please report this error\", err)\n+\t\t\tlog.Info(\"No JWT secret found in DB. Generating new one\")\n \t\t\tsecret = uuid.NewString()\n+\t\t\t// Encrypt new secret before storage\n+\t\t\tencryptedSecret, err := encryptSecret(secret)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Fatal(\"Failed to encrypt JWT secret\", err)\n+\t\t\t}\n+\t\t\tif err := ds.Property(context.TODO()).Set(consts.JWTSecretKey, encryptedSecret); err != nil {\n+\t\t\t\tlog.Fatal(\"Failed to store JWT secret\", err)\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// Decrypt existing secret\n+\t\t\tdecryptedSecret, err := decryptSecret(secret)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Fatal(\"Failed to decrypt JWT secret\", err)\n+\t\t\t}\n+\t\t\tsecret = decryptedSecret\n \t\t}\n+\n \t\tSecret = []byte(secret)\n \t\tTokenAuth = jwtauth.New(\"HS256\", Secret, nil)\n \t})\n+}\n+\n+// encryptSecret uses the encryption key from config to encrypt sensitive data\n+func encryptSecret(plaintext string) (string, error) {\n+\tencKey := conf.Server.EncryptionKey\n+\tif len(encKey) == 0 {\n+\t\treturn \"\", log.NewError(\"Encryption key not configured\")\n+\t}\n+\treturn utils.Encrypt(context.TODO(), encKey, plaintext)\n+}\n+\n+// decryptSecret uses the encryption key from config to decrypt sensitive data\n+func decryptSecret(ciphertext string) (string, error) {\n+\tencKey := conf.Server.EncryptionKey\n+\tif len(encKey) == 0 {\n+\t\treturn \"\", log.NewError(\"Encryption key not configured\")\n+\t}\n+\treturn utils.Decrypt(context.TODO(), encKey, ciphertext)\n }\n \n func createBaseClaims() map[string]any {\n\n--- a/utils/encrypt.go\n+++ b/utils/encrypt.go\n@@ -37,26 +37,33 @@\n }\n \n func Decrypt(ctx context.Context, encKey []byte, encData string) (string, error) {\n-\tenc, _ := base64.StdEncoding.DecodeString(encData)\n+\tenc, err := base64.StdEncoding.DecodeString(encData)\n+\tif err != nil {\n+\t\tlog.Error(ctx, \"Could not decode base64\", err)\n+\t\treturn \"\", err\n+\t}\n \n \tblock, err := aes.NewCipher(encKey)\n \tif err != nil {\n-\t\tlog.Error(ctx, \"Could not create a cipher\", err)\n+\t\tlog.Error(ctx, \"Could not create cipher\", err)\n \t\treturn \"\", err\n \t}\n \n \taesGCM, err := cipher.NewGCM(block)\n \tif err != nil {\n-\t\tlog.Error(ctx, \"Could not create a GCM\", err)\n+\t\tlog.Error(ctx, \"Could not create GCM\", err)\n \t\treturn \"\", err\n \t}\n \n \tnonceSize := aesGCM.NonceSize()\n+\tif len(enc) < nonceSize {\n+\t\treturn \"\", log.NewError(\"Invalid ciphertext\")\n+\t}\n+\n \tnonce, ciphertext := enc[:nonceSize], enc[nonceSize:]\n-\n \tplaintext, err := aesGCM.Open(nil, nonce, ciphertext, nil)\n \tif err != nil {\n-\t\tlog.Error(ctx, \"Could not decrypt password\", err)\n+\t\tlog.Error(ctx, \"Decryption failed\", err)\n \t\treturn \"\", err\n \t}\n \n\n"}
{"cve": "CVE-2025-24806", "fix_patch": "--- a/internal/handlers/handler_firstfactor.go\n+++ b/internal/handlers/handler_firstfactor.go\n@@ -31,7 +31,18 @@\n \t\t\treturn\n \t\t}\n \n-\t\tif bannedUntil, err := ctx.Providers.Regulator.Regulate(ctx, bodyJSON.Username); err != nil {\n+\t\t// Get user details first to ensure we use the effective username for regulation\n+\t\tuserDetails, err := ctx.Providers.UserProvider.GetDetails(bodyJSON.Username)\n+\t\tif err != nil {\n+\t\t\tctx.Logger.WithError(err).Errorf(logFmtErrObtainProfileDetails, regulation.AuthType1FA, bodyJSON.Username)\n+\n+\t\t\trespondUnauthorized(ctx, messageAuthenticationFailed)\n+\n+\t\t\treturn\n+\t\t}\n+\n+\t\teffectiveUsername := userDetails.Username\n+\t\tif bannedUntil, err := ctx.Providers.Regulator.Regulate(ctx, effectiveUsername); err != nil {\n \t\t\tif errors.Is(err, regulation.ErrUserIsBanned) {\n \t\t\t\t_ = markAuthenticationAttempt(ctx, false, &bannedUntil, bodyJSON.Username, regulation.AuthType1FA, nil)\n \n@@ -49,7 +60,7 @@\n \n \t\tuserPasswordOk, err := ctx.Providers.UserProvider.CheckUserPassword(bodyJSON.Username, bodyJSON.Password)\n \t\tif err != nil {\n-\t\t\t_ = markAuthenticationAttempt(ctx, false, nil, bodyJSON.Username, regulation.AuthType1FA, err)\n+\t\t\t_ = markAuthenticationAttempt(ctx, false, nil, effectiveUsername, regulation.AuthType1FA, err)\n \n \t\t\trespondUnauthorized(ctx, messageAuthenticationFailed)\n \n@@ -57,14 +68,14 @@\n \t\t}\n \n \t\tif !userPasswordOk {\n-\t\t\t_ = markAuthenticationAttempt(ctx, false, nil, bodyJSON.Username, regulation.AuthType1FA, nil)\n+\t\t\t_ = markAuthenticationAttempt(ctx, false, nil, effectiveUsername, regulation.AuthType1FA, nil)\n \n \t\t\trespondUnauthorized(ctx, messageAuthenticationFailed)\n \n \t\t\treturn\n \t\t}\n \n-\t\tif err = markAuthenticationAttempt(ctx, true, nil, bodyJSON.Username, regulation.AuthType1FA, nil); err != nil {\n+\t\tif err = markAuthenticationAttempt(ctx, true, nil, effectiveUsername, regulation.AuthType1FA, nil); err != nil {\n \t\t\trespondUnauthorized(ctx, messageAuthenticationFailed)\n \n \t\t\treturn\n@@ -122,8 +133,8 @@\n \t\t\t}\n \t\t}\n \n-\t\t// Get the details of the given user from the user provider.\n-\t\tuserDetails, err := ctx.Providers.UserProvider.GetDetails(bodyJSON.Username)\n+\t\t// Reuse userDetails we already retrieved earlier\n+\t\terr = nil\n \t\tif err != nil {\n \t\t\tctx.Logger.WithError(err).Errorf(logFmtErrObtainProfileDetails, regulation.AuthType1FA, bodyJSON.Username)\n \n\n"}
{"cve": "CVE-2025-24882", "fix_patch": "--- a/types/manifest/manifest.go\n+++ b/types/manifest/manifest.go\n@@ -122,9 +122,21 @@\n \t\t\tcl, _ := strconv.Atoi(mc.header.Get(\"Content-Length\"))\n \t\t\tc.desc.Size = int64(cl)\n \t\t}\n-\t\tif c.desc.Digest == \"\" {\n-\t\t\tc.desc.Digest, _ = digest.Parse(mc.header.Get(\"Docker-Content-Digest\"))\n-\t\t}\n+\t\t\theaderDigestStr := mc.header.Get(\"Docker-Content-Digest\")\n+\t\t\tif headerDigestStr != \"\" {\n+\t\t\t\theaderDigest, err := digest.Parse(headerDigestStr)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, fmt.Errorf(\"invalid Docker-Content-Digest header: %w\", err)\n+\t\t\t\t}\n+\t\t\t\t// Verify header digest matches pinned digest if present\n+\t\t\t\tif c.desc.Digest != \"\" && c.desc.Digest != headerDigest {\n+\t\t\t\t\treturn nil, fmt.Errorf(\"header digest %s does not match pinned digest %s\", headerDigest, c.desc.Digest)\n+\t\t\t\t}\n+\t\t\t\t// Set digest from header if not already pinned\n+\t\t\t\tif c.desc.Digest == \"\" {\n+\t\t\t\t\tc.desc.Digest = headerDigest\n+\t\t\t\t}\n+\t\t\t}\n \t\tc.setRateLimit(mc.header)\n \t}\n \tif mc.orig != nil {\n\n"}
