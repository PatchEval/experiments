--- a/index.js
+++ b/index.js
@@ -138,6 +138,12 @@
         return result;
     };
 
+    // Validate null/undefined first
+    if (value === null || typeof value === 'undefined') {
+        if (pattern === null || typeof pattern === 'undefined') return res(true);
+        return res(false);
+    }
+
     // simple types pattern = number | boolean | symbol | bigint
     if ((typeof pattern === 'number') || (typeof pattern === 'symbol') || (typeof pattern === 'boolean') ||
         (typeof pattern === 'bigint') || (typeof pattern === 'undefined') || (pattern === null)) {
@@ -179,6 +185,10 @@
         // Patterns
         let logicalMatches = pattern.match(/^(!)?\[(.*)\](\?)?$/i);
         if (logicalMatches !== null) {
+            // Validate value is valid type before pattern comparison
+            if (typeof value !== 'string' && typeof value !== 'number') {
+                return res(false);
+            }
             const valid = comparePattern(value, logicalMatches[2]);
 
             // ------------------------> Deprecated
@@ -204,6 +214,8 @@
         let functionalRegexMatches = pattern.match(/^(?!=^|,)(!)?\{\/(.*)\/([a-z]*)\}(\?)?$/i);
         if (functionalRegexMatches !== null) {
             depricated('tag');
+            // Validate value is string before regex match
+            if (typeof value !== 'string') return res(false);
             let match = (String(value).match(new RegExp(functionalRegexMatches[2], functionalRegexMatches[3])) !== null);
             // Negation ? Operator
             if (typeof functionalRegexMatches[4] !== 'undefined') {
@@ -218,6 +230,8 @@
         let functionalFixedMatches = pattern.match(/^(!)?\{(.*)\}(\?)?$/i);
         if (functionalFixedMatches !== null) {
             depricated('tag');
+            // Validate value is string before comparison
+            if (typeof value !== 'string') return res(false);
             let match = (String(value) === String(functionalFixedMatches[2]));
             // Negation ? Operator
             if (typeof functionalFixedMatches[3] !== 'undefined') {
@@ -233,12 +247,33 @@
         return res(value === pattern);
     }
 
+    // Array pattern validation
+    if (pattern.constructor === Array) {
+        // Pattern is array but value is not - fail validation
+        if (value.constructor !== Array) return res(false);
+        
+        // Validate array structure before processing
+        if (!Array.isArray(value) || value.length === 0) return res(false);
+        
+        // For array patterns, validate all elements match the first pattern
+        const firstPattern = pattern[0];
+        for (let i = 0; i < value.length; i++) {
+            if (!compare(value[i], firstPattern, options)) {
+                return res(false);
+            }
+        }
+        return res(true);
+    }
+
     // Constructor is JpvObject
     if (typeof pattern === 'object' && pattern.constructor === JpvObject) {
         if (pattern.type === 'not') {
             return res(!compare(value, pattern.value, options));
         }
         if (pattern.type === 'and') {
+            // Validate pattern array is valid before iteration
+            if (!Array.isArray(pattern.value) || pattern.value.length === 0) return res(false);
+            
             for (let i = 0; i < pattern.value.length; i++) {
                 if (!compare(value, pattern.value[i])) {
                     return res(false);
@@ -247,6 +282,9 @@
             return true;
         }
         if (pattern.type === 'or') {
+            // Validate pattern array is valid before iteration
+            if (!Array.isArray(pattern.value) || pattern.value.length === 0) return res(false);
+            
             for (let i = 0; i < pattern.value.length; i++) {
                 if (compare(value, pattern.value[i])) {
                     return true;
@@ -264,21 +302,28 @@
         }
 
         if (pattern.type === 'is') {
+            // Validate value type before pattern comparison
+            if (typeof value !== 'string' && typeof value !== 'number') return res(false);
             return res(comparePattern(value, pattern.value));
         }
     }
 
     // pattern = object
     if (typeof pattern === 'object') {
-        if (value !== null) {
-            return res(value.constructor === pattern.constructor);
-        }
-        return res(value === pattern);
+        // Validate both are objects before constructor comparison
+        if (value === null || pattern === null) return res(value === pattern);
+        if (typeof value !== 'object' || typeof pattern !== 'object') return res(false);
+        
+        return res(value.constructor === pattern.constructor);
     }
 
     // pattern is a function
     if (typeof pattern === 'function') {
-        return res(!!pattern(value));
+        try {
+            return res(!!pattern(value));
+        } catch (e) {
+            return res(false);
+        }
     }
 
     throw new Error('invalid data type');

