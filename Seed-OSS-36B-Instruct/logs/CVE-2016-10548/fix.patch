--- a/index.js
+++ b/index.js
@@ -30,6 +30,118 @@
 function reduceCSSCalc(value, decimalPrecision) {
   stack = 0
   decimalPrecision = Math.pow(10, decimalPrecision === undefined ? 5 : decimalPrecision)
+
+  // Safe arithmetic evaluator (replaces eval to prevent code injection)
+  function tokenize(expr) {
+    const tokens = [];
+    let numBuffer = '';
+    const ops = '+*-/()';
+    let expectNumber = true;
+
+    for (let i = 0; i < expr.length; i++) {
+      const char = expr[i];
+      if (char === ' ') {
+        if (numBuffer) {
+          tokens.push(numBuffer);
+          numBuffer = '';
+          expectNumber = false;
+        }
+        continue;
+      }
+
+      if (ops.includes(char)) {
+        if (char === '-' && expectNumber) {
+          numBuffer += char;
+          expectNumber = false;
+        } else {
+          if (numBuffer) {
+            tokens.push(numBuffer);
+            numBuffer = '';
+            expectNumber = false;
+          }
+          tokens.push(char);
+          expectNumber = (char === '(');
+        }
+      } else {
+        numBuffer += char;
+        expectNumber = false;
+      }
+    }
+
+    if (numBuffer) tokens.push(numBuffer);
+
+    for (let i = 0; i < tokens.length; i++) {
+      const token = tokens[i];
+      if (token === '-' && (i === 0 || tokens[i-1] === '(' || ops.includes(tokens[i-1]))) {
+        if (i+1 >= tokens.length || !/^\d+(\.\d+)?$/.test(tokens[i+1])) throw new Error('Invalid unary minus');
+        tokens[i+1] = '-' + tokens[i+1];
+        tokens.splice(i, 1);
+      }
+    }
+
+    return tokens;
+  }
+
+  function shuntingYard(tokens) {
+    const output = [];
+    const stack = [];
+    const precedence = { '+': 1, '-': 1, '*': 2, '/': 2 };
+    const associativity = { '+': 'left', '-': 'left', '*': 'left', '/': 'left' };
+
+    for (let token of tokens) {
+      if (/^-?\d+(\.\d+)?$/.test(token)) {
+        output.push(token);
+      } else if (token === '(') {
+        stack.push(token);
+      } else if (token === ')') {
+        while (stack.length && stack[stack.length-1] !== '(') output.push(stack.pop());
+        stack.pop();
+      } else if (precedence[token]) {
+        while (stack.length && stack[stack.length-1] !== '(' && 
+               (precedence[stack[stack.length-1]] > precedence[token] || 
+                (precedence[stack[stack.length-1]] === precedence[token] && associativity[token] === 'left'))) {
+          output.push(stack.pop());
+        }
+        stack.push(token);
+      } else {
+        throw new Error('Invalid token: ' + token);
+      }
+    }
+
+    while (stack.length) output.push(stack.pop());
+    return output;
+  }
+
+  function evaluatePostfix(postfix) {
+    const stack = [];
+    for (let token of postfix) {
+      if (/^-?\d+(\.\d+)?$/.test(token)) {
+        stack.push(parseFloat(token));
+      } else {
+        const b = stack.pop();
+        const a = stack.pop();
+        switch (token) {
+          case '+': stack.push(a + b); break;
+          case '-': stack.push(a - b); break;
+          case '*': stack.push(a * b); break;
+          case '/': 
+            if (b === 0) throw new Error('Division by zero');
+            stack.push(a / b); 
+            break;
+          default: throw new Error('Unknown operator: ' + token);
+        }
+      }
+    }
+    if (stack.length !== 1) throw new Error('Invalid expression');
+    return stack[0];
+  }
+
+  function safeEval(expr) {
+    if (typeof expr !== 'string' || expr.trim() === '') throw new Error('Empty expression');
+    const tokens = tokenize(expr);
+    const postfix = shuntingYard(tokens);
+    return evaluatePostfix(postfix);
+  }
 
   /**
    * Evaluates an expression

