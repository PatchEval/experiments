--- a/oauthproxy.go
+++ b/oauthproxy.go
@@ -599,16 +599,23 @@
 
 // IsValidRedirect checks whether the redirect URL is whitelisted
 func (p *OAuthProxy) IsValidRedirect(redirect string) bool {
+	// First, decode any URL-encoded characters in the redirect
+	decodedRedirect, err := url.QueryUnescape(redirect)
+	if err != nil {
+		logger.Printf("Rejecting invalid redirect %q: failed to decode", redirect)
+		return false
+	}
+
 	switch {
-	case redirect == "":
+	case decodedRedirect == "":
 		// The user didn't specify a redirect, should fallback to `/`
 		return false
-	case strings.HasPrefix(redirect, "/") && !strings.HasPrefix(redirect, "//") && !invalidRedirectRegex.MatchString(redirect):
+	case strings.HasPrefix(decodedRedirect, "/") && !strings.HasPrefix(decodedRedirect, "//") && !invalidRedirectRegex.MatchString(decodedRedirect):
 		return true
-	case strings.HasPrefix(redirect, "http://") || strings.HasPrefix(redirect, "https://"):
-		redirectURL, err := url.Parse(redirect)
+	case strings.HasPrefix(decodedRedirect, "http://") || strings.HasPrefix(decodedRedirect, "https://"):
+		redirectURL, err := url.Parse(decodedRedirect)
 		if err != nil {
-			logger.Printf("Rejecting invalid redirect %q: scheme unsupported or missing", redirect)
+			logger.Printf("Rejecting invalid redirect %q: scheme unsupported or missing", decodedRedirect)
 			return false
 		}
 		redirectHostname := redirectURL.Hostname()
@@ -633,10 +640,10 @@
 			}
 		}
 
-		logger.Printf("Rejecting invalid redirect %q: domain / port not in whitelist", redirect)
+		logger.Printf("Rejecting invalid redirect %q: domain / port not in whitelist", decodedRedirect)
 		return false
 	default:
-		logger.Printf("Rejecting invalid redirect %q: not an absolute or relative URL", redirect)
+		logger.Printf("Rejecting invalid redirect %q: not an absolute or relative URL", decodedRedirect)
 		return false
 	}
 }

