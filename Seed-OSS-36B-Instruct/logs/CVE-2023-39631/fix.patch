--- a/numexpr/necompiler.py
+++ b/numexpr/necompiler.py
@@ -263,6 +263,49 @@
 def stringToExpression(s, types, context):
     """Given a string, convert it to a tree of ExpressionNode's.
     """
+    import ast
+
+    # Validate expression AST to prevent code injection
+    class _ExpressionValidator(ast.NodeVisitor):
+        def __init__(self, allowed_functions):
+            self.allowed_functions = set(allowed_functions)
+            self.blocked_nodes = {
+                ast.Import, ast.ImportFrom, ast.Assign, ast.AugAssign,
+                ast.Delete, ast.Print, ast.Raise, ast.Assert, ast.Pass,
+                ast.Break, ast.Continue, ast.For, ast.While, ast.If,
+                ast.Try, ast.ExceptHandler, ast.Finally, ast.ClassDef,
+                ast.FunctionDef, ast.Lambda, ast.Global, ast.Nonlocal,
+                ast.Eval, ast.Exec, ast.Expr
+            }
+            self.dangerous_builtins = {"__import__", "eval", "exec", "getattr", "setattr", "delattr", "open", "compile"}
+
+        def visit_Node(self, node):
+            if type(node) in self.blocked_nodes:
+                raise ValueError(f"Code injection attempt blocked: Disallowed node type {type(node).__name__}")
+            self.generic_visit(node)
+
+        def visit_Call(self, node):
+            if isinstance(node.func, ast.Name):
+                if node.func.id not in self.allowed_functions:
+                    raise ValueError(f"Code injection attempt blocked: Disallowed function {node.func.id}")
+            elif isinstance(node.func, ast.Attribute):
+                raise ValueError(f"Code injection attempt blocked: Attribute access in function call")
+            self.generic_visit(node)
+
+        def visit_Attribute(self, node):
+            raise ValueError(f"Code injection attempt blocked: Attribute access {node.attr}")
+
+        def visit_Name(self, node):
+            if node.id in self.dangerous_builtins:
+                raise ValueError(f"Code injection attempt blocked: Disallowed builtin {node.id}")
+            self.generic_visit(node)
+
+    # Get allowed functions from expressions module and validate input
+    allowed_functions = set(expressions.functions.keys())
+    tree = ast.parse(s, mode='eval')
+    validator = _ExpressionValidator(allowed_functions)
+    validator.visit(tree)
+
     old_ctx = expressions._context.get_current_context()
     try:
         expressions._context.set_new_context(context)

