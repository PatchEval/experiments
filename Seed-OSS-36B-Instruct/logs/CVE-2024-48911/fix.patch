--- a/opencanary/config.py
+++ b/opencanary/config.py
@@ -53,11 +53,20 @@
         self.__config = None
         self.__configfile = configfile
 
-        files = [
-            configfile,
-            "%s/.%s" % (expanduser("~"), configfile),
-            "/etc/opencanaryd/%s" % configfile,
-        ]
+        # Determine which config files to load based on privileges (CVE-2021-XXXX fix)
+        if os.geteuid() == 0:
+            # Running as root: skip user's home directory config to prevent privilege escalation
+            files = [
+                configfile,
+                "/etc/opencanaryd/%s" % configfile,
+            ]
+        else:
+            files = [
+                configfile,
+                "%s/.%s" % (expanduser("~"), configfile),
+                "/etc/opencanaryd/%s" % configfile,
+            ]
+
         print(
             "** We hope you enjoy using OpenCanary. For more open source Canary goodness, head over to canarytokens.org. **"
         )

--- a/opencanary/modules/portscan.py
+++ b/opencanary/modules/portscan.py
@@ -68,7 +68,14 @@
 
 
 def detectNFTables():
-    return b"nf_tables" in subprocess.check_output(["iptables", "--version"])
+    try:
+        return b"nf_tables" in subprocess.check_output(
+            ["iptables", "--version"], 
+            stderr=subprocess.PIPE,
+            universal_newlines=False
+        )
+    except (subprocess.SubprocessError, FileNotFoundError):
+        return False
 
 
 class CanaryPortscan(CanaryService):
@@ -89,13 +96,24 @@
         self.config = config
 
     def getIptablesPath(self):
+        # Only allow trusted iptables paths to prevent command injection (CVE-2021-XXXX fix)
+        trusted_paths = ["/sbin/iptables", "/usr/sbin/iptables", "/usr/bin/iptables"]
+        
         if self.iptables_path:
+            if self.iptables_path not in trusted_paths:
+                raise ValueError(f"Invalid iptables path: {self.iptables_path} (must be in {trusted_paths})")
             return self.iptables_path
 
         if detectNFTables():
-            return shutil.which("iptables-legacy")
-
-        return shutil.which("iptables") or "/sbin/iptables"
+            path = shutil.which("iptables-legacy")
+            if path not in trusted_paths:
+                raise ValueError(f"Invalid iptables-legacy path: {path} (must be in {trusted_paths})")
+            return path
+
+        path = shutil.which("iptables") or "/sbin/iptables"
+        if path not in trusted_paths:
+            raise ValueError(f"Invalid iptables path: {path} (must be in {trusted_paths})")
+        return path
 
     def startYourEngines(self, reactor=None):
         # Logging rules for loopback interface.

