--- a/core/auth/auth.go
+++ b/core/auth/auth.go
@@ -21,17 +21,56 @@
 	TokenAuth *jwtauth.JWTAuth
 )
 
+// Add utils import (already exists in file but included for completeness)
+// import "github.com/navidrome/navidrome/utils"
+
 func Init(ds model.DataStore) {
 	once.Do(func() {
 		log.Info("Setting Session Timeout", "value", conf.Server.SessionTimeout)
+		
+		// Get or generate JWT secret
 		secret, err := ds.Property(context.TODO()).Get(consts.JWTSecretKey)
 		if err != nil || secret == "" {
-			log.Error("No JWT secret found in DB. Setting a temp one, but please report this error", err)
+			log.Info("No JWT secret found in DB. Generating new one")
 			secret = uuid.NewString()
+			// Encrypt new secret before storage
+			encryptedSecret, err := encryptSecret(secret)
+			if err != nil {
+				log.Fatal("Failed to encrypt JWT secret", err)
+			}
+			if err := ds.Property(context.TODO()).Set(consts.JWTSecretKey, encryptedSecret); err != nil {
+				log.Fatal("Failed to store JWT secret", err)
+			}
+		} else {
+			// Decrypt existing secret
+			decryptedSecret, err := decryptSecret(secret)
+			if err != nil {
+				log.Fatal("Failed to decrypt JWT secret", err)
+			}
+			secret = decryptedSecret
 		}
+
 		Secret = []byte(secret)
 		TokenAuth = jwtauth.New("HS256", Secret, nil)
 	})
+}
+
+// encryptSecret uses the encryption key from config to encrypt sensitive data
+func encryptSecret(plaintext string) (string, error) {
+	encKey := conf.Server.EncryptionKey
+	if len(encKey) == 0 {
+		return "", log.NewError("Encryption key not configured")
+	}
+	return utils.Encrypt(context.TODO(), encKey, plaintext)
+}
+
+// decryptSecret uses the encryption key from config to decrypt sensitive data
+func decryptSecret(ciphertext string) (string, error) {
+	encKey := conf.Server.EncryptionKey
+	if len(encKey) == 0 {
+		return "", log.NewError("Encryption key not configured")
+	}
+	return utils.Decrypt(context.TODO(), encKey, ciphertext)
 }
 
 func createBaseClaims() map[string]any {

--- a/utils/encrypt.go
+++ b/utils/encrypt.go
@@ -37,26 +37,33 @@
 }
 
 func Decrypt(ctx context.Context, encKey []byte, encData string) (string, error) {
-	enc, _ := base64.StdEncoding.DecodeString(encData)
+	enc, err := base64.StdEncoding.DecodeString(encData)
+	if err != nil {
+		log.Error(ctx, "Could not decode base64", err)
+		return "", err
+	}
 
 	block, err := aes.NewCipher(encKey)
 	if err != nil {
-		log.Error(ctx, "Could not create a cipher", err)
+		log.Error(ctx, "Could not create cipher", err)
 		return "", err
 	}
 
 	aesGCM, err := cipher.NewGCM(block)
 	if err != nil {
-		log.Error(ctx, "Could not create a GCM", err)
+		log.Error(ctx, "Could not create GCM", err)
 		return "", err
 	}
 
 	nonceSize := aesGCM.NonceSize()
+	if len(enc) < nonceSize {
+		return "", log.NewError("Invalid ciphertext")
+	}
+
 	nonce, ciphertext := enc[:nonceSize], enc[nonceSize:]
-
 	plaintext, err := aesGCM.Open(nil, nonce, ciphertext, nil)
 	if err != nil {
-		log.Error(ctx, "Could not decrypt password", err)
+		log.Error(ctx, "Decryption failed", err)
 		return "", err
 	}
 

