--- a/mlflow/server/handlers.py
+++ b/mlflow/server/handlers.py
@@ -598,9 +598,27 @@
 
     tags = [ExperimentTag(tag.key, tag.value) for tag in request_message.tags]
 
-    # Validate query string in artifact location to prevent attacks
-    parsed_artifact_locaion = urllib.parse.urlparse(request_message.artifact_location)
-    validate_query_string(parsed_artifact_locaion.query)
+    # Validate query string and fragment in artifact location to prevent attacks
+    parsed_artifact_location = urllib.parse.urlparse(request_message.artifact_location)
+    validate_query_string(parsed_artifact_location.query)
+    
+    # Validate fragment for path traversal attacks
+    if parsed_artifact_location.fragment:
+        fragment = urllib.parse.unquote(parsed_artifact_location.fragment)
+        if "\x00" in fragment:
+            raise MlflowException(
+                f"Invalid artifact location: '{request_message.artifact_location}'. Fragment contains null byte.",
+                error_code=INVALID_PARAMETER_VALUE,
+            )
+        # Normalize and resolve fragment to check for relative paths
+        normalized_fragment = re.sub(r"/+", "/", fragment.rstrip("/"))
+        resolved_fragment = pathlib.Path(normalized_fragment).resolve().as_posix()
+        _, resolved_fragment_path = os.path.splitdrive(resolved_fragment)
+        if resolved_fragment_path != normalized_fragment:
+            raise MlflowException(
+                f"Invalid artifact location: '{request_message.artifact_location}'. Fragment contains relative path traversal.",
+                error_code=INVALID_PARAMETER_VALUE,
+            )
 
     experiment_id = _get_tracking_store().create_experiment(
         request_message.name, request_message.artifact_location, tags
@@ -1698,6 +1716,8 @@
     "file://path/to/../../../../some/where/you/should/not/be"
     "mlflow-artifacts://host:port/..%2f..%2f..%2f..%2f"
     "http://host:port/api/2.0/mlflow-artifacts/artifacts%00"
+    "mlflow-artifacts://host:port/path#../../../../etc/passwd"
+    "http://host:port/path#../etc/passwd"
     """
     invalid_source_error_message = (
         f"Invalid model version source: '{source}'. If supplying a source as an http, https, "
@@ -1706,18 +1726,28 @@
         "Please provide an absolute path."
     )
 
-    while (unquoted := urllib.parse.unquote_plus(source)) != source:
-        source = unquoted
-    source_path = re.sub(r"/+", "/", urllib.parse.urlparse(source).path.rstrip("/"))
-    if "\x00" in source_path:
-        raise MlflowException(invalid_source_error_message, INVALID_PARAMETER_VALUE)
-    resolved_source = pathlib.Path(source_path).resolve().as_posix()
-    # NB: drive split is specifically for Windows since WindowsPath.resolve() will append the
-    # drive path of the pwd to a given path. We don't care about the drive here, though.
-    _, resolved_path = os.path.splitdrive(resolved_source)
-
-    if resolved_path != source_path:
-        raise MlflowException(invalid_source_error_message, INVALID_PARAMETER_VALUE)
+    parsed_source = urllib.parse.urlparse(source)
+    parts_to_check = [parsed_source.path, parsed_source.fragment]
+
+    for part in parts_to_check:
+        if not part:
+            continue
+        # Fully unquote any URL-encoded characters
+        unquoted_part = part
+        while (next_unquoted := urllib.parse.unquote_plus(unquoted_part)) != unquoted_part:
+            unquoted_part = next_unquoted
+        # Check for null bytes (common in path traversal attacks)
+        if "\x00" in unquoted_part:
+            raise MlflowException(invalid_source_error_message, INVALID_PARAMETER_VALUE)
+        # Normalize path to handle redundant separators and remove trailing slash
+        normalized_part = re.sub(r"/+", "/", unquoted_part.rstrip("/"))
+        # Resolve the path to check for relative traversal attempts
+        resolved_part = pathlib.Path(normalized_part).resolve().as_posix()
+        # Split drive letter for Windows compatibility (ignore drive part)
+        _, resolved_part_path = os.path.splitdrive(resolved_part)
+        # If resolved path differs from original, relative traversal was attempted
+        if resolved_part_path != normalized_part:
+            raise MlflowException(invalid_source_error_message, INVALID_PARAMETER_VALUE)
 
 
 def _validate_source(source: str, run_id: str) -> None:

