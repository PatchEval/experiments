--- a/lib/path-reservations.js
+++ b/lib/path-reservations.js
@@ -19,17 +19,31 @@
   // fn => {paths:[path,...], dirs:[path, ...]}
   const reservations = new Map()
 
-  // return a set of parent dirs for a given path
-  const getDirs = path =>
-    path.split('/').slice(0, -1).reduce((set, path) =>
-      set.length ? set.concat(normPath(join(set[set.length - 1], path)))
-      : [path], [])
+  // Return a set of parent dirs for a given path with proper normalization
+  const getDirs = path => {
+    const parts = path.split('/').slice(0, -1)
+    return parts.reduce((dirs, part) => {
+      const newPath = dirs.length 
+        ? normPath(join(dirs[dirs.length - 1], part))
+        : normPath(part)
+      return dirs.concat(newPath)
+    }, [])
+  }
 
-  // functions currently running
+  // Check if a path exists and is not a symlink
+  const isRealDirectory = async (path) => {
+    try {
+      const stats = await fs.promises.lstat(path)
+      return stats.isDirectory() && !stats.isSymbolicLink()
+    } catch {
+      return false
+    }
+  }
+
+  // Functions currently running
   const running = new Set()
 
-  // return the queues for each path the function cares about
-  // fn => {paths, dirs}
+  // Return the queues for each path the function cares about
   const getQueues = fn => {
     const res = reservations.get(fn)
     /* istanbul ignore if - unpossible */
@@ -41,15 +55,15 @@
     }
   }
 
-  // check if fn is first in line for all its paths, and is
+  // Check if fn is first in line for all its paths, and is
   // included in the first set for all its dir queues
   const check = fn => {
     const {paths, dirs} = getQueues(fn)
-    return paths.every(q => q[0] === fn) &&
-      dirs.every(q => q[0] instanceof Set && q[0].has(fn))
+    return paths.every(q => q && q[0] === fn) &&
+      dirs.every(q => q && q[0] instanceof Set && q[0].has(fn))
   }
 
-  // run the function if it's first in line and not already running
+  // Run the function if it's first in line and not already running
   const run = fn => {
     if (running.has(fn) || !check(fn))
       return false
@@ -67,30 +81,33 @@
 
     paths.forEach(path => {
       const q = queues.get(path)
-      assert.equal(q[0], fn)
-      if (q.length === 1)
-        queues.delete(path)
-      else {
-        q.shift()
-        if (typeof q[0] === 'function')
-          next.add(q[0])
-        else
-          q[0].forEach(fn => next.add(fn))
+      if (q) {
+        assert.equal(q[0], fn)
+        if (q.length === 1)
+          queues.delete(path)
+        else {
+          q.shift()
+          if (typeof q[0] === 'function')
+            next.add(q[0])
+          else
+            q[0].forEach(fn => next.add(fn))
+        }
       }
     })
 
     dirs.forEach(dir => {
       const q = queues.get(dir)
-      assert(q[0] instanceof Set)
-      if (q[0].size === 1 && q.length === 1) {
-        queues.delete(dir)
-      } else if (q[0].size === 1) {
-        q.shift()
-
-        // must be a function or else the Set would've been reused
-        next.add(q[0])
-      } else
-        q[0].delete(fn)
+      if (q) {
+        assert(q[0] instanceof Set)
+        if (q[0].size === 1 && q.length === 1) {
+          queues.delete(dir)
+        } else if (q[0].size === 1) {
+          q.shift()
+          next.add(q[0])
+        } else {
+          q[0].delete(fn)
+        }
+      }
     })
     running.delete(fn)
 
@@ -98,19 +115,41 @@
     return true
   }
 
-  const reserve = (paths, fn) => {
-    paths = paths.map(p => normPath(join(p)).toLowerCase())
+  const reserve = async (paths, fn) => {
+    // Enhanced path normalization with security checks
+    const normalizedPaths = paths.map(p => {
+      let path = normPath(join(p))
+      // Add additional normalization for Unicode and Windows paths
+      path = path.normalize('NFC') // Unicode normalization
+      return path.toLowerCase()
+    })
+
+    // Get directory paths with proper normalization
     const dirs = new Set(
-      paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b))
+      normalizedPaths.map(path => getDirs(path)).reduce((a, b) => a.concat(b))
     )
-    reservations.set(fn, {dirs, paths})
-    paths.forEach(path => {
+
+    // Verify all directories exist and are not symlinks
+    const allDirsReal = await Promise.all(
+      [...dirs].map(dir => isRealDirectory(dir))
+    )
+
+    if (!allDirsReal.every(Boolean)) {
+      return false
+    }
+
+    reservations.set(fn, {dirs, paths: normalizedPaths})
+    
+    // Add path reservations
+    normalizedPaths.forEach(path => {
       const q = queues.get(path)
       if (!q)
         queues.set(path, [fn])
       else
         q.push(fn)
     })
+
+    // Add directory reservations
     dirs.forEach(dir => {
       const q = queues.get(dir)
       if (!q)

