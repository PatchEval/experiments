--- a/internal/app/trustd/internal/reg/reg.go
+++ b/internal/app/trustd/internal/reg/reg.go
@@ -6,6 +6,8 @@
 
 import (
 	"context"
+	"encoding/pem"
+	"fmt"
 
 	"github.com/cosi-project/runtime/pkg/resource"
 	"github.com/cosi-project/runtime/pkg/safe"
@@ -39,11 +41,48 @@
 		return nil, err
 	}
 
-	// TODO: Verify that the request is coming from the IP addresss declared in
-	// the CSR.
-	signed, err := x509.NewCertificateFromCSRBytes(osRoot.TypedSpec().CA.Crt, osRoot.TypedSpec().CA.Key, in.Csr)
+	// Parse and validate CSR format
+	var csr *x509.CertificateRequest
+	rest := in.Csr
+	for len(rest) > 0 {
+		var p []byte
+		p, rest = pem.Decode(rest)
+		if p == nil {
+			break
+		}
+		if p.Type == "CERTIFICATE REQUEST" {
+			csr, err = x509.ParseCertificateRequest(p)
+			if err != nil {
+				return nil, fmt.Errorf("failed to parse CSR: %w", err)
+			}
+			break
+		}
+	}
+
+	if csr == nil {
+		return nil, fmt.Errorf("no valid certificate request found in input")
+	}
+
+	// Validate worker node requirements (implements TODO + client auth check)
+	if len(csr.IPAddresses) == 0 {
+		return nil, fmt.Errorf("CSR must include at least one IP address")
+	}
+
+	hasClientAuth := false
+	for _, eku := range csr.ExtendedKeyUsage {
+		if eku == x509.ExtendedKeyUsageClientAuth {
+			hasClientAuth = true
+			break
+		}
+	}
+	if !hasClientAuth {
+		return nil, fmt.Errorf("CSR must request client authentication (Extended Key Usage)")
+	}
+
+	// Sign validated CSR
+	signed, err := x509.NewCertificateFromCSRBytes(osRoot.TypedSpec().CA.Crt, osRoot.TypedSpec().CA.Key, csr.Raw)
 	if err != nil {
-		return
+		return nil, err
 	}
 
 	resp = &securityapi.CertificateResponse{

