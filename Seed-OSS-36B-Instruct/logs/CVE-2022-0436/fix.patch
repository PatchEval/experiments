--- a/lib/grunt/file.js
+++ b/lib/grunt/file.js
@@ -292,18 +292,39 @@
 // Read a file, optionally processing its content, then write the output.
 // Or read a directory, recursively creating directories, reading files,
 // processing content, writing output.
-file.copy = function copy(srcpath, destpath, options) {
-  if (file.isDir(srcpath)) {
+file.copy = function copy(srcpath, destpath, options, srcRoot) {
+  // Initialize srcRoot with original source path on top-level call
+  if (srcRoot === undefined) {
+    srcRoot = srcpath;
+  }
+
+  // Check if path exists and is a directory (without following symlinks)
+  var isDir = file.exists(srcpath) && fs.lstatSync(srcpath).isDirectory();
+  if (isDir) {
     // Copy a directory, recursively.
     // Explicitly create new dest directory.
     file.mkdir(destpath);
     // Iterate over all sub-files/dirs, recursing.
     fs.readdirSync(srcpath).forEach(function(filepath) {
-      copy(path.join(srcpath, filepath), path.join(destpath, filepath), options);
+      var currentSrc = path.join(srcpath, filepath);
+      // Compute relative path from original source root to current source
+      var relativePath = path.relative(srcRoot, currentSrc);
+      // Prevent path traversal by blocking paths with ".." components
+      if (relativePath.split(path.sep).some(function(part) { return part === '..'; })) {
+        return;
+      }
+      var currentDest = path.join(destpath, relativePath);
+      copy(currentSrc, currentDest, options, srcRoot);
     });
   } else {
+    // For single files, ensure we're not escaping the source root
+    var relativePath = path.relative(srcRoot, srcpath);
+    if (relativePath.split(path.sep).some(function(part) { return part === '..'; })) {
+      return;
+    }
+    var currentDest = path.join(destpath, relativePath);
     // Copy a single file.
-    file._copy(srcpath, destpath, options);
+    file._copy(srcpath, currentDest, options);
   }
 };
 

