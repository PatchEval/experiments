--- a/pdf_ocr.go
+++ b/pdf_ocr.go
@@ -3,6 +3,7 @@
 package docconv
 
 import (
+	"bytes"
 	"fmt"
 	"io"
 	"io/ioutil"
@@ -110,13 +111,63 @@
 
 // PdfHasImage verify if `path` (PDF) has images
 func PDFHasImage(path string) bool {
-	cmd := "pdffonts -l 5 %s | tail -n +3 | cut -d' ' -f1 | sort | uniq"
-	out, err := exec.Command("bash", "-c", fmt.Sprintf(cmd, path)).Output()
-	if err != nil {
-		log.Println(err)
-		return false
-	}
-	if string(out) == "" {
+	var out bytes.Buffer
+
+	// Create pipeline: pdffonts → tail → cut → sort → uniq (no shell involved)
+	pdfCmd := exec.Command("pdffonts", "-l", "5", path)
+	stdout, err := pdfCmd.StdoutPipe()
+	if err != nil {
+		log.Println(err)
+		return false
+	}
+
+	tailCmd := exec.Command("tail", "-n", "+3")
+	tailCmd.Stdin = stdout
+	stdout, err = tailCmd.StdoutPipe()
+	if err != nil {
+		log.Println(err)
+		return false
+	}
+
+	cutCmd := exec.Command("cut", "-d", " ", "-f1")
+	cutCmd.Stdin = stdout
+	stdout, err = cutCmd.StdoutPipe()
+	if err != nil {
+		log.Println(err)
+		return false
+	}
+
+	sortCmd := exec.Command("sort")
+	sortCmd.Stdin = stdout
+	stdout, err = sortCmd.StdoutPipe()
+	if err != nil {
+		log.Println(err)
+		return false
+	}
+
+	uniqCmd := exec.Command("uniq")
+	uniqCmd.Stdin = stdout
+	uniqCmd.Stdout = &out
+
+	// Start all pipeline commands
+	cmds := []*exec.Cmd{pdfCmd, tailCmd, cutCmd, sortCmd, uniqCmd}
+	for _, cmd := range cmds {
+		if err := cmd.Start(); err != nil {
+			log.Println(err)
+			return false
+		}
+	}
+
+	// Wait for all commands to complete with error checking
+	for _, cmd := range cmds {
+		if err := cmd.Wait(); err != nil {
+			log.Println(err)
+			return false
+		}
+	}
+
+	// Preserve original logic: empty output → return true
+	if string(out.Bytes()) == "" {
 		return true
 	}
 	return false

